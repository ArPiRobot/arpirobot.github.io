{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArPiRobot Framework","text":"<p>A collection of programs, libraries, and tools to make building robots easy and accessible.</p> <ol> <li> <p>Easy for education use</p> Details <p>This means that it not only needs to be easy to code with, but easy to use without assuming lots of experience with computers. Most existing solutions require knowledge of SSH, various types or wiring, writing code to communicate with different devices, creating a from-scratch wireless control solution, setting up a development environment from scratch or writing code with a command line editor. This may work well for many experienced developers, but it does not often for new developers and people who want to just get started quickly.</p> </li> <li> <p>Provide a complete setup from writing code to deploying it, to controlling the robot</p> Details <p>The ArPiRobot project provides an easy to use development environment, pre-configured OS images for the robot, a GUI tool to deploy code from your PC to the robot, a GUI tool to control the robot wirelessly, scripts to manage everything from WiFi to launching the program on boot, and a program libraries to interface with many devices. Everything has been designed to make it easy to use and just get started making a robot work instead of spending time on communicating with motor controllers, WiFi, gamepads, bluetooth,  etc.</p> </li> <li> <p>Support low-power, low-cost devices</p> Details <p>Not only does this make it more accessible (in line with the education use goal), but there's no reason you couldn't use it on a more powerful device. It just means that more power is left for demanding tasks such as camera streaming, vision processing, etc. The core functionality of the framework is designed to work even on the single-core Raspberry Pi Zero W and more advanced features are all designed for and tested on the Raspberry Pi 3A+.</p> </li> </ol>"},{"location":"#overview","title":"Overview","text":"<p>The ArPiRobot Framework include various components to make building a robot easy.</p> Drive Station <p>The drive station runs on your computer and makes it easy to communicate with a robot's program wireless to control the robot or send information to/from the robot.</p> <p></p> Deploy Tool <p>The deploy tool runs on your computer and makes it easy to configure the robot and deploy your programs to the robot. No command line tools required.</p> <p></p> Visual Studio Code Extension <p>The provided extension makes it easy to write robot programs using Visual Studio Code. Visual Studio code is a code editor / development environment which provides suggestions and error detection for Python and C++.</p> <p></p> Operating System Images <p>Pre-configured Operating system images are provided for supported single board computers. All you have to do is write them to an SD card.</p> <p></p> Core Library <p>Python and C++ library with support for many different devices to make writing robot code easy.</p> Arduino Firmware <p>Arduino program provided to make it easy to add additional sensors to the robot.</p> Other Tools <p>Additional tools, such as C++ cross compiler toolchains are provided to ensure ease of use.</p> Guide <p>A detailed step-by-step guide is provided to make setting everything up easy. Additionally, this guide includes some example low cost robot builds (also with step-by-step instructions).</p> <p>See the Guide here</p> <p></p>"},{"location":"#license","title":"License","text":"<p>All components of the ArPiRobot Framework are open source and most are released under the GNU Lesser General Public License v3.0.</p>"},{"location":"#where-does-the-name-come-from","title":"Where Does the Name Come From?","text":"<p>I got tired of typing <code>ArduinoAndPiRobot</code> so I decided to shorten it into <code>ArPiRobot</code>. Really creative right?</p>"},{"location":"defaultsettings/","title":"Default Settings","text":"<p>A list of all default settings for the ArPiRobot OS Images</p> <p>Default WiFi Network Settings</p> <ul> <li>Channel 6 (2.4G)</li> <li>Country: US*</li> <li>SSID: <code>ArPiRobot-Robot</code></li> <li>Password: <code>arpirobot123</code></li> <li>IP Address: <code>192.168.10.1</code></li> <li>Hostname: <code>ArPiRobot-Robot</code></li> </ul> <p>Default Ethernet Settings</p> <ul> <li>DHCP Server: No</li> <li>IP Address: <code>192.168.11.1</code></li> <li>Hostname: <code>ArPiRobot-Robot</code></li> </ul> <p>Default Usernames and Passwords</p> <ul> <li>Username: <code>arpirobot</code></li> <li>Password: <code>arpirobot</code></li> </ul> <p></p> <ul> <li>Username: <code>root</code></li> <li>Password: <code>notdefault</code></li> </ul>"},{"location":"none/","title":"None","text":"<p>Coming Soon</p> <p>Translation: I may get to it eventually</p>"},{"location":"devs/arduinofw/","title":"Arduino Firmware","text":""},{"location":"devs/arduinofw/#firmware-architecture-libraries","title":"Firmware Architecture &amp; Libraries","text":"<p>TODO</p>"},{"location":"devs/arduinofw/#arduinofirmware-devices","title":"ArduinoFirmware Devices","text":"<ul> <li>SingeEncoder</li> <li>QuadEncoder</li> <li>Ultrasonic4Pin</li> <li>OldAda9DofImu</li> <li>NxpAda9DofImu</li> <li>Mpu6050Imu</li> <li>VoltageMonitor</li> <li>IRReflectorModule</li> </ul>"},{"location":"devs/corelib/","title":"Core Library (CoreLib)","text":"<p>Development of the ArPiRobot-CoreLib can be done using VSCode with the same basic setup as is used for writing robot code. It is recommended to open the <code>cpp_library</code> and / or <code>python_bindings</code> folder in VSCode.</p> <p>The <code>cpp_library</code> folder contains the CoreLib source. The CoreLib is implemented in C++. The Python version is simply wrappers around a C API. The C API is provided by the <code>bridge.cpp</code> and <code>bridge.hpp</code> layer in the <code>cpp_library</code>. The <code>python_bindings</code> folder contains the actual python code. The same organization structure (files, classes, function names, etc) is used for the python bindings as is used in the C++ library. The <code>bridge.py</code> file uses the <code>ctypes</code> module to call the C API functions from the <code>cpp_library</code>'s bridge. The object oriented API in python is built on calling these functions. As such when implementing a new object / function in C++ it is also necessary to add functions to the bridge layer in both C++ and python. Then, the object / function API must be replicated in the python bindings using the bridge layer.</p>"},{"location":"devs/corelib/#testing","title":"Testing","text":"Testing on a Robot <p>A directory called <code>testrobot</code> in the <code>cpp_library</code> directory and <code>testrobot-py</code> in the <code>python_bindings</code> is used to hold a robot program used during development. This directory will be \"empty\" after cloning the repository. Run <code>setup-testrobot.py</code> to setup the test projects from templates. These can then be edited and will have access to all features available in the local development version of the CoreLib and bindings respectively.</p> <p>When ready to test you will need to be connected to a robot via its WiFi network (or have some network connection to the Robot's Pi).</p> <p>On the development PC run the <code>dev-deploy.py</code> script.in the root of the ArPiRobot-CoreLib folder. This will build the CoreLib and copy the build library, development versions of the python bindings and both testrobot projects to <code>/home/arpirobot/CoreLib-Test</code> on the robot.</p> <p>To run the <code>testrobot</code> program  login to the Pi via ssh. You can use OpenSSH (Windows 10 and newer) PuTTY on Windows. Other OSes should include OpenSSH. The commands below are OpenSSH commands which will work with OpenSSH on Windows 10, macOS, Linux, etc.</p> <pre><code>ssh -l arpirobot 192.168.10.1\n</code></pre> <p>Then (in the SSH session after logging in as the user <code>arpirobot</code>) run the following command to stop the deployed robot program (only one program can run at a time)</p> <pre><code>sudo systemctl stop arpirobot-program.service\n</code></pre> <p>Change to the directory where the program was deployed</p> <pre><code>cd /home/arpirobot/CoreLib-Test/\n</code></pre> <p>Then run either of the following commands to run the C++ testrobot program or the Python testrobot program respectively.</p> <pre><code>./start-cpp.sh\n./start-py.sh\n</code></pre> Testing on the Development PC <p>For features that do not require specific hardware, some testing can be done on the development pc itself. This is supported on any system with a GNU toolchain (<code>gcc</code> compiler). The CoreLib may build with other toolchains, but are not explicitly supported. On windows, use mingw-w64. On macOS, install gcc using homebrew.</p> <p>The CoreLib can be built as a standard cmake project using the system's compiler. Run the following in the cloned <code>ArPiRobot-CoreLib</code> directory.</p> <p>Powershell (Windows):</p> <pre><code>cd cpp_library\nrm -r -Force .\\build\\\nmkdir build\ncd build\ncmake .. -G \"Unix Makefiles\"\ncmake --build . -j\ncd ..\\..\n</code></pre> <p>Bash / Zsh (macOS &amp; Linux):</p> <pre><code>cd cpp_library\nrm -rf build/\nmkdir build\ncd build\ncmake .. -G \"Unix Makefiles\"\ncmake --build . -j\ncd ../..\n</code></pre> <p>After building the CoreLib, the C++ and python testrobot programs can be run using one of the following commands (in the root directory of the corelib repository).</p> <pre><code># Runs C++ test program\npython3 run.py cpp\n\n# Runs Python test program\npython3 run.py python\n</code></pre> <p>When the program is running, it will likely not use the same IO provider as on the robot. This limits what devices are supported. Typically, the <code>SerialIoProvider</code> will be used. This IO provider only supports UART operations. This provider supports Windows, macOS, and Linux. However, on Linux systems, the <code>LibsocIoProvider</code> will likely be used by default (though non-uart devices will still likely not be usable).</p> <p>This means that most devices (other than Arduino coprocessors) will likely not be usable, however this can still be a way to do some testing during development.</p>"},{"location":"devs/corelib/#corelib-general-structure","title":"CoreLib General Structure","text":"<p>TODO</p> <ul> <li>Robot classes</li> <li>Scheduler</li> <li>NetworkManager (include network protocol, order of connections DS must make, single client enforcement, etc)</li> <li>NetworkTable (include sync procedure)</li> <li>ControllerData</li> <li>Action API</li> <li>Arduinos</li> <li>Logging (and how it integrates with networking)<ul> <li>Also prints to stdout so ArPiRobot-Tools arpirobot-program service can log to file</li> </ul> </li> <li>Use of references for statically allocated objects (user must keep in scope) and shared_ptrs for dynamically allocated that the user does not need to manage the lifecycle of. Also document why some places such as BaseDevice::action and ArduinoDevice::arduino use raw pointers (these should not keep what they point to alive and the object that sets these vars clears these vars on its deletion).</li> <li>Document bridge lifecycle management<ul> <li>Bridge creates objects using make_shared and keeps a map of raw ptr to shared_ptr</li> <li>Bridge returns raw ptr. When passed a raw ptr it looks up the shared_ptr and passes that to c++ functions. The c++ funcs may keep a copy of the shared_ptr to keep objects in scope even if the bridge's calling language (eg python) has its object leave scope and call destroy. Destroy just removes the shared_ptr copy from the bridge's map. If a copy is held elsewhere the object is not deallocated. If it is not held elsewhere, the object is deallocated immediately. BaseRobot does not use this method as the robot is started using its own blocking start method. No need to handle scenarios where a reference is not kept by user code for the duration of the program. Additionally, the bridge calling language must make sure objects with callbacks (eg Actions) are not cleaned up in the calling language (eg python) while C++ may call functions that are members (pointers to member functions). To this end, Actions are always kept in scope once instantiated by the python bindings.</li> </ul> </li> </ul>"},{"location":"devs/corelib/#corelib-devices","title":"CoreLib Devices","text":"<p>TODO</p> <p>Devices</p> <p>Things controlled entirely by the Pi.</p> <ul> <li>Gamepad</li> <li>INA260PowerSensor</li> <li>AdafruitMotorHatMotor</li> <li>DRV8833Motor and DRV8833Module</li> <li>TB6612Motor and TB6612Module</li> <li>L298NMotor and L298NModule</li> </ul> <p>ArduinoDevices</p> <p>Things controlled by the arduino that provide data to the Pi.</p>"},{"location":"devs/corelib/#corelib-arduino-interface-and-communication-protocol","title":"CoreLib Arduino Interface and Communication Protocol","text":"<ul> <li>Document general communication protocol, start byte, escape byte, stop byte</li> <li>CRC16, intent behind it, what happens if the Pi gets invalid data</li> <li>Default settings for the firmware</li> <li>Why not use arduino for motors: no ACK of message receipt so robot won't know state reliably</li> </ul>"},{"location":"devs/corelib/#packaging-corelib","title":"Packaging CoreLib","text":"<ul> <li>Package scripts</li> </ul>"},{"location":"devs/new_release/","title":"Publish New Release","text":"<p>Note that some components that are bundled with the OS Images (CameraStreaming and Tools) may not have releases on GitHub, but just tags.</p>"},{"location":"devs/new_release/#new-build-of-specific-component-not-a-new-major-or-minor-version","title":"New build of specific component (not a new major or minor version)","text":"<ul> <li>Publish release on github</li> <li>Update download link on download page</li> </ul>"},{"location":"devs/new_release/#new-major-minor-version-all-components","title":"New Major / minor version (all components)","text":"<ul> <li>Handle milestone stuff on GitHub repos</li> <li>Publish new releases for all components on each github repo (version number change if nothing else; every component's major and minor versions should match)</li> <li>Create downloads page in docs. Link to new github releases</li> <li>Update downloads/latest.md redirect in <code>mkdocs.yml</code> (if stable release; latest should always redirect to latest stable release)</li> <li>Publish updated docs</li> </ul>"},{"location":"devs/overview/","title":"Overview","text":""},{"location":"devs/overview/#github","title":"GitHub","text":"<p>The source code for all components is located on the ArPiRobot GitHub. There is also a project board.</p> <p>Generally, the most up to date documentation on building or using a specific component is located in the <code>README.md</code> file in that component's repository. Information in this section of the docs is intended to be supplemental.</p>"},{"location":"devs/overview/#components","title":"Components","text":"<p>There are various components of the framework. Some are used on the development PC, others are included in the OS image and are used on the robot.</p> <p></p> <p>Development PC Components:</p> <ul> <li>Drive Station: Program that runs on the PC and connects to a program running on the robot over network. Uses custom communication protocol to enable / disable the robot, implement a network table (key / value pairs shared between robot and drive station), retrieve logs, and send controller (gamepad) data to the robot.  </li> <li>Mobile Drive Station: Drive station that runs on an android phone or tablet. Uses virtual (on-screen) gamepad to control the robot.  </li> <li>Deploy Tool: Program that runs on the PC. Primarily used to deploy a program to the robot. Also implements various features to configure and monitor the robot. Additionally acts as a front-end for camera stream components.  </li> <li>Visual Studio Code Extension: Extension for Visual Studio Code that can create ArPiRobot projects from a template.  </li> <li>C++ Toolchains: GNU cross compiler toolchains capable of building C / C++ programs to run on the robot. Prebuilt toolchains are provided for each officially supported target architecture. Builds to run on Windows (x86_64), macOS (x86_64), and Linux (x86_64) are provided.  </li> </ul> <p>Robot Components:</p> <ul> <li>CoreLib: The core library used by robot programs. Implements: custom network protocol for use with drive station, logging, code to control various devices, multiple I/O backend libraries, a base class for robots, a scheduler driven action system, and an interface to an Arduino running the official Arduino Firmware. Note that while this is used on the robot, it is not included with OS images. Update packages for the CoreLib are installed by the deploy tool on the development PC. The CoreLib is deployed with the robot program. Thus, the CoreLib version used will be the version installed on the development PC.</li> <li>ArPiRobot-Tools: Various scripts used by the deploy tool and services used to manage the robot program. Included with the OS image.  </li> <li>Arduino Firmware: Runs on an Arduino connected to the robot's main computer. Implements various device drivers to control many types of sensors. Configured by the robot program.  </li> <li>Camera Streaming: Camera streaming services and scripts. Focused on realtime, low-latency streams for use on the robot. Included with the OS image.  </li> <li>Image Scripts: Used to create OS images for all officially supported boards.  </li> </ul> <p>Other Components:</p> <ul> <li>CAD Models: Models of example robot builds and custom parts.  </li> <li>Examples: Example robot programs.  </li> </ul>"},{"location":"downloads/betas-old/","title":"Old Beta Downloads","text":"<p>THIS INFORMATION IS NO LONGER ACURATE. THE OLD PYTHONLIB AND JAVALIB ARE NO LONGER SUPPORTED. MUCH OF THIS INFO DOES NOT APPLY.</p> <p>The image contains the OS pre-configured to work with ArPiRobot software. The image is a modified version of the Raspberry Pi OS (Debian based Linux distro). Each image will determine what versions of the python library and ArPiRobot tools can be used. These components (python library and ArPiRobot tools) are contained in updates which are only compatible with a single image. The drive station and deploy tool run on a PC and interact with the python library and ArPiRobot-Tools respectively so versions of the drive station and deploy tool may only be compatible with certain updates. Make sure to check the compatibility tables below.</p>"},{"location":"downloads/betas-old/#images","title":"Images","text":"Image Version RasPiOS Version Python Version Java Runtime Version Link Beta 8 2020-05-27-raspios-buster-lite 3.7 1.8 Download Beta7 2020-05-27-raspios-buster-lite 3.7 1.8 Download Beta6 2020-02-13-raspbian-buster-lite 3.7 None Download Beta5 2020-02-13-raspbian-buster-lite 3.7 None Download Beta4 2020-02-13-raspbian-buster-lite 3.7 None Download Beta3 2020-02-13-raspbian-buster-lite 3.7 None Download Beta2 ??? 3.7 None Download"},{"location":"downloads/betas-old/#updates","title":"Updates","text":"Compatible Image Version Update Number Python Library Version ArPiRobot-Tools Version Link Beta 8 Update 7 v0.0.32 v0.2.4 Download Beta 8 Update 6 v0.0.31 v0.2.4 Download Beta 8 Update 5 v0.0.31 v0.2.3 Download Beta 8 Update 4 v0.0.30 v0.2.3 Download Beta 8 Update 3 v0.0.28/v0.0.29 v0.2.3 Download Beta 8 Update 2 v0.0.27 v0.2.3 Download Beta 8 Update 1 v0.0.26 v0.2.3 Download Beta 7 Update 1 v0.0.24 v0.2.2 Download Beta 6 Update 10 v0.0.24 v0.2.2 Download Beta 6 Update 9 v0.0.24 v0.2.1 Download Beta 6 Update 8 v0.0.23 v0.2.0 Download Beta 6 Update 7 v0.0.22 v0.2.0 Download Beta 6 Update 6 v0.0.21 v0.2.0 Download Beta 6 Update 5 v0.0.20 v0.2.0 Download Beta 6 Update 4 v0.0.19 v0.2.0 Download Beta 6 Update 3 v0.0.18 v0.2.0 Download Beta 6 Update 2 v0.0.17 v0.2.0 Download Beta 6 Update 1 v0.0.16 v0.2.0 Download Beta 5 Update 1 v0.0.15 v0.2.0 Download Beta 4 Update 7 v0.0.14 v0.1.1 Download Beta 4 Update 6 v0.0.13 v0.1.1 Download Beta 4 Update 5 v0.0.12 v0.1.1 Download Beta 4 Update 4 v0.0.11 v0.1.1 Download Beta 4 Update 3 v0.0.10 v0.1.1 Download Beta 4 Update 2 v0.0.9 v0.1.1 Download Beta 3 Update 3 v0.0.8 v0.1.1 Download Beta 3 Update 2 v0.0.7 v0.1.1 Download Beta 3 Update 1 v0.0.7 v0.1.0 Download Beta 2 Update 3 v0.0.7 v0.0.3 Download Beta 2 Update 2 v0.0.6 v0.0.3 Download Beta 2 Update 1 v0.0.5 v0.0.2 Download"},{"location":"downloads/betas-old/#drive-station","title":"Drive Station","text":"Drive Station Versions Compatible Images and Updates Latest Download v0.3.x Beta 8 Updates 1-7  Beta 7 Update 1  Beta 6 Updates 1-10  Beta 5 Update 1  Beta 4 Updates 1-7  Beta 3 Updates 1-3  Beta 2 Update 3 v0.3.5 v0.2.x Beta 2 Updates 1 and 2 v0.2.2"},{"location":"downloads/betas-old/#mobile-android-drive-station","title":"Mobile (Android) Drive Station","text":"Mobile Drive Station Versions Compatible Images and Updates Latest Download v0.0.2 Beta 8 Updates 1-7  Beta 7 Update 1  Beta 6 Updates 1-10 v0.0.2"},{"location":"downloads/betas-old/#deploy-tool","title":"Deploy Tool","text":"Deploy Tool Versions Compatible Images and Updates Latest Download v0.2.2-v0.2.4 Beta 8 Updates 1-7  Beta 7 Update 1  Beta 6 Updates 9-10 v0.2.4 v0.2.0-v0.2.1 Beta 6 Updates 1-8  Beta 5 Update 1 v0.2.1 v0.1.2 - v0.1.3 Beta 4 Updates 1-7  Beta 3 Updates 2-3 v0.1.3 v0.1.0 - v0.1.1 Beta 3 Update 1 v0.1.1 v0.0.x Beta 2 Updates 1-3 v0.0.10"},{"location":"downloads/betas-old/#visual-studio-code-extension","title":"Visual Studio Code Extension","text":"Extension Version Changes Link v0.0.12 Fixes to JavaLib project Download v0.0.11 Enabled pylint and mypy in python template project Download v0.0.10 Added initial JavaLib support Download v0.0.9 Using new main.sh startup script model (Beta 6 Update 9). Download v0.0.8 Updated logger imports for Beta6Update8. Download v0.0.7 Added new menu structure. Added python project settings file. Download v0.0.6 Update project structure for Beta6Update7. Download v0.0.5 Fixed messages, updated project structure for Beta6Update1 and newer Download v0.0.4 Fixed broken commands. Correct dependencies included. Download v0.0.3 Support for updating dev environment from extension Download"},{"location":"downloads/betas-old/#arduino-firmware","title":"Arduino Firmware","text":"<p>Downloads</p> Arduino Firmware Versions Compatible Images and Updates v0.0.9 Beta 8 Updates 1-7  Beta 7 Update 1  Beta 6 Updates 4-10 v0.0.8 Beta 8 Updates 1-6  Beta 7 Update 1  Beta 6 Updates 4-10 v0.0.7 Beta 8 Updates 1-6  Beta 7 Update 1  Beta 6 Updates 4-10 v0.0.6 Beta 6 Updates 1-3 v0.0.5 Beta 5 Update 1  Beta 4 Updates 6-7 v0.0.4 Beta 4 Update 5 v0.0.3 Beta 4 Update 4 v0.0.2 Beta 4 Updates 1-3  Beta 3 Update 3"},{"location":"downloads/betas/","title":"Beta Downloads","text":"<p>The image contains the OS pre-configured to work with ArPiRobot software. The image is a modified version of the Raspberry Pi OS (Debian based Linux distro). </p> <p>The ArPiRobot core library is a C++ library providing code to facilitate robot program flow and interact with hardware.</p> <p>The drive station connects to a running robot program on the robot.</p> <p>The deploy tool is used to manage the robot and deploy code to it.</p>"},{"location":"downloads/betas/#arpirobot-os-images","title":"ArPiRobot OS Images","text":"Image Version RasPiOS Version ArPiRobot-Tools Version Python Version Link Beta 10C 2021-12-02-raspios-buster-armhf-lite 0.2.7 3.7 Download Beta 10B 2021-12-02-raspios-buster-armhf-lite 0.2.7 3.7 Download Beta 10A 2021-05-07-raspios-buster-lite v0.2.7 3.7 Download Beta 9 2020-05-27-raspios-buster-lite v0.2.7 3.7 Download Beta 8C 2020-05-27-raspios-buster-lite v0.2.6 3.7 Download Beta 8B 2020-05-27-raspios-buster-lite v0.2.5 3.7 Download"},{"location":"downloads/betas/#arpirobot-corelib","title":"ArPiRobot-CoreLib","text":"<p>Install this on your PC using the Deploy Tool before deploying code. This will be deployed along with your robot program.</p> Update Package Link v0.2.2-beta1 Download v0.2.1-beta1 Download v0.2.0-beta3 Download v0.2.0-beta2 Download v0.2.0-beta1 Download v0.1.0-beta2 Download v0.1.0-beta1 Download v0.0.23-beta Download v0.0.22-beta Download v0.0.21-beta Download v0.0.20-beta No Download v0.0.19-beta No Download v0.0.18-beta Download v0.0.17-beta Download v0.0.16-beta Download v0.0.14-beta Download v0.0.11-alpha Download v0.0.10-alpha Download v0.0.9-alpha Download v0.0.8-alpha Download"},{"location":"downloads/betas/#drive-station","title":"Drive Station","text":"Drive Station Versions Compatible CoreLib Versions Latest Download v0.4.0 v0.0.8-alpha+ v0.4.0-beta3 v0.3.x v0.0.8-alpha+ v0.3.5"},{"location":"downloads/betas/#mobile-android-drive-station","title":"Mobile (Android) Drive Station","text":"Mobile Drive Station Versions Compatible CoreLib Versions Latest Download v0.0.3 v0.0.8-alpha+ v0.0.3 v0.0.2 v0.0.8-alpha+ v0.0.2"},{"location":"downloads/betas/#deploy-tool","title":"Deploy Tool","text":"Deploy Tool Versions Compatible Images Latest Download v0.4.x Beta8B, Beta8C, Beta9, Beta10A, Beta10B, Beta10C v0.4.2-beta2 v0.3.x Beta8B, Beta8C, Beta9, Beta10A, Beta10B v0.3.1"},{"location":"downloads/betas/#visual-studio-code-extension","title":"Visual Studio Code Extension","text":"Extension Version Link v0.1.14 Download v0.1.13 Download v0.1.12 Download v0.1.11 Download v0.1.10 Download v0.1.9 Download v0.1.8 Download v0.1.7 Download v0.1.6 Download v0.1.5 Download v0.1.4 Download v0.1.3 Download v0.1.2 Download v0.1.1 Download"},{"location":"downloads/betas/#arduino-firmware","title":"Arduino Firmware","text":"<p>Downloads</p> Arduino Firmware Versions Compatible CoreLib Versions v0.0.14 v0.0.21-beta+ v0.0.13 v0.0.20-beta (only) v0.0.12 v0.0.8-alpha to v0.0.19-beta v0.0.11 v0.0.8-alpha to v0.0.19-beta v0.0.10 v0.0.8-alpha to v0.0.19-beta v0.0.9 v0.0.8-alpha to v0.0.19-beta"},{"location":"downloads/v1_0/","title":"Version 1.0 Downloads","text":"<p>This page contains download links for Version 1.0 of the ArPiRobot Framework. All components will be <code>1.0.x</code> versions. The <code>x</code> is a revision number and may change as components are updated. Generally, such updates will only be bugfixes. New features will typically not be introduced until a new version of the framework (eg <code>1.1</code>).</p>"},{"location":"downloads/v1_0/#development-pc-downloads","title":"Development PC Downloads","text":"ArPiRobot Drive Station <p>Download for Windows, macOS, and Linux</p> <p>Mobile Drive Station for Android Phones &amp; Tablets</p> ArPiRobot Deploy Tool <p>Download for Windows, macOS, and Linux</p> ArPiRobot VSCode Extension <p>Download</p> ArPiRobot C++ Toolchains <p>Note: A toolchain matching the architecture of the OS image on the robot is required. Multiple toolchains can be installed using the Deploy Tool.</p> <p>armv6 Toolchain for Windows, macOS, and Linux</p> <p>aarch64 Toolchain for Windows, macOS, and Linux</p>"},{"location":"downloads/v1_0/#robot-downloads","title":"Robot Downloads","text":"ArPiRobot Operating System Images <p>Note: Images for all supported systems are on the page linked below. Download the correct one for your robot's SBC (single board computer). Also, make note of the architecture if you plan to download a C++ toolchain.</p> <p>Minimum Python Version: <code>3.7</code></p> <p>Downloads for All SBCs</p> ArPiRobot Arduino Firmware <p>Source Code</p> ArPiRobot CoreLib Package <p>The downloaded zip file can be installed using the deploy tool and will be deployed to the robot when a program is deployed. Only one version of the CoreLib can be installed on your computer at a time.</p> <p>Download</p>"},{"location":"downloads/v1_0/#other-downloads","title":"Other Downloads","text":"ArPiRobot CAD Models <p>3D Models of some robots or components designed in FreeCAD.</p> <p>Note that some addons are needed for FreeCAD to open some of these parts. See the README in the downloaded zip for more info.</p> <p>Download</p> ArPiRobot Example Programs <p>Example robot programs in both C++ and Python. Most are designed for the Mini clipboard example robot build.</p> <p>The downloaded zip file contains multiple programs written in both C++ and Python.</p> <p>Download</p>"},{"location":"guide/gettingstarted/","title":"Getting Started","text":"<p>The ArPiRobot Framework is designed to make building and programming a robot easy for beginners, while still being sufficiently flexible to allow support complex designs and software. This guide is intended to introduce important parts of the ArPiRobot Framework, as well as introduce key robotics concepts and walk you through building a basic robot.</p> <p>This guide is written with beginners in mind. For those with more robotics experience, some sections can be skipped, however this guide will still provide important information specific to the ArPirobot Framework.</p>"},{"location":"guide/gettingstarted/#guide-outline","title":"Guide Outline","text":"<p>This Guide will cover the following topics</p> <ul> <li>Building a Robot: Covers what is necessary to build a custom robot to use with the ArPiRobot Framework. Also includes some example build with instructions to create them.</li> <li>Software Setup: Covers setting up software on your computer to program the robot and setting up the computer on the robot for use.</li> <li>Programming the Robot: Covers using various tools to program the robot and writing code to program the robot. This section is not a tutorial on any programming language. It covers how to use ArPiRobot CoreLib features to program the robot.</li> <li>Other Tasks: This section is a collection of various standalone guides to perform specific tasks (unrelated to each other or other sections of this guide).</li> </ul> <p>It is intended that the first three sections of this guide be followed in order.</p>"},{"location":"guide/gettingstarted/#required-items","title":"Required Items","text":"<p>Before getting started with the ArPiRobot Framework you will need the following items. These are in addition to any parts and tools required to actually build the robot.:</p> <ul> <li>A computer running Windows, macOS, or Linux. This computer will be used to write robot code and run the Drive Station.</li> <li>Your computer will need to be capable of connecting to a WiFi network. Laptops will almost always have WiFi builtin, however many desktops do not. If you computer does not support WiFi, a USB WiFi adapter can be used instead. Cheap ones such as the TP-Link TL-WN725N should work, however you may get better range with one with an external antenna such as the TP-Link AC600.</li> <li>You computer will need a micro SD card slot. Many laptops have these builtin (some desktops do too). If your computer has a full size SD card slot that should also work as most micro SD cards come with adapters to connect them to a full size SD slot. If you do not have an SD card slot, you can use a USB micro SD card adapter such as this one.</li> <li>To control the robot, you will need a gamepad that can connect to your computer. You may be able to use gamepads from various consoles if you have them, but the steps to use these vary with controller type and operating system your computer runs. You could also use a controller made for PC's such as the Logitech F310. Some console controller info is listed below. Generally, PlayStation controllers are easy to get working on any OS and XBox controllers are easy on Windows. Newer Bluetooth XBox One controllers are easy to get working on any OS.</li> </ul> Console Controller Compatibility Info <p>The table below may be incorrect, or may change over time. It is highly recommended to test your controller with the ArPiRobot Drive Station to confirm it works before planning on using it. Controllers can be tested by installing the drive station, connecting the controller. If the controller does not show up in the list, it is not functioning. If it shows up, select it in the list (click the name) and move axes / press buttons to make sure the drive station shows the state of the controller. If axis / button indicators do not change, the controller is not functioning.</p> Controller Windows macOS Linux PS3 Controller USB and Bluetooth work with third party software USB and Bluetooth work USB and Bluetooth work PS4 Controller USB and bluetooth work USB and Bluetooth work USB and Bluetooth work PS5 Controller USB and bluetooth work USB and Bluetooth work USB and Bluetooth work Original Xbox Controller USB works with adapter USB works with adapter and third party software USB works with adapter Xbox 360 Wired Controller USB works USB works with third party software USB works Xbox 360 Wireless Controller Works with Xbox 360 gaming receiver Not easily supported even with third party software Works with gaming adapter with third party software Xbox One Controller USB works. Wireless adapter works USB works with third party software USB works. Wireless using adapter requires third party software XBox One Controller with Bluetooth Support Bluetooth works. USB requires third party software USB and Bluetooth Work USB and Bluetooth work <ul> <li>Alternatively, instead of a gamepad you can use the Mobile Drive Station on an Android phone or tablet instead of running the PC Drive Station on your computer. However, the Mobile Drive Station currently lacks some features of the PC Drive Station and does not support iOS. As such, a controller that works with your computer is generally recommended.</li> </ul>"},{"location":"guide/custom/quadencoder/","title":"TT Motor Quadrature Encoder","text":"<p>Custom designed optical quadrature encoder for \"TT Motors\" (yellow gearmotors). Designed to be a low cost way to add a quadrature encoder to low cost motors. While some of these motors are sold with an included hall effect encoder, these are hard to find and often quite expensive.</p> <p>This is an optical encoder using two photo interrupters. An alignment plate is used to position the interrupters such that they generate out of phase signals using the custom encoder disk (thus creating a quadrature encoder).</p>"},{"location":"guide/custom/quadencoder/#version-1","title":"Version 1","text":"<p>Version 1 uses HY301-07A photo interrupters. These used to be easy to find cheap, but have become harder to get over time.</p> <p></p>"},{"location":"guide/custom/quadencoder/#required-parts","title":"Required Parts","text":"<ul> <li>1x TT Motor (straight gearbox, not angled one; must have dual output shafts)</li> <li>2x HY301-07A Photo Interrupters</li> <li>2x 100 Ohm resistors (through hole)</li> <li>4x Jumper wires (dupont ends)</li> <li>1x Small piece of wire (any)</li> <li>1x Custom Encoder Disk (3D printable)</li> <li>1x Custom Photo Interrupter Alignment Plate (3D printable)</li> </ul>"},{"location":"guide/custom/quadencoder/#assembly","title":"Assembly","text":"<ol> <li> <p>Use hot glue to attach the alignment plate to the motor. Attach it to the side opposite the \"bump\" and align the mounting holes.</p> <p></p> </li> <li> <p>Bend pin 2 on each photo interrupter up to pin 4 and solder it.</p> <p></p> </li> <li> <p>Solder a 100 ohm resistor to pin 1 of each photo interrupter</p> <p></p> </li> <li> <p>Use hot glue to attach the two photo interrupters in the slots on the mounting plate. Then, solder the leads of both 100 ohm resistors together.</p> <p></p> </li> <li> <p>Solder a wire between pin 4 of both photo interrupters</p> <p></p> </li> <li> <p>Solder signal wires to pins 3 of each photo interrupter (yellow and green); solder a VCC wire to the junction of both resistors; solder a ground wire to pin 4 of one photo interrupter. These four wires are used to connect the encoder. Hot glue can be used to prevent pins / wires from touching (as needed) and can also be used as strain relief on the encoder wires.</p> <p></p> </li> <li> <p>Finally, the encode wheel can be attached to the output shaft, slotted between the photo interrupter slots. This can be done by angling the disk while slotting it into place.</p> <p></p> </li> </ol>"},{"location":"guide/custom/quadencoder/#wiring-diagram","title":"Wiring Diagram","text":""},{"location":"guide/hardware/examplebuilds/","title":"Example Robot Builds","text":""},{"location":"guide/hardware/examplebuilds/#mini-clipboard-robot","title":"Mini Clipboard Robot","text":"<p>A four wheel differential drive robot build on a small clipboard (6\" by 9\"). This robot build uses common \"TT\" motors with a 1:48 gear ratio and does not require any soldering or 3D printed parts to assemble. This is intended to be a low-cost easy to build reference robot design for beginners. It includes various sensors such as encoders, an IMU, an ultrasonic sensor, a voltage monitor, and IR reflector sensors for line following.</p> <p>This is the robot example code in the ArPiRobot-Examples repository is designed for.</p> <p></p> Parts List <p>Mechanical Parts:</p> <ul> <li>1x 6\"x9\" Mini Clipboard with Low Profile Clip</li> <li>4x TT Motor with Wires and Wheels<ul> <li>Alternate: Motors with Wires</li> <li>Alternate: Wheels</li> </ul> </li> <li>1x Pack of Bingo Chips</li> <li>2x TT Motor Encoder Disk</li> </ul> <p>Electrical Parts:</p> <ul> <li>1x Raspberry Pi Zero W w/ Headers<ul> <li>Alternate: Raspberry Pi Zero 2 W no headers, must buy and solder separately</li> </ul> </li> <li>1x Arduino Nano<ul> <li>Alternate: Arduino Nano Every</li> <li>Alternate: Metro Mini 328</li> </ul> </li> <li>1x MPU-6050 IMU Breakout</li> <li>1x Voltage Monitor Module<ul> <li>Alternate</li> </ul> </li> <li>1x HC-SR04 Ultrasonic Sensor<ul> <li>Alternate</li> <li>Alternate</li> </ul> </li> <li>2x IR Reflector Module<ul> <li>Alternate</li> </ul> </li> <li>2x Photo-Interrupter Module<ul> <li>Alternate</li> </ul> </li> <li>1x 5AA Holder<ul> <li>Alternate plus male screw terminal to barrel jack adapter</li> </ul> </li> <li>1x Mini Breadboard</li> <li>1x Compact USB Battery Pack<ul> <li>Alternate</li> </ul> </li> <li>1x Pack of Jumper Wires<ul> <li>Alternate</li> </ul> </li> <li>1x Short USB Cable for Arudino<ul> <li>A to Mini B (for Arduino Nano &amp; Clones)</li> <li>A to Micro B (for Arduino Nano Every &amp; Metro Mini 328)</li> </ul> </li> <li>1x USB OTG Adapter for Pi Zero<ul> <li>Alternate</li> </ul> </li> <li>1x Female Barrel Jack screw terminal adapter</li> <li>1x Cable for MPU-6050 Breakout</li> </ul> Assembly Instructions <ol> <li> <p>Motor Assemblies</p> <ul> <li> <p>The motor assembly consists of the motor, wheels, bingo chip spacers, and encoder disks.</p> </li> <li> <p>The outside face of the motor is the face with an axel that has a \"bump\" on it. The front of the motor is the face opposite the actual motor.</p> </li> </ul> <p> </p> <ul> <li> <p>Bingo chips are used to construct a spacer (approx 0.25 in thick) to space the motor away from the clipboard it will eventually be mounted on. This is typically between 4 and 6 bingo chips.</p> </li> <li> <p>Bingo chip spacers should be constructed using super glue. Glue a stack of bingo chips to each other to result in a 0.25 in tall stack. Eight of these stacks are necessary in total.</p> </li> <li> <p>Two motors of each of two orientations are required. The first orientation requires bingo chips on the \"top\" face (as shown in the image above). Two require bingo chips on the bottom face. If the motors are arranged in the layout shown below, all bingo chip stacks go on the top faces.</p> </li> </ul> <p> </p> <ul> <li>To attach the bingo chip stacks to the motor do not use super glue. Instead use hot glue. Ideally, clean each surface using isopropyl alcohol before applying hot glue (let it dry before applying glue) to ensure best adhesion. Use a decent amount of glue to ensure the motor remains attached to the bingo chips. Hot glue is used as isopropyl alcohol can be used later to easily remove it allowing the motor to be opened or replaced easily. When placing the bingo chips, be careful with alignment. They will be slightly wider than the motor's face. Make sure the inside edge is flush. The bingo chips can overhang the outside edge slightly.</li> </ul> <p> </p> <ul> <li>Once all assembled, the motors can be arranged as follows. The clipboard is then essentially placed on top.</li> </ul> <p> </p> <ul> <li>However, it is easier to place the motors on the clipboard one at a time. Turn the clipboard clip-side up and place each motor at the distances shown below. The outside face of each motor should be flush with the edge of the clipboard to ensure proper movement. The motors should be attached to the clipboard using hot glue. It is again recommended to clean the bingo chip faces before applying hot glue. Super glue is not recommended as it is difficult to reposition if you mess up alignment.</li> </ul> <p> </p> <p> </p> <ul> <li>Finally, add the wheels to all motors (outside shaft) and add an encoder disk to the inside shaft of the front two motors (front is side without the clip).</li> </ul> <p> </p> <p> </p> </li> <li> <p>Electronics</p> <ul> <li>Place the motor bonnet on top of the Raspberry Pi Zero (solder header to Pi Zero if required first). When fully seated, there may be a small gap. This is ok.</li> </ul> <p> </p> <ul> <li>This assembly (pi and bonnet) can then be attached to the clipboard. Place electrical tape on the bottom of the Raspberry Pi (to protect the PCB from hook and loop tape adhesive). Then apply hook tape. Place loop tape in the correct spot on the clipboard and attach the Raspberry Pi using the hook and loop tape.</li> </ul> <p> </p> <ul> <li>Next, place the Arduino Nano in the mini breadboard as shown below. Notice that one side has three rows on the breadboard and the other only has two. Also notice that the \"back\" of the breadboard has one empty row not obstructed by the row. Matching this is important.</li> </ul> <p> </p> <ul> <li>The add the breadboard in the position shown below. The breadboard likely has adhesive tape on the bottom. If not, electrical tape followed by hook and loop tape can be used as was done for the Raspberry Pi.</li> </ul> <p> </p> <ul> <li>Next add the top-side sensors in the indicated positions. These are attached directly to the clipboard using hot glue. Generally, the PCB is set directly onto the clipboard and hot glue is applied around the edges (not under the board). This makes it easier to remove if needed. For the ultrasonic sensor, hot glue is generally placed under the metal rings around the emitter and receiver. Note that the ultrasonic sensor's front face is flush with the front edge of the clipboard.</li> </ul> <p> </p> <p> </p> <ul> <li>Then, add the following sensors in the indicated positions on the bottom of the board. These too are attached using hot glue on the sides of the PCBs.</li> </ul> <p> </p> <ul> <li>Finally, use hook and loop tape to attach both the AA battery pack and USB battery pack in the positions shown below.</li> </ul> <p> </p> </li> <li> <p>Wiring (Non-Sensor Cables)</p> <ul> <li>Connect the USB OTG adapter to the Raspberry Pi Zero's USB host port (inner one; outer one is for power).</li> </ul> <p> </p> <ul> <li> <p>Then connect the USB A to Mini B cable (or Micro B cable depending on the sensor coprocessor board used). The USB A (rectangle) side should be connected to the OTG adapter on the Raspberry Pi Zero and the Mini / Micro B should be connected to the Arduino Nano (or other board as applicable).</p> </li> <li> <p>The USB Battery pack should have come with a USB A to Micro B cable. This will be used to power the raspberry Pi. Connect the micro B end to the Raspberry Pi's power port. It is recommended to use hot glue to secure this cable on top of the clipboard and let it hang over the back. Only plug this into the battery pack when you are using the robot.</p> </li> <li> <p>Motor battery power should go to the motor bonnet power ports. Place the female barrel jack screw terminal adapter where shown. In each screw terminal port, two jumper wires (male to male) are needed (four wires total). One power and one ground (one each + and -) go to cooresponding places on the motor hat. The other pair goes to the voltage monitor</p> </li> </ul> <p> </p> <ul> <li> <p>To connect motor battery power, bring the AA battery pack wires around the back of the clipboard and connect the barrel jack to the female one. If your AA battery pack does not have a male barrel jack connector installed, add one with screw terminal blocks (you may need to strip off some wire insulation).</p> </li> <li> <p>When done, the robot should look something like the following</p> </li> </ul> <p> </p> <ul> <li>Finally, connect the motor cables to the correct places on the motor bonnet. Motor numbers are shown below. Order of red and black wires in these ports does not matter. Swapping red and black (for the same motor) will invert its direction. You may want to use hot glue or tape to keep the wires on top of the clipboard.</li> </ul> Motor Number Front Left 3 Rear Left 4 Front Right 2 Rear Right 1 <p> </p> </li> <li> <p>Wiring (Sensor Cables)</p> <ul> <li>First, you need to know how breadboards work. Each row of pins is connected internally. To connect a wire to a pin on the Arduino Nano, plug it into the same row on the breadboard.</li> </ul> <p> </p> <ul> <li> <p>Next, more sensors will need connections to the 3.3V pin (3V3) and GND pins than are available on the breadboard. As such, the two empty rows need to be connected to 3.3V and GND. This provides four extra GND and 3.3V pins. Note that the MPU6050 has a cable that connects to either port on the short sides of the board. This cable has four jumper wire pins on the other end that are connected to the breadboard.</p> </li> <li> <p>Then connect each sensor as follows using jumper wires</p> </li> </ul> Sensor Sensor Pin Arduino Nano Voltage Monitor - GND Voltage Monitor S A0 Ultrasonic VCC 5V Ultrasonic GND GND Ultrasonic TRIG 7 Ultrasonic ECHO 8 Left Encoder VCC 3.3V Left Encoder GND GND Left Encoder D0 D2 Right Encoder VCC 3.3V Right Encoder GND GND Right Encoder D0 D3 Left IR VCC 3.3V Left IR GND GND Left IR OUT D11 Right IR VCC 3.3V Right IR GND GND Right IR OUT D12 MPU6050 Red Wire 5V MPU6050 Black Wire GND MPU6050 Yellow Wire A5 MPU6050 Blue Wire A4 <ul> <li> <p>To connect the sensors on the bottom, it is recommended to bring the wires around the front of the clipboard and use hot glue or tape to keep them from hanging off the robot too much.</p> </li> <li> <p>Twist ties, electrical tape, and hot glue can be used for cable management. When fully wired, it should look something like the following images</p> </li> </ul> <p> </p> <p> </p> </li> </ol>"},{"location":"guide/hardware/examplebuilds/#mini-clipboard-robot-orange-pi-lite-variant","title":"Mini Clipboard Robot (Orange Pi Lite Variant)","text":"<p>This is a slightly modified version of the Mini Clipboard Robot using an Orange Pi Lite instead of a Raspberry Pi Zero. Typically, the original variant is recommended, but Raspberry Pis are difficult to get at the time of writing this.</p> Parts List Modifications <ul> <li>1x Orange Pi Lite instead of Raspberry Pi Zero</li> <li>1x USB-A to Barrel Jack Cable to power the Orange Pi<ul> <li>Alternate</li> <li>Alternate</li> <li>Alternate</li> </ul> </li> </ul> Assembly Instruction Modifications <p>Overall, wiring and assembly should follow the same instructions as for the standard Mini Clipboard Robot build. However, the Orange Pi should be placed in the location shown below.</p> <p></p> <p>Other changes:</p> <ul> <li>Glue the wireless antenna to the location shown below.</li> <li>The Arduino's USB cable should be connected to either of the USB-A ports on the side (not the micro USB port)</li> <li>Orange Pi Lite cannot be powered via its micro USB port. It must be powered by the barrel jack connector.</li> </ul> <p></p>"},{"location":"guide/hardware/requiredhardware/","title":"Required Components","text":""},{"location":"guide/hardware/requiredhardware/#mechanical-components","title":"Mechanical Components","text":"<p>The mechanical components of your robot include structural components and physical parts that make up various systems on the robot and make the robot function. The mechanical components used on a robot will vary widely depending on what the robot is designed to do. The following list is a guideline set of components necessary for a simple drive base (robot that just drives). Additional systems on the robot to perform different tasks, or robots designed to move in different ways, will likely need a very different set of components.</p>"},{"location":"guide/hardware/requiredhardware/#major-drive-base-components","title":"Major Drive Base Components","text":"<ul> <li>Base / Frame / Chassis: This is the foundation that the rest of the robot is built on. This may be made up of several components. A \"base\" is typically just a flat plane that other mechanical components are attached to. A \"frame\" is typically an \"outline\" which components are attached to. Often, a flat plane will be placed on top of a frame to allow space for electronics, but items such as motors are attached on the sides. A chassis is more of a generic term in this context.</li> <li>Motors: Motors are used to spin wheels to make the robot drive. Typically, either two or four motors are used, with an even number on each side. If only two are used, a caster wheel is often required for stability. Alternatively, two \"free spinning\" wheels could be used instead (robot would have four wheels, but two motors). However, this configuration is often less ideal than a caster as steering is more difficult.</li> <li>Wheels: Attach to motors, or in the case of a caster, to the drive base / frame / chassis.</li> <li>Mounting Hardware: Screws, nuts, bolts, etc. Anything that you plan to use to attach components to each other.</li> <li>Spacers: Washers or other 3d printed / metal / other spacers to place components where desired when attaching.</li> </ul>"},{"location":"guide/hardware/requiredhardware/#electrical-components","title":"Electrical Components","text":"<p>Unlike the physical construction of the robot, the requirements for a robot's electrical system are often very similar. While there will be minor differences depending on specifically what a robot does, the main types of components needed often do not change.</p>"},{"location":"guide/hardware/requiredhardware/#major-components","title":"Major Components","text":"<ul> <li>Main Computer: The main computer is what runs the robot software. This is an embedded computer running a Linux operating system. Often, Raspberry Pi boards are used.</li> <li>Computer Power Source: The power source used to power the computer (and other devices powered from the computer). In many cases, this is a second battery in the form of a USB battery pack (rechargeable). However, this can also sometimes be regulated from the same source powering motors.</li> <li>Motor Power Source: The power source used to power motors. Often this is a set of AA batteries, or a rechargeable battery pack.</li> <li>Motion controllers: These components are used to control the robot's motion. This includes devices such as motor controllers used to move motors on the robot.</li> <li>Sensor Coprocessor: A microcontroller (or microcontroller dev board) capable of interfacing with sensors on the robot. Communicates important information back to the main computer. Often, Arduino development boards are used.</li> <li>Sensors: Any device on the robot used to provide the software information about the robot or its environment. Includes encoders, IMUs (gyro, accelerometer, magnetometer), voltage sensors, ultrasonic sensor, IR reflection detectors, etc</li> <li>Indicators: Any device used to convey information to the robot's user. Typically, these are just LEDs.</li> </ul> <p>A general block diagram of an ArPiRobot electrical system is shown below</p> <p></p>"},{"location":"guide/hardware/requiredhardware/#example-block-diagram","title":"Example Block Diagram","text":"<p>The following is a block diagram of an electrical system for a 4 wheel drive robot including several sensors.</p> <p></p>"},{"location":"guide/hardware/requiredhardware/#tools-and-other-components","title":"Tools and Other Components","text":"<p>There are a few \"minor\" components and tools that are sometimes necessary as well. These are listed below.</p> <ul> <li>Micro SD Card: Required to boot the computer (in most cases). Stores the computer's OS and the robot's program files.</li> <li>USB Cables: Required to connect some components. Typically, a USB cable is needed to connect a sensor coprocessor to the main computer and to connect the computer power source to the computer.</li> <li>Jumper Wires: Used to connect various components on the robot to each other (sensors, motors, etc)</li> <li>Barrel Jack Connector: Used to connect power to motor driver(s).</li> <li>Breadboards: Used to connect sensor and other devices using jumper wires. No soldering required.</li> <li>Solder Iron: Used to assemble electronic components. Required to assemble some sensor boards, solder headers to some main computers, or connect wires to some motors. Most of the time, it is possible to avoid soldering if you want to do so, but some components will no be available assembled or may be more expensive assembled.</li> <li>Wire Strippers: Used to remove insulation from wires. Useful if you are making your own jumper wires or attaching wires to motors yourself. Not always required.</li> <li>Electrical Tape: Used to cover contacts to prevent shorting. Also useful for cable management.</li> <li>Hook and Loop Tape: Often incorrectly referred to by the brand name \"Velcro\". Used to attach components to the robot. Note that if using to attach PCBs, electrical tape is also recommended.</li> <li>Hot Glue &amp; Glue Gun: Useful to attach components and for wire management</li> <li>Super glue: Useful to attach components with more stress on them</li> <li>Ruler: Useful during assembly at times</li> <li>Screwdrivers: Used with screws to assemble mechanical components (if necessary). Small screwdrivers are also used with various electrical components to connect wires (in screw terminal blocks).</li> <li>Wrenches: Used during assembly of mechanical components</li> </ul>"},{"location":"guide/hardware/requiredhardware/#selecting-components","title":"Selecting Components","text":"<p>The next section includes lists of supported hardware. Choosing items from this list will ensure full compatibility. Generally, you will want to determine the physical construction of your robot first. Then choose one or more of each component from the lists above as required. </p> <p>Generally, one of each component is necessary. More than one motor controller may be needed depending on which motor controller(s) and how many motors are on the robot. Additionally, the sensors used on your robot depend on its physical construction and what you want it to do. It is also possible to build a robot without sensors, in which case a sensor coprocessor is not needed. There is also a small selection of sensors that work directly with the main computer and do not require a sensor coprocessor. More details on the supported hardware page.</p> <p>Alternatively, some example robot builds are documented. If you're less experienced with robotics, it may be beneficial to start with one of these examples, instead of a custom build.</p>"},{"location":"guide/hardware/supportedhardware/","title":"Supported Hardware","text":""},{"location":"guide/hardware/supportedhardware/#where-to-buy-components","title":"Where to Buy Components","text":"<p>Note: These are not the only possible places to buy components. These are just some general starting points.</p> Sources <p>Adafruit - Sell many custom microcontroller boards and sensor / motor controller breakout boards. Also sell Raspberry Pi computers and various components such as motors. </p> <p>SparkFun - Similar to Adafruit, sell many custom sensor / motor controller boards. Sell Arduinos and custom microcontroller boards as well as Raspberry Pi computers, motors, and various other components.</p> <p>Digikey - Sell various electronic chips and components. Also stock most / all Adafruit parts (and usually allow back ordering).</p> <p>Mouser -  Sell various electronic chips and components. Also stock many Adafruit parts (and usually allow back ordering).</p> <p>Amazon - Good source for \"common\" parts being used. Sometimes motors and some sensor boards can be found. Mostly good for \"generic\" type parts and common parts.</p> <p>Banggood - Stocks many items to be purchased online. Similar to Amazon, but slow shipping from China. Sometimes cheaper prices than Amazon and sometimes slightly different availability.</p> <p>DFRobot - Provide many robot kits and components. The kits often include electronics that are not easily usable with the ArPiRobot framework, but the robot chases can be useful. Additionally, some sensors and motors are useful.</p> <p>Robotshop - Stock many components, including many DFRobot motors with cheaper shipping.</p> <p>Arduino Store - This is sometimes the only place to easily find some Arduino boards.</p> <p>Note: In many cases, the components listed below are examples of a type of product. The linked items are intended to serve as examples and are not endorsements of a specific item / specific items.</p>"},{"location":"guide/hardware/supportedhardware/#mechanical-components","title":"Mechanical Components","text":""},{"location":"guide/hardware/supportedhardware/#base-frame-chassis","title":"Base / Frame / Chassis","text":"<p>Sometimes, kits are used for the robot's base / frame / chassis, however this is also frequently custom built. Some kits are linked here. This is not a complete list of kits. Amazon is a good place to look for chassis kits. DFRobot also has several custom kits available.</p> Kits Chassis Kit Description Link(s) Generic 2WD Acrylic This is a simple chassis cut out of acrylic. It is semi-decent quality (for acrylic), however acrylic will crack over time. Additionally, the space for electrical components is relatively small. This is decent for a low cost, simple build with relatively few sensors, but won't scale well to more complex robots. Often comes as a kit including motors, wheels, a AA battery pack, and mounting hardware. Amazon Source 1 Amazon Source 2 Amazon Source 3 Generic 4WD Acrylic This is a simple chassis cut out of acrylic. It is semi-decent quality (for acrylic), however acrylic will crack over time. the two layers allow a little extra space for electrical components compared to the 2WD kit linked above, however space is still limited. Often comes as a kit including motors, wheels, a battery pack, and mounting hardware. However, usually comes with a 4x AA battery pack, which is barely sufficient for a 4WD robot. 5 AA batteries are highly recommended instead. There are also variations that include mecanum wheels. Amazon Source 1 Amazon Source 2 Amazon Source 3 Amazon Source 4 Banggood Source 1 Banggood Source 2 DFRobot 4WD (Pirate) Good quality Aluminum robot chassis including 4 motors. Motors included are a 1:120 gear ratio as opposed to the more common 1:48 gear ratio. Provides ample space for electrical components, but not much space for more complex mechanical systems. DFRobot Shop"},{"location":"guide/hardware/supportedhardware/#motors-and-wheels","title":"Motors and Wheels","text":"<p>The list below includes commonly used motors. Any motor should be usable, provided it is usable with the motor driver and power source used. The power source will need to be of a sufficient voltage and the motor controller (motor driver) will need to be able to supply enough current for the motor.</p> Motors Motor Description Link(s) TT Motor 1:48 Commonly available low cost motors with a plastic gearbox with a double-D output shaft. Most often, these have a 1:48 gear ratio and are constructed with plastic gears. These motors are generally listed as being 3V to 6V motors (but are often run up to 9V without issue). These motors are relatively low current, small, and not too powerful, however are sufficient for a small robot's drive system. Sometimes these motors come with wheels and / or wires pre-soldered to the motor leads. Other times, they do not. These also sometimes come in multi packs. Amazon Source 1 Amazon Source 2 Amazon Source 3 Amazon Source 4 Adafruit Banggood Source 1 Banggood Source 2 Banggood Source 3 Robot Shop Source 1 Robot Shop Source 2 TT Motor 1:120 Similar to 1:48 version, but harder to find. All gearbox components are still plastic, so despite the higher gear ratio, these cannot withstand too much torque. These are often impossible to source from Amazon or Banggood sellers. Best option is to search \"TT Motor 1:120\" on ebay or Aliexpress. Links provided to a search not specific parts as sellers change often. Double check gear ratio before ordering. ebay AliExpress Angled TT Motor Similar to other TT Motors above, but output shaft is 90 degrees angle from motor input shaft. These are harder to find. These are also usually 1:120 gear ratio. Robot Shop DFRobot Various Pololu Plastic Gearmotors Similar in form factor and capabilities to the common \"TT\" motors, but have a different output shaft. Pololu Various Pololu Metal Gearmotors May options including larger higher voltage / current motors capable of generating / withstanding higher torque. Output shafts vary. Pololu TT Motor Bi-Metal Similar to TT Motor, but with some metal internal gears. 1:90 gear ratio. Note: these have no rear output shaft making encoders more difficult. Adafruit TT Motor All-Metal Similar to TT Motor ,but all internal gears are metal. 1:90 gear ratio. Note: these have no rear output shaft making encoders more difficult. Adafruit Wheels Wheel Description Link(s) Generic Yellow &amp; Black TT Motor Wheel Commonly sold with motors or drive chassis kits. Hard to find without motors. Links provided only for wheels alone. On Amazon and Bangood motors will usually come with wheels. Searching \"TT Motor Wheel\" on AliExpress seems to be the best option to find the wheels without motors. AliExpress Source 1 AliExpress Source 2 AliExpress Source 3 AliExpress Source 4 AliExpress Source 5 Orange TT Motor Wheel Similar to generic wheel, but grippier rubber. Adafruit Thin White TT Motor Wheel Thinner TT Motor wheel. Adafruit Skinny TT Motor Wheel Even thinner TT Motor wheel. Adafruit Various Pololu Wheels Various wheels that work with Pololu Motors Pololu TT Motor Mecanum Wheels Mecanum wheels that work with TT Motors. Adafruit: 48mm Left Adafruit: 48mm Right Robot Shop: 48mm Set Robot Shop: 60mm Set"},{"location":"guide/hardware/supportedhardware/#electrical-components","title":"Electrical Components","text":""},{"location":"guide/hardware/supportedhardware/#main-computer","title":"Main Computer","text":"<p>Typically, a Single Board Computer (SBC) is used as the robot's main computer. Often, Raspberry Pi boards are used as they are low cost and well supported. However, other SBCs are supported too (see lists below).</p> <p>When selecting a SBC to use as the main computer consider not only the specs of the computer, but the following items as well - Size - Power requirements (current required and how power is connected) - Interface Options (USB ports, builtin wifi, types of headers) - Compatibility with Raspberry Pi Hats     - Many SBCs have a 40-pin header matching the raspberry pi for hat compatibility (pin numbers may differ though). Some SBCs also have a 26-pin header which matches part of the raspberry pi pinout and can be used with some, but not all hats.</p> <p>Note that a board with a WiFi adapter is required for full functionality. Most supported boards have builtin wifi adapters, however if they do not a USB wifi adapter will be needed.</p> Raspberry Pi Boards <p>There are thee main types of Raspberry Pi boards</p> <ul> <li>Model B boards: \"Full size\" Raspberry Pis. Small, but larger than the other options.</li> <li>Model A boards: Smaller boards (size of a Pi hat). Also generally slightly less powerful than same generation Model B board.</li> <li>Zero series boards: Very small boards (about half the size of a Model A board). Generally significantly less powerful than similarly aged Model B / Model A boards.</li> </ul> <p>The following boards are recommended for use with the ArPiRobot Framework</p> Board Number of Cores RAM 64-bit WiFi Power Supply Link Raspberry Pi 4 Model B 4 1GB - 8GB Yes Yes 5V@2.4A Link Raspberry Pi 3 Model A+ 4 512MB Yes Yes 5V@2.1A Link Raspberry Pi 3 Model B 4 1GB Yes Yes 5V@2.4A Link Raspberry Pi 3 Model B+ 4 1GB Yes Yes 5V@2.4A Link Raspberry Pi Zero 2 W 4 512MB Yes Yes 5V@2.1A Link Raspberry Pi Zero W 1 512MB No Yes 5V@1.5A Link <p>Note that the Raspberry Pi Zero W is a single core board. As such, it is only recommended for simple robots.</p> Orange Pi Boards <p>The following Orange Pi boards are supported. Other boards are not officially supported (and would require a custom OS image).</p> Board Number of Cores RAM 64-bit WiFi Power Supply Link Orange Pi Lite 4 1GB No Yes 5V@2.1A Link Orange Pi 3 LTS 4 2GB Yes Yes 5V@2.4A Link <p>Note that the Orange Pi Lite is compatible with Raspberry Pi hats (40-pin header). This header is however oriented \"backwards\" compared to a Raspberry Pi, meaning hats do not sit over the SBC, but hang off the SBC.</p> <p>Note that the Orange Pi 3 LTS is compatible with some Raspberry Pi hats (26-pin header). Most I2C and SPI hats should work (including Adafruit Motor Hat), but check pinouts to be sure.</p>"},{"location":"guide/hardware/supportedhardware/#computer-power-sources","title":"Computer Power Sources","text":"<p>Generally, it is easiest to have two power sources on the robot. This avoids scenarios where motors changing speed cause a voltage drop that reboots the computer. Often, the computer power source is a USB battery pack.</p> <p>When selecting a power source, be aware that it needs to be able to supply a sufficient amount of current. The current requirement mostly depends on the main computer. In general, using a 2.4A power source is a safe option, however double check the tables in the previous section to see the recommended current rating for each supported board. It is ok to use a power source that has a higher current rating, but lower is not recommended.</p> <p>Note that recommendations in the tables above are lower than manufacturer recommendations in many cases because the SBC will not be driving a display on the robot and often has fewer USB devices connected.</p> <p>Finally, also make sure you have a way to connect power to your main computer. Most SBCs are powered either by a micro USB port or a USB C port. To use most of the battery packs linked below you will need a USB type A (rectangle type) to micro B or USB A to USB C cable. Most battery packs come with a USB A to micro B cable. A USB A to USB C cable will have to be purchased separately. Also, some SBCs can or must be powered by a DC barrel jack connector (eg Orange Pi Lite must be). In this case make sure to buy a USB A to barrel jack connector sized correctly for the board.</p> USB Battery Packs <p>Higher capacity battery packs will last longer on a single charge.</p> Battery Pack Capacity Output Current (max) Link(s) Anker Astro E1 5200 mAh / 6700mAh 2.1A Amazon (5200mAh) Amazon (6700mAh) EnergyCell Compact 10000 mAh 2.4A Amazon Miday Portable Charger 10000 mAh 2.4A Amazon Miday Portable Charger 5000 mAh 2.4A Amazon Other Options <p>Voltage regulators can be used to regulate power from the same source that powers motors (or another unregulated source). Most single board computers require a 5V supply capable of the currents indicated above. Keep this in mind when selecting a regulator. Also be aware of the regulator's input voltage requirements. Some example regulators are listed below</p> <ul> <li>5V/3A UBEC from Adafruit</li> <li>5V/3A UBEC from ShareGoo (Amazon)</li> </ul> <p>There are also other batteries designed for use with a raspberry pi. Some are listed below.</p> <ul> <li>PiJuice Hat</li> <li>Kuman UPS Battery Pack Board</li> <li>Geekworm Raspberry Pi UPS HAT</li> </ul>"},{"location":"guide/hardware/supportedhardware/#supported-motor-drivers","title":"Supported Motor Drivers","text":"<p>Motor drivers are connected directly to the SBC. There are multiple types of motor drivers listed below.</p> PWM Motor Drivers <p>When used with the ArPiRobot Core Library, the PWM signals will be software generated. As such, it is recommended to use other motor drivers if you have many motors (more than 4-6) or if exact speeds are critical.</p> Motor Driver Number of Motors Motor Voltage Max Current per Motor Links DRV8833 2 2.7V - 10.8V 1.2A Adafruit Breakout Pololu Breakout TB6612 2 4.5V - 13.5V 1.2A Adafruit Breakout SparkFun Breakout L298N 2 5V - 12V 2A Generic Module (Amazon 1) Generic Module (Amazon 2) <p>Note: The L298N has a voltage drop of about 1V from input power to motor outputs at full speed. As such, it is generally better to use other drivers.</p> I2C Motor Drivers <p>These I2C motor drivers connect to the SBC via I2C and have onboard PWM generators (avoiding the software PWM problem).</p> Motor Driver Number of Motors Motor Voltage Max Current per Motor Links Adafruit Motor Hat 4 4.5V - 13.5V 1.2A Adafruit Adafruit Motor Bonnet 4 4.5V - 13.5V 1.2A Adafruit Geekworm Motor Hat 4 4.5V - 13.5V 1.2A Amazon Geekworm Site <p>Note: The Adafruit Hat and Bonnet are identical except for size / form factor. The Geekworm hat is built around the same chips as the Adafruit hat and is very similar.</p>"},{"location":"guide/hardware/supportedhardware/#motor-power-sources","title":"Motor Power Sources","text":"<p>The \"easiest\" power source for motors is a AA battery pack. At least 4AA batteries are recommended for two TT motors and 5 AA batteries for 4 TT motors. When using TT motors, more than 6AA batteries is not recommended (or 8 if using rechargeable). Other motors may require different voltages / current draw and may need different types or numbers of batteries.</p> <p>Note: Make sure the voltage of the power source you are using is acceptable for the motor driver you are using.</p> AA Battery Packs <p>Note: these are just holders for the batteries. Batteries are not included. If using rechargeable AA's it is recommended to use one or two more batteries than the minimum recommended above (rechargeable are 1.2V per not 1.5V per).</p> Item Link(s) 4x AA Holder Amazon 1 Amazon 2 Amazon 3 Adafruit 1 Adafruit 2 5x AA Holder Amazon 1 Amazon 2 Adafruit 6x AA Holder Amazon 1 Amazon 2 Adafruit 8x AA Holder Amazon 1 Amazon 2 Amazon 3 Adafruit <p>Other types of batteries can also be used. Typically, NiMH batteries are the best option (from a safety standpoint), but LiPo batteries are usable too (however more caution must be used with them).</p> Other Batteries <ul> <li>7.2V 3600mAh NiMH Battery</li> <li>6V 200mAh NiMH Battery</li> <li>2 Cell LiPo Battery 6200mAh</li> <li>2 Cell LiPo battery 5200mAh</li> <li>NiMH Charger (6V-12V)</li> <li>LiPo Charger</li> </ul>"},{"location":"guide/hardware/supportedhardware/#supported-sensor-coprocessors","title":"Supported Sensor Coprocessors","text":"<p>Officially supported sensor coprocessors must run the ArPiRobot Arduino Firmware. The following boards are officially supported by the firmware. However, other boards will likely work, but would require firmware modifications.</p> Supported Boards <p>Notes on Arduino Compatible Boards:</p> <ul> <li>Official Arduino boards are open source hardware, meaning they can be easily copied. Thus, many \"clones\" of official boards exist on the market (often same board name with a different brand name). Clones are generally fine, however may cut corners to reduce cost. Additionally, there are some counterfeit boards which try to pass themselves off as official Arduino boards. These should be avoided (buy from reputable seller / site; if buying from Amazon, check the seller).</li> <li>Many non-Arduino brand boards are compatible with Arduino software. Some of these are officially supported on the list below</li> <li>Additionally, some non-Arduino brand boards are compatible with other boards (eg some boards are \"Arduino Uno Compatible\"). If a board is compatible with a supported model, it should work too. </li> <li>Also, some boards come with headers soldered, others come with loose headers (that can be soldered), and some do not come with headers. Be aware of this when buying a board. There are also sometimes variants with headers pre-soldered (Adafruit and SparkFun often sell soldered header versions that may not be linked here).</li> </ul> <p>Officially supported list:</p> <p>Note: This list should be considered incomplete. This list includes board that have been tested / are known to work, but many other \"compatible\" boards should also work. For example, other boards that are \"Arduino Uno Compatible\" will work. Also, other clones should be compatible.</p> Board Description Link(s) Arduino Nano Low power board with a small size. Same chip as Arduino Uno. Arduino Store Amazon Arduino Uno Low power board, commonly included in kits. Arduino Store SparkFun Amazon Arduino Nano Every Slightly more powerful than original Nano; similar size and pinout. Arduino Store SparkFun Amazon Teensy 3.1 / 3.2 Small, but powerful chip. Capable of handling more sensors. PJRC Store Adafruit SparkFun Raspberry Pi Pico Low cost, small, and powerful. Capable of handling many sensors. Raspberry Pi Site Adafruit SparkFun Feather S2 ESP32 based board with feather form factor. Small and powerful processor. Note: wireless features are not used. Adafruit Unexpected Maker Shop Adafruit Metro 328 Arduino Uno compatible board of a similar size to Arduino Uno. Adafruit Adafruit Metro Mini 328 Arduino Uno compatible board of a similar size to Arduino Nano. Adafruit"},{"location":"guide/hardware/supportedhardware/#supported-sensors","title":"Supported Sensors","text":"<p>Most sensors are only supported using an sensor coprocessor. This is either due the how the sensors connect or requirements regarding timing when working with the sensors. However, there are a few sensors that are supported connected directly to the main computer.</p> Coprocessor Sensors Sensor Description Parts (Links) Single Channel Encoders Used to determine how far something (such as a motor) has rotated or how fast it is rotating. Single channel encoders have only one signal channel and are capable only of determining distance or speed, but not the direction of rotation. Often constructed using a photo interrupter and a slotted disk. TT Motor Disk - Adafruit Photo Interrupter (No breakout) Breakout Board - Amazon 1 Breakout Board - Amazon 2 Breakout Board - Amazon 3 Breakout Board - Amazon 4 Quadrature Encoders Used to determine how far something (such as a motor) has rotated or how fast it is rotating. Quadrature encoders have two signal channels and are capable of distinguishing direction of rotation. Sometimes these are magnetic and sometimes these are optical (two photo interrupters with a slotted disk and precise positioning). TT Motor w/ Builtin Encoder - DFRobot TT Motor (L) w/ Builtin Encoder - DFRobot TT Motor w/ Builtin Encoder - RobotShop TT Motor (L) w/ Builtin Encoder - RobotShop Custom Quadrature Encoder for TT Motor Analog Voltage Monitors Measure a voltage on a sensor coprocessor's analog input pins. A voltage divider can be used to measure larger voltages. Voltage divider modules also exist and can be used instead of loose resistors. Voltage Divider Module - Amazon 1 Voltage Divider Module - Amazon 2 Voltage Divider Module - Amazon 3 Voltage Divider Module - Amazon 4 4-Pin Ultrasonic Sensors Use sound to measure the distance to an object the sensor is facing. This version has 4 pins including a \"trigger\" and \"echo\" pin. Standard HC-SR04 5V/3V Compatible Device HC-SR04 Amazon 1 IR Reflection Detector Often used to detect dark lines on a light surface (line follower robots). Measure IR light reflected off a surface. Longer Range Module - Amazon 1 Longer Range Module - Amazon 2 Shorter Range Module - Amazon 1 Shorter Range Module - Amazon 2 L3GD20H + LSM303 IMU 9DOF sensor (3 axis gyroscope + 3 axis accelerometer + 3 axis magnetometer). Intended to be used with Adafruit's old 9DOF IMU board Adafruit FXOS8700 + FXAS21002 IMU 9DOF sensor (3 axis gyroscope + 3 axis accelerometer + 3 axis magnetometer). Intended to be used with Adafruit's NXP 9DOF IMU board Adafruit MPU-6050 IMU 6DOF sensor (3 axis gyroscope + 3 axis accelerometer). This is a common low cost IMU chip. Adafruit Breakout Board Cable for Adafruit Board Sparkfun Breakout Board Main Computer Sensors Sensor Description Parts (Links) INA260 Voltage + Current Sensor Voltage and current sensor capable of interfacing directly with the main computer (good for robots without a sensor coprocessor). Also provides higher accuracy readings than are typically possible with an Analog Voltage Monitor on a sensor coprocessor. Adafruit"},{"location":"guide/hardware/supportedhardware/#tools-miscellaneous","title":"Tools &amp; Miscellaneous","text":"Other Electrical Components Item Purpose Link(s) LEDs Indicators to user. Connect to main computer's GPIO pins. LEDs require a current limiting resistor. Adafruit 5mm Amazon 5mm - 1 Amazon 5mm - 2 SparkFun 5mm Builtin Resistor Micro SD Card Storage for main computer OS. Generally A1 or A2 rated cards are faster when running an OS from the card. SanDisk Ultra (A1) - Amazon SanDisk Extreme (A2) Samsung Evo Select (A1 / A2) USB Cables Connect devices (power to main computer, sensor coprocessor to main computer, etc) A to Mini B (6 in) A to Micro B (6 in) A to Mini B (3 ft) A to Micro B (3 ft) A to C (6 in) A to C (3 ft) Orange Pi Lite Power Cable Connect USB battery pack power to Orange Pi Lite via DC barrel jack port. Orange Pi Site Amazon - 1 Amazon - 2 Amazon - 3 USB OTG Adapter Used to connect a USB device to a micro-B OTG host port (eg on Pi Zero). Adafruit (No Cable) Adafruit (Cable) Amazon - 1 Amazon 2 Adafruit (Micro B to Micro B) Barrel Jack Connectors Used to attach barrel jack connectors to jumper wires. Useful for motor battery power input. Adafruit (Female) Amazon (Multipack) - 1 Amazon (Multipack) - 2 Jumper Wires Premade wires with \"DuPont\" headers. Useful for connecting sensors. Often come in packs includeing male / male wires, female / female wires, and male / female wires. Amazon - 1 Amazon -2 Adafruit Wire 28AWG Useful for making custom \"DuPont\" jumper wires. Will need the headers, pins, and crimper (see following entries). Also useful to connect low current motors (eg TT motor). Amazon - 1 Amazon - 2 \"DuPont\" Kit Includes pins and housings for \"DuPont\" connectors. Some kits come with a crimper and some wire too. Housings and pins can also be purchased separately. Amazon - 1 Amazon - 2 \"Dupont\" Crimper Used to crimp \"DuPont\" pins to wires. Amazon - 1 Amazon - 2 Amazon - 3 Male .1 inch Header Pins Soldered onto many boards to connect wires or breadboard. Often come with boards, but not always. Adafruit Amazon - 1 Amazon - 2 Logic Level Shifter Used to adjust signals between voltage levels. Necessary to connect some sensors to some boards (eg 5V sensors to 3.3V boards). Note that not all shifters support logic level frequencies (PWM, I2C, SPI, UART, etc) and may only work for lower frequency GPIOs. Parts linked here are bidirectional level shifters. Adafruit - 1 Adafruit - 2 Amazon - 1 Amazon - 2 Switches Often used to switch motor battery on and off. Adafruit - 1 Adafruit - 2 Adafruit - 3 Mini Breadboard Used to connect electronics without soldering. Very small size. Adafruit Amazon - 1 Amazon - 2 Half Size Breadboard Used to connect electronics without soldering. Half of standard size. Adafruit Amazon - 1 Amazon - 2 Full Size Breadboard Used to connect electronics without soldering. Standard size. Adafruit Amazon - 1 Amazon - 2 USB / UART Converter Useful to connect to main computer by UART (debugging, fixing things, etc). Not usually necessary, but useful to have at times. Often sold as a \"Console Cable\", having  a blue USB connector housing. DO NOT BUY THIS TYPE OF CABLE FROM AMAZON. THE PL2303 ONES SOLD THERE GENERALLY DO NOT WORK IN RECENT YEARS! Adafruit is the only source that still has a functional version (different chip). The adapters linked here do work and are 3.3V devices (suitable for use with Raspberry Pi boards). Adafruit Amazon - 1 Amazon - 2 SparkFun Tools and Assembly Components Item Purpose Link(s) Hook and Loop Tape Commonly wrongly referred to as \"Velcro\". Useful for attaching electronics to the robot. WARNING: Do not apply this direclty to PCBs. Some adhesives are conductive, corrosive, or may become so over time. As such, a layer of electrical tape should be between any PCB and adhesive on hook and loop tape. Amazon -1 Amazon - 2 Twist Ties Useful for cable management. Plastic ones hold up better than paper ones. Amazon - 1 Amazon - 2 Zip Ties Useful for cable management or attaching components. Amazon - 1 Amazon - 2 Hot Glue + Glue Gun Hot glue is useful for attaching components. It is also not conductive or corrosive so it can be placed directly on PCBs. Amazon - 1 Amazon - 2 Amazon - 3 Super Glue Useful for attaching parts when hot glue is not strong enough. Comes in gel and liquid forms. The gel is easier to use, but often more expensive. Amazon (Gel) - 1 Amazon (Liquid) - 1 Amazon (Gel) - 2 Amazon (Liquid) - 2 Electrical Tape Useful for cable management and anything where adhesives need to contact electronics. Amazon - 1 Amazon - 2 Ruler Useful for measuring for placements. Not for precision measurements. Amazon - 1 Amazon - 2 Small Screwdriver Kit Useful for working with small screws found in screw terminals and other parts. Amazon - 1 Amazon - 2 Amazon - 3 Solder Iron Used to attach electronics, install headers on PCBs, etc. Sometimes come in kits. Solder is also required. Note: Some of the kits linked here are cheap. They should work for simple jobs, but won't work as well as a slightly more expensive option. Also note that these cheaper kits often include lead solder. Lead solder is easier to work with than leadless (and requires lower temperatures), but it is lead. Amazon (Cheap Kit) - 1 Amazon (Cheap Kit) - 2 Adafruit - Iron Adafruit - Lead Solder Adafruit - Leadless Solder Multimeter Useful for debugging electrical problems. Also just a useful tool to have around. Amazon - 1 Amazon - 2 Amazon - 3 Wire Stripper Used to remove insulation from wires. Amazon - 1 Amazon - 2 Amazon - 3"},{"location":"guide/other/audio/","title":"Playing Audio","text":"<p>Many single board computers include interfaces capable of outputting audio. Typically, this is a 3.5mm audio jack or an HDMI interface. Many also have an \"I2S\" interface which can use an external audio amplifier and speaker to play audio. This is often the most compact solution for use on robots, however it is more involved to setup.</p>"},{"location":"guide/other/audio/#example-i2s-setup","title":"Example I2S Setup","text":"<p>This section describes setting up an Adafruit MAX98357A Breakout (I2S AMP) on a Raspberry Pi. This process will vary on different systems.</p> <p>Connections:</p> MAX98357A Breakout Pin SBC Pin Raspberry Pi Pin Recommended Wire Color VIN 5V 5V Red GND GND GND Black SD (not connected) (not connected) N/A GAIN (not connected) (not connected) N/A DIN PCM DOUT / I2S DOUT GPIO 21 Blue BCLK PCM CLK / I2S CLK GPIO 18 Yellow LRC PCM FS / I2S FS GPIO 19 Green <p>See Adafruit's documentation for more details.</p> <p>Software Setup:</p> <ul> <li>Follow Adafruit's Guide. Note that since the robot does not have internet access, the automated install process will not work. You must follow the steps in \"Detailed Install\".</li> <li>You will need to Connect to the robot via SSH to follow these steps.</li> <li>These steps are for a Raspberry Pi. The software setup will not be the same for other single board computers. For other systems, it is recommended to search the SBC's name followed by \"I2S\". There will likely be an existing guide to enable I2S on the board.</li> </ul>"},{"location":"guide/other/audio/#playing-audio-in-a-robot-program","title":"Playing Audio in a Robot Program","text":"<p>The <code>ArPiRobot-CoreLib</code> includes an <code>AudioManager</code> object that is capable of playing audio files in <code>.wav</code>, <code>.mp3</code>, and <code>.flac</code> formats. </p> <p>The <code>AudioManager</code> includes three functions of interest:</p> <ul> <li><code>get_playback_devices()</code> / <code>getPlaybackDevices()</code>: Returns a list of playback devices. Each device has a name and some other information about the device. </li> <li><code>play_sound()</code> / <code>playSound()</code>: Plays a given audio file. Can also specify a specific audio device to play it on (one of the devices from <code>get_playback_devices</code> / <code>getPlaybackDevices()</code>) instead of using the \"default\" audio device. This function returns an integer to identify a \"job\" (which really just means a specific file being played).</li> <li><code>stop_job()</code> / <code>stopJob()</code>: Stops the job with the given identifier (integer returned from <code>play_sound()</code> / <code>playSound()</code>). This is used to stop a sound \"early\". If the file has already finished playing, this function has no effect.</li> </ul> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.core.audio import AudioManager, AudioDeviceInfo\n\ndef __init__(self):\n    super().__init__()\n    self.dev: AudioDeviceInfo = None\n    self.has_device: bool = False\n    self.job: int = -1\n\ndef robot_started(self):\n    # Searching for a specific audio device\n    # This is an I2S interface's name on a raspberry pi\n    for dev in AudioManager.get_playback_devices():\n        if dev.name == \"snd_rpi_hifiberry_dac, HifiBerry DAC HiFi pcm5102a-hifi-0\":\n            self.dev = dev\n            self.has_device = True\n\ndef robot_enabled(self):\n    # Start playing an audio file named \"enable.mp3\"\n    # This file is in the \"sound_files\" folder in the arpirobot project\n    # Thus it is placed in \"/home/arpirobot/arpirobot/sound_files\"\n    # Only play on the specific device if the device was found in robot_started\n    # Otherwise, play on the \"default\" playback device\n    if self.has_device:\n        self.job = AudioManager.play_sound(\"/home/arpirobot/arpirobot/sound_files/enable.mp3\", self.dev)\n    else:\n        self.job = AudioManager.play_sound(\"/home/arpirobot/arpirobot/sound_files/enable.mp3\")\n\ndef robot_disabled(self):\n    # Stop playing the enable sound if it is playing\n    # If job is -1 or the job has completed, this does nothing\n    AudioManager.stop_job(self.job)\n</code></pre> <pre><code>// Add at top with includes\n#include &lt;arpirobot/core/audio/AudioDeviceInfo.hpp&gt;\n\n// Add as member variables of Robot class with other member variables\nAudioDeviceInfo dev;\nbool hasDev = false;\nint job = -1;\n</code></pre> <pre><code>void robotStarted(){\n// Searching for a specific audio device\n// This is an I2S interface's name on a raspberry pi\nfor(auto &amp;dev : AudioManager::getPlaybackDevices()){\nif (dev.name == \"snd_rpi_hifiberry_dac, HifiBerry DAC HiFi pcm5102a-hifi-0\"){\nthis-&gt;dev = dev;\nthis-&gt;hasDev = true;\n}\n}\n}\n\nvoid robotEnabled(){\n// Start playing an audio file named \"enable.mp3\"\n// This file is in the \"sound_files\" folder in the arpirobot project\n// Thus it is placed in \"/home/arpirobot/arpirobot/sound_files\"\n// Only play on the specific device if the device was found in robot_started\n// Otherwise, play on the \"default\" playback device\nif(hasDev){\njob = AudioManager::playSound(\"/home/arpirobot/arpirobot/sound_files/enable.mp3\", dev)\n}else{\njob = AudioManager::playSound(\"/home/arpirobot/arpirobot/sound_files/enable.mp3\")\n}\n}\n\nvoid robotDisabled(){\n// Stop playing the enable sound if it is playing\n// If job is -1 or the job has completed, this does nothing\nAudioManager::stopJob(job)\n}\n</code></pre> <p>Finally, the project's json file needs to be modified to make the deploy tool copy the <code>sound_files</code> folder. Edit <code>arpirobot-proj.json</code> and add the following in the <code>deployFiles</code> section.</p> <pre><code>\"sound_files/\"\n</code></pre> <p>The file should look something like the following</p> Python ProjectC++ Project <pre><code>{\n\"version\": 2,\n\"deployFiles\": [\n\"src/*\",\n\"main.sh\",\n\"sound_files/\"\n],\n\"coreLibFiles\": [\n\"lib/*\",\n\"python_bindings/arpirobot/\"\n]\n}\n</code></pre> <pre><code>{\n\"version\": 2,\n\"deployFiles\": [\n\"build/robot\",\n\"main.sh\",\n\"sound_files/\"\n],\n\"coreLibFiles\": [\n\"lib/*\"\n]\n}\n</code></pre> <p>You will also need to place an audio file in <code>mp3</code> format a folder named <code>sound_files</code> in your project (next to the <code>src</code> folder). The file must be called <code>enable.mp3</code>. Alternatively, the filename could be changed in the example code above.</p> <p>When run, this example program will play the sound when enabled, and stop it when disabled.</p>"},{"location":"guide/other/camstream/","title":"Camera Streaming","text":"<p>The ArPiRobot-CameraStreaming component is pre-installed on all ArPiRobot OS images. This component includes scripts to generate and invoke gstreamer pipelines for realtime camera streaming. An RTSP server is also installed (rtsp-simple-server). The combination of these two components allows for multiple low-latency camera streams over the robot's wifi network.</p>"},{"location":"guide/other/camstream/#configuring-camera-streams","title":"Configuring Camera Streams","text":"<p>There are three ways to configure camera streams</p> <ol> <li> <p>The <code>camstream.py</code> script can be run directly (over ssh for example). In this case, the options described below are passed as command line flags (see <code>camstream.py --help</code> or the <code>README.md</code> file in the github repository for specific flags).</p> </li> <li> <p>Text (<code>.txt</code>) files in <code>/home/arpirobot/camstream</code> are configurations for camera streams. These files contain command line flags. The name of the text file is the name of the stream. The system service <code>camstream</code> will launch a camestream pipeline for each <code>.txt</code> file when it is started.</p> </li> <li> <p>The Deploy Tool can configure camera streams in the \"Camera Stream\" tab. This is a GUI frontend to edit the text file described in method 2. It also includes buttons to play streams as well as start / stop the <code>camstream</code> service and the <code>rtsp</code> server. Note that the <code>camstream</code> service must be restarted (stop then start again) after modifying configurations.</p> </li> </ol>"},{"location":"guide/other/camstream/#source-options","title":"Source Options","text":"<p>Three camera \"drivers\" are currently supported:</p> <ul> <li>RasPiCam</li> <li>LibCamera w/ LibCamera Apps</li> <li>Video4Linux2 (V4L2)</li> </ul> <p>The first two methods currently only support Raspberry Pi devices using the Raspberry Pi Camera. Also note that RasPiCam is replaced by LibCamera, however for now raspicam is used instead on ArPiRobot OS images for Raspberry Pi devices. As such, libcamera will not work (without modifications). The third method (v4l2) is a generic linux camera input method that should work with most cameras on most devices. Any USB webcam should work with this input method.</p> <p>When using the v4l2 driver there are two additional options available</p> <ul> <li><code>device</code>: This is used to specify a v2l4 device (<code>/dev/video#</code>)</li> <li><code>iomode</code>: This is used to specify a v4l2 iomode. Use <code>auto</code> unless you get high latency. For usb webcams, using <code>dmabuf</code> may reduce latency</li> </ul> <p>Additionally, for all drivers, there is a <code>vconvert</code> (video convert) option for inputs. This adds a <code>videoconvert</code> element to the pipeline and can help in cases where camera input format is not directly handled by the next elements in the pipeline. Basically, if something doesn't work try turning this on. Otherwise, it should not be needed.</p>"},{"location":"guide/other/camstream/#video-options","title":"Video Options","text":"<ul> <li><code>width</code>: Video resolution width*</li> <li><code>height</code>: Video resolution height*</li> <li><code>framerate</code>: Video framerate*</li> <li><code>flip</code>: Flip the video one one or both axes (<code>hflip</code>, <code>vflip</code> flags)</li> <li><code>rotate</code>: Rotate the video. Most drivers / cameras only support 0 or 180. raspicam supports 90 and 270.</li> <li><code>gain</code>: Supported only for the Raspberry Pi Camera using the raspicam or libcamera drivers. Adjusts the camera's \"sensitivity\" to light.</li> </ul> <p>*The combination of these three parameters must be a supported input mode of the camera. Check your specific camera's specs for supported input modes.</p>"},{"location":"guide/other/camstream/#stream-options","title":"Stream Options","text":"<p>Two output formats are supported using the <code>format</code> option: <code>h264</code> and <code>mjpeg</code>. <code>h264</code> will take a little more time to encode / decode, but uses much less bandwidth for a given resolution / framerate. <code>mjpeg</code> is rarely useful for realtime streams.</p> <p>When using the <code>h264</code> format, the following options are used</p> <ul> <li><code>encoder</code>: Which H.264 encoder to use. <code>libav-omx</code> uses omx hardware acceleration on Raspberry Pi devices. The <code>omx</code> encoder also uses hardware acceleration, but is not available on some newer systems (thus <code>libav-omx</code> is recommended instead). <code>libx264</code> is a software encoder that should work on any device.</li> <li><code>profile</code>: Which H.264 profile to use (baseline, main, or high). Baseline is typically recommended for realtime streams (especially if software encoding is used).</li> <li><code>bitrate</code>: Target stream bitrate in bits / second</li> </ul> <p>When using the <code>mjpeg</code> format, the followint options are used</p> <ul> <li><code>quality</code>: Integer between 1 and 100. Controls jpeg image quality of frames. Lower numbers reduce bitrate and image quality. Note that this parameter has no effect with the raspicam driver. If using raspicam, use the <code>bitrate</code> option instead. This option sets target stream bitrate and automatically adjusts quality to achieve this.</li> </ul>"},{"location":"guide/other/camstream/#network-options","title":"Network Options","text":"<ul> <li><code>netmode</code>: Controls stream network mode. Either <code>tcp</code>, <code>udp</code>, or <code>rtsp</code>. Defaults to <code>rtsp</code> which is generally recommended for robots. <code>tcp</code> and <code>udp</code> stream one camera directly to one computer. <code>rtsp</code> is a server that can handle multiple streams and clients. It also makes using <code>udp</code> easier than directly using <code>udp</code> mode (which is better for realtime streams).</li> <li><code>address</code>: Address to send the stream to. For <code>tcp</code> mode this is a local address to host a <code>tcp</code> server. For <code>udp</code> mode this is the address of the computer to send the stream to. For <code>rtsp</code> mode this is the address of the computer hosing the rtsp server (typically the same device so <code>127.0.0.1</code> or <code>localhost</code>).</li> <li><code>port</code>: Port associated with the address. For the included <code>rtsp</code> server, use port <code>8554</code>. For <code>tcp</code> and <code>udp</code> modes, choose a port number.</li> <li><code>rtspkey</code>: Only applies in <code>rtsp</code> mode. This is a unique identifier for this stream (rtsp servers can have multiple streams; this identifies which stream). Each stream on the rtsp server must have a unique identifier.</li> </ul>"},{"location":"guide/other/camstream/#playing-camera-streams","title":"Playing Camera Streams","text":"<p>Many programs can play the streams in various supported netmodes, however often additional configuration is needed to achieve low latency playback. As such, the camera streaming repository includes a <code>playstream.py</code> script that will launch <code>ffplay</code>, <code>mpv</code>, or <code>mplayer</code> to play a stream. See the <code>README.md</code> file in the github repository for more info.</p> <p>Additionally, the Deploy Tool provides a GUI to play streams using any of these three players. The players themselves though must be installed on your system separately (and be in the system <code>PATH</code>).</p>"},{"location":"guide/other/ssh/","title":"Connect By SSH","text":"<p>While the ArPiRobot framework is designed such that logging in to the Pi via SSH is unnecessary, it may sometimes be required or desired to debug certain features or change settings that may be otherwise unavailable.</p>"},{"location":"guide/other/ssh/#what-is-ssh","title":"What is SSH","text":"<p>In simple terms SSH is a way to login to another computer over a network (such as WiFi). In this case, we can log into the Raspberry Pi on the robot from a PC that is connected to the robot's WiFi network.</p> <p>When logged in via SSH there is no graphical environment (no desktop, start menu, mouse, etc). SSH provides only a command line interface (similar to using command prompt on Windows or the terminal app on macOS). If you are not familiar with using a Linux shell CLI, you probably have little reason to log into the robot using ssh. However, if you want to learn more you can look at this tutorial or this one.</p>"},{"location":"guide/other/ssh/#installing-a-ssh-client-on-your-computer","title":"Installing a SSH Client on your Computer","text":"<p>Most modern operating systems include the OpenSSH client by default. Linux distributions and macOS have included it for a long time. More recently Windows 10 began including OpenSSH's client by default. The OpenSSH client is a command line program that connects to another device by ssh. The other device must be running an SSH server (which the Pi on the robot is). </p> <p>The OpenSSH client is invoked by running the <code>ssh</code> command in a terminal (or command prompt on Windows). Run the following command to list the OpenSSH version</p> <pre><code>ssh -V\n</code></pre> <p>If you see an error about the command not being found (or ssh not being a valid command) you do not have OpenSSH installed (or it may not be in your PATH if you installed it on an older version of windows). If you are using Windows 10 and <code>ssh</code> is not found you may need to install the feature.</p> <p>If you are on an older version of windows that does not include OpenSSH you can install it. win32-openssh can also be installed using the scoop package manager for windows. Alternatively, use PuTTY as described below. </p> <p></p> <p>There are other ssh clients that can be used. One of the most popular of which is PuTTY. PuTTY provides a graphical interface to configure the SSH session and connect. It is particularly commonly used on Windows operating systems, but many Linux distributions have PuTTY builds in their package repositories. On macOS putty can be installed using Homebrew.</p>"},{"location":"guide/other/ssh/#connecting-to-the-robot","title":"Connecting to the Robot","text":"<p>The following information is required to connect to the robot's Pi. You must already be connected to the robot's WiFi.</p> <p>Address: <code>192.168.10.1</code> Port: <code>22</code> (default for SSH) Username: <code>pi</code> Password: <code>arpirobot</code> This information is the same as documented on the Default Settings page.</p> <p>OpenSSH:</p> <p>To connect using OpenSSH's client run the following command</p> <pre><code># ssh -l [username] [address]\n# Port is omitted because default is 22\nssh -l pi 192.168.10.1\n</code></pre> <p>You will likely be asked to approve the host's key. This is a way of making sure you are connecting to the device you intended. Simply type \"yes\" and press enter. You will not be asked again. However, if you connect to a different robot, you will get an error because the key will have changed and, but the address is the same. In this case you have to remove the entry from <code>~/.ssh/known_hosts</code>. Alternatively, see the \"Ignoring SSH Host Key\" section below. After approving the key (if necessary) enter the password. You will then be logged in.</p> <p>PuTTY</p> <p>Select \"SSH\" for the connection type. Enter the address in the \"Host name\" field. Make sure the port is set to <code>22</code> (it will be by default if the connection type is SSH). Then, click Open.</p> <p></p> <p>If prompted accept the key. If you connect to a different robot (same IP, different key) PuTTY will warn you, but give you a button to connect anyways.</p> <p>You will then be prompted for the username (\"login as\") and the password. Enter both and you will have a shell session.</p>"},{"location":"guide/other/ssh/#ignoring-ssh-host-key","title":"Ignoring SSH Host Key","text":"<p>Note: This applies only to the OpenSSH client, not PuTTY.</p> <p>Each Pi has its own ssh host key. As such, when working with several robots you may run into issues where the current key does not match the one in <code>~/.ssh/known_hosts</code>. As such, it may be desirable to ignore the host key for this specific IP address (<code>192.168.10.1</code>). This can be done by adding the following to the <code>~/.ssh/config</code> file (<code>C:\\username\\.ssh\\config</code> on windows).</p> <pre><code>Host 192.168.10.1\n    StrictHostKeyChecking no\n    UserKnownHostsFile=/dev/null\n</code></pre> <p>On windows instead of <code>/dev/null</code> use <code>nul</code> so it becomes</p> <pre><code>Host 192.168.10.1\n    StrictHostKeyChecking no\n    UserKnownHostsFile=nul\n</code></pre>"},{"location":"guide/other/wifidebug/","title":"WiFi Debugging","text":"<p>Note: This is intended as a resource to help debug WiFi issues when connected to the robot's WiFi network (the access point generated by the Raspberry Pi on the robot).</p> <p>Sometimes there may be issues with a robot related to WiFi. These issues can include</p> <ul> <li>Takes a long time to connect to the robot with the Deploy Tool or Drive Station</li> <li>Deploy Tool and/or Drive Station frequently disconnect (loose connection to robot)</li> <li>Robot \"randomly\" stops for a second or two then starts working again when controlling it with a gamepad</li> <li>Robot responds late to gamepad input (high input latency)</li> </ul> <p>While there are other problems that can cause these issues WiFi is a common one. WiFi-related problems can be caused by many things including</p> <ul> <li>The distance between the robot and the computer</li> <li>The other WiFi networks in your area</li> <li>The WiFi adapter on your PC or WiFi settings on your PC</li> <li>The WiFi adapter/settings on the Raspberry Pi</li> </ul>"},{"location":"guide/other/wifidebug/#first-steps","title":"First Steps","text":"<ul> <li>Reboot the robot and your PC</li> <li>If there are still issues follow the \"Check the Channel\" Steps in the debugging section below</li> <li>If there are still issues run the bandwidth/latency tests</li> <li>If there are still issues<ul> <li>If the bandwidth and latency tests seem OK the issues are probably not network related</li> <li>If the bandwidth and latency tests seem to indicate a network problem see the PC WiFi adapter section below</li> </ul> </li> </ul>"},{"location":"guide/other/wifidebug/#steps-to-debug","title":"Steps to Debug","text":""},{"location":"guide/other/wifidebug/#physical-location","title":"Physical Location","text":"<p>WiFi has a limited range and you will likely get the best results if the PC controlling your robot is within 50 feet of the robot. Also make sure there are no walls or other objects between the robot and your PC.</p>"},{"location":"guide/other/wifidebug/#check-the-channel","title":"Check the Channel","text":""},{"location":"guide/other/wifidebug/#short-version","title":"Short Version","text":"<p>The first step to debugging WiFi issues is to make sure your are on a channel where there is little interference from other nearby WiFi networks on the same channel. Using WiFi Analyzer apps (see recommendations for iOS and Android in long version section below) it is easy to determine what channels nearby networks are using. Ideally, you would choose a channel with no other nearby network on it, however in reality this is not always possible. The most important things to consider if there is not a free channel are: </p> <ol> <li>What channels are the closest (strongest signal) networks using</li> <li>How many networks are on a given channel</li> </ol> <p>Try to find a channel with few nearby networks and with the weakest signal strengths from nearby networks. Avoiding the channel of the closest networks is key, which often means your home network.</p> <p>You can use the Network settings tab in the Deploy Tool to change the WiFi channel. </p>"},{"location":"guide/other/wifidebug/#long-version","title":"Long Version","text":"<p>As widely-used as WiFi is it does have one major problem: WiFi networks compete with each other. There are a certain number of WiFi channels available and when multiple networks are on the same channel and both in range of your device they end up competing with each other. There are multiple WiFi frequency ranges divided into these channels. The robot uses the 2.4GHz channels (numbered 1 to 14*).</p> <p>The biggest issues comes when two nearby networks are on the same channel (or close channels as there is some overlap in frequencies). For example, if you have a home WiFi network on the same channel as the robot this could cause many issues, especially since most wireless routers have much more powerful transmitters the Raspberry Pi does. It can also be an issue if other nearby networks are on the same channel, such as neighbor's networks.</p> <p>The first step to debugging WiFi issues is determining the \"best\" channel. One easy way to do this is by using a \"WiFi Analyzer\" app on your phone or computer.</p> <p>For Android I recommend an open source WiFi Analyzer.</p> <p>For iOS there are fewer of these apps available for free, however Apple's Airport Utility app should be able to do this. You can follow this guide, however it is more basic than the recommended android app and lacks the ability to graph the channels as will be described below. Instead you'll get a list of networks and their strengths and channels. The same concepts described below still apply.</p> <p>After scanning for wifi networks (following the guide linked above for iOS or just opening the app on Android) you will get a list of networks in descending order of signal strength. The list will also indicate the network's channel. These scans will show networks from other frequency ranges (such as 5GHz networks) so ignore any where the channel number is not 1 through 14. In the Android app you can tap \"Channel Graph\" at the bottom to switch to a graph of available networks and the channels they are on (this also shows overlap of channels).</p> <p>Often this list of channels will be very long. The most important things to consider are</p> <ol> <li>What channels do the closest (strongest signal) networks use</li> <li>How many networks are on channels that the closest network does not use</li> </ol> <p>Ideally you want to find an unused channel, however that is often not possible so using a channel further from the one in use by the closest networks (usually your home network) is the best option. From there you want to find a channel with the fewest number of other networks on it (you may also want to consider how strong of a signal those other networks have). This is where the channel graph in the Android app can be really helpful.</p> <p>Once you decide which channel to use you can change the WiFi channel by using the Network Settings tab in the Deploy Tool.</p> <p>This should help fix many WiFi related issues, however keep in mind that WiFi routers will \"seek\" the best channel, meaning they may change what channel they use to try to find the best option. The Raspberry Pi does not do this, so it is possible that the best channel for the Pi will change over time. If you find this happening a lot it is advised to change the settings on your home WiFi network (if possible) to use a specific channel instead of \"Auto\" or \"Best\".</p> <p>*In many countries there are restrictions on which channels can be used. In the US the allowed channels are 1 through 11 (source). If you try to configure the Pi to use a channel out of the allowed range for the configured country it will not start the WiFi network and you may have to re-flash the SD card to get access to the robot back.</p>"},{"location":"guide/other/wifidebug/#test-the-network","title":"Test the Network","text":"<p>After making sure your network is on a \"good\" channel, if you are still having issues it will often be useful to test network bandwidth and latency. The bandwidth is simply how much data can be sent in a certain amount of time. The latency is how long between when one device sends data and when the other receives it.</p> <p>In both tests we will be testing between the Raspberry Pi and your computer.</p>"},{"location":"guide/other/wifidebug/#testing-latency","title":"Testing Latency","text":"<p>To test network latency we will use a tool builtin to most modern operating systems called ping.</p> <p>On windows open a command prompt (Win+R then type cmd.exe and hit enter). In the command prompt run</p> <pre><code>ping -n 10 -l 32 192.168.10.1\n</code></pre> <p>On Linux/macOS open a terminal and run</p> <pre><code>ping -c 10 -s 24 192.168.10.1 \n</code></pre> <p>This will send 10 packets of 32-bytes each to the raspberry pi and wait for it to send the same data back. It will report how long it took for each packet in milliseconds. A value below 10ms is generally good. If it frequently jumps higher you may want to consider changing WiFi channels and/or rebooting the Pi or your PC. If this does not seem to help see the PC WiFi adapter section below.</p>"},{"location":"guide/other/wifidebug/#testing-bandwidth","title":"Testing Bandwidth","text":"<p>To test network bandwidth we will use a tool called iperf.</p> <p>As of the Beta7 image iperf3 is included in the image. For older images you will need to  copy the sources to the Pi and build from source.</p> <p>On the Pi login via SSH and run </p> <pre><code>iperf3 -s\n</code></pre> <p>Then on your PC download iperf3 and run (in the same directory as you extracted iperf)</p> <pre><code>./iperf3 -c 192.168.10.1\n</code></pre> <p>This will give useful information about bandwidth between the Pi and the PC. Generally if the speed is above 2Mbits/sec you should have no problem with the robot, however if the speed suddenly drops to 0 or close to 0 you may want to consider either rebooting the robot or your PC and trying again and/or changing the WiFi channel. If this does not seem to help see the PC WiFi adapter section below.</p>"},{"location":"guide/other/wifidebug/#pc-wifi-adapters","title":"PC WiFi Adapters","text":"<p>Sometimes network issues are related to the WiFi adapter in your PC. Sometimes an adapter may have trouble with certain channels and sometimes the WiFi adapter may just be weak or have a bad driver. If you are experiencing network issues if possible it is always recommended to run the bandwidth and latency tests from multiple PCs. If one seems to have problems and another does not the problem is likely with the PC WiFi adapter. If both have issues the issue may still be with the Pi.</p> <p>If you suspect the problem is the PC's WiFi adapter you have a few options:</p> <ul> <li>Update your WiFi drivers. If you are using a Windows PC that came with WiFi check the manufacturer's website for driver updates or check the WiFi card vendor's website.</li> <li>If you are using a USB WiFi adapter make sure it is plugged into a USB 2.0 port not a USB 3 port (including a USB-C port using an adapter). Make sure the adapter is not behind your PC (if using a desktop PC). You can also try a different USB port and/or a USB extension cable to move the adapter further form the PC.</li> <li>You may want to consider a different WiFi adapter. Ones that connect to a USB port are generally the easiest way to do this. See the next bullet for information about some of these.</li> <li>If you are using a USB WiFi adapter with builtin antenna these will always work better than the ones without an antenna. That being said, I've had good results with some without antennas including TPLink's TL-WN725N. If you're willing to spend a little more on one with an antenna those almost always are the better option, but if not the TL-WN725N is a decent option and not very expensive.</li> </ul>"},{"location":"guide/other/wifidebug/#advanced-options-on-the-pi","title":"Advanced Options on The Pi","text":"<p>To perform these steps you will need to be able to login to the Pi via SSH. Alternatively you can login via the UART console using a Raspberry Pi console cable.</p> <p>Edit <code>/etc/hostapd/hostapd.conf</code> as root (<code>sudo nano /etc/hostapd/hostapd.conf</code>)</p> <p>Somewhere in the file there should be the following two lines (don't worry about what they are equal to in the file). If one or both don't exist add the missing one(s) at the end of the file</p> <pre><code>wmm_enabled\nwme_enabled\n</code></pre> <p>These options can be set either to 1 or 0. Try all of the following combinations and re-run the latency and bandwidth tests after applying each. After making a change make sure to save the file and run <code>sudo systemctl restart hostapd</code> or reboot the Pi. If you find a setup that works leave the file alone and keep that setup.</p> <pre><code>wmm_enabled=0\nwme_enabled=0\n</code></pre> <pre><code>wmm_enabled=1\nwme_enabled=0\n</code></pre> <pre><code>wmm_enabled=0\nwme_enabled=1\n</code></pre> <pre><code>wmm_enabled=1\nwme_enabled=1\n</code></pre>"},{"location":"guide/programming/actions/","title":"Using Actions","text":"<p>Up until now, this guide has used the periodic programming model. This is the programming model where robot functionality is implemented using the <code>enabled_periodic</code> / <code>enabledPeriodic</code> and <code>disabled_periodic</code> / <code>disabledPeriodic</code> functions in the <code>Robot</code> class. While this has worked fine so far, it becomes limiting for more complex robot programs.</p>"},{"location":"guide/programming/actions/#challenges-with-periodic-programming-model","title":"Challenges with Periodic Programming Model","text":"<p>The main issue with the periodic programming model is switching between tasks. Suppose you sometimes want the robot to respond to gamepad controls, at other times you want it to drive some distance on its own. How do you implement both in <code>enabled_periodic</code> / <code>enabledPeriodic</code>? You would need some variable that indicates what task you are currently performing. This could be a simple integer where zero means human drive and one means autonomous drive, however this quickly becomes difficult to work with. What happens if you want your robot to drive a triangle instead of just a straight line? Task zero is still human drive, task one drives an edge, task two rotates, task three drives the next edge and so on. Once done, it goes back to task zero. This could look something like the following</p> PythonC++ <pre><code># In enabled_periodic\nif task == 0:\n    # Respond to gamepad controls\n    # Drive using drive helper\n    # If a button is pressed switch to task 1\n    # Store start time of task 1\nelif task == 1:\n    # Drive straight\n    # if enough time has passed, move to task 2\n    # Store start time of task 2\nelif task == 2:\n    # Rotate\n    # if enough time has passed, move to task 3\n    # Store start time of task 3\nelif task == 3:\n    # Drive straight\n    # if enough time has passed, move to task 4\n    # Store start time of task 4\nelif task == 4:\n    # Rotate\n    # if enough time has passed, move to task 5\n    # Store start time of task 5\nelif task == 5:\n    # Drive straight\n    # if enough time has passed, move to task 6\n    # Store start time of task 6\nelif task == 6:\n    # Rotate\n    # if enough time has passed, move to task 0\n</code></pre> <pre><code>// In enabledPeriodic\nif (task == 0){\n// Respond to gamepad controls\n// Drive using drive helper\n// If a button is pressed switch to task 1\n// Store start time of task 1\n}}elif (task == 1){\n// Drive straight\n// if enough time has passed, move to task 2\n// Store start time of task 2\n}elif (task == 2){\n// Rotate\n// if enough time has passed, move to task 3\n// Store start time of task 3\n}elif (task == 3){\n// Drive straight\n// if enough time has passed, move to task 4\n// Store start time of task 4\n}elif (task == 4){\n// Rotate\n// if enough time has passed, move to task 5\n// Store start time of task 5\n}elif (task == 5){\n// Drive straight\n// if enough time has passed, move to task 6\n// Store start time of task 6\n}elif (task == 6){\n// Rotate\n// if enough time has passed, move to task 0\n}\n</code></pre> <p>Looking at the above outline, it has a few issues. First, it is hard to read what the program is supposed to be doing. Without comments looking at code structured like the above outline would be very difficult to interpret. Second, it is hard to modify the sequence of tasks. Say you wanted to introduce a delay between task 0 and 1. You now need to change many places in the code. Finally, there is a lot of duplicated code. Three different tasks drive straight. Three rotate. Reusing code in this format is very difficult. It becomes even more difficult if you wanted to the ability to drive many different shapes. The rotate code for a triangle could not be reused for a square, so you would have seven rotate task. The code is not modular and reusable and is also difficult to follow. This is clearly a non-ideal way to create complex sequences of tasks. The action system helps to address these issues.</p>"},{"location":"guide/programming/actions/#what-is-an-action","title":"What is an Action","text":"<p>Object oriented programming makes reusing code easy. The action system takes advantage of this. Each action is an object of a certain type. That type might be a rotate action or a drive action. If you need to rotate multiple times, the same action just has multiple instances (possibly with different parameters during construction). For example, this would allow you to define an action that rotates for some amount of time and create instances of that action to rotate for 1 second, 2 seconds, 3 seconds, etc. This allows the same code to be used for all three rotations.</p> <p>This approach helps solve the code reusability / organization and readability issues, but what exactly is an action? In simple terms an actions is like one of the tasks defined previously. An action is a class that defines how to perform a specific type of task. This task could be driving with the gamepad, driving straight for some amount of time, or rotating for some amount of time. Once that class is defined instances of that class are created to represent specific tasks. Those objects (instances) can be started and stopped independently of each other.</p> <p>In other words, an action is a class that defines how to perform a task. An instance of an action is an object that represents a specific task. Each instance can be started and stopped when needed to create complex robot programs.</p>"},{"location":"guide/programming/actions/#action-structure","title":"Action Structure","text":"<p>An action is a class that inherits from the builtin <code>Action</code> class (part of ArPiRobot CoreLib). Child classes must implement four functions to define the behavior of an action.</p> PythonC++ <ul> <li><code>begin()</code>: Run each time an action is started. Any setup for the action should occur here including locking devices (explained later).</li> <li><code>process()</code>: Run periodically while an action is running. Every 50ms (by default) this function is run. This is where the main functionality of the action is often implemented.</li> <li><code>finish(was_interrupted: bool)</code>: Called when the action is stopped / stops. There are two ways an action can stop. First, it's <code>should_continue</code> function returns false (used to allow the action to stop itself when it finishes). Second, it can be interrupted (stopped early) for a number of reasons (explained later). The <code>was_interrupted</code> argument is used to inform the action why it is stopping. Any cleanup for the action should be done here. Anything the action was doing should also be stopped here. Sometimes, what is done depends on whether the action completed (based on <code>was_interrupted</code>).</li> <li><code>should_continue() -&gt; bool</code>: This function is called after each time <code>process</code> is run. If this function returns false, this action will stop (<code>process</code> will not run again). If this function returns true, this action will continue running (<code>process</code> will be called again later unless this action is interrupted). The only way an action can finish without being interrupted is if this function returns false.</li> </ul> <pre><code>class MyAction(Action):\n    def begin(self):\n        # Setup for the action to run\n        pass\n\n    def process(self):\n        # Implement the action\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Stop anything / do any cleanup\n        pass\n\n    def should_continue(self) -&gt; bool:\n        # Return False when action is done\n        return True\n</code></pre> <ul> <li><code>void begin()</code>: Run each time an action is started. Any setup for the action should occur here including locking devices (explained later).</li> <li><code>void process()</code>: Run periodically while an action is running. Every 50ms (by default) this function is run. This is where the main functionality of the action is often implemented.</li> <li><code>void finish(bool wasInterrupted)</code>: Called when the action is stopped / stops. There are two ways an action can stop. First, it's <code>shouldContinue</code> function returns false (used to allow the action to stop itself when it finishes). Second, it can be interrupted (stopped early) for a number of reasons (explained later). The <code>wasInterrupted</code> argument is used to inform the action why it is stopping. Any cleanup for the action should be done here. Anything the action was doing should also be stopped here. Sometimes, what is done depends on whether the action completed (based on <code>wasInterrupted</code>).</li> <li><code>bool shouldContinue()</code>: This function is called after each time <code>process</code> is run. If this function returns false, this action will stop (<code>process</code> will not run again). If this function returns true, this action will continue running (<code>process</code> will be called again later unless this action is interrupted). The only way an action can finish without being interrupted is if this function returns false.</li> </ul> Header (.hpp)Source (.cpp) <pre><code>class MyAction : public Action {\nprotected:\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n};\n</code></pre> <pre><code>void MyAction::begin(){\n// Setup for action to run\n}\n\nvoid MyAction::process(){\n// Implement the action\n}\n\nvoid MyAction::finish(bool wasInterrupted){\n// Stop anything / do any cleanup\n}\n\nbool MyAction::shouldContinue(){\n// Return false when action is done\nreturn true;\n}\n</code></pre> <p>In robot programs, actions are typically created in the <code>actions</code> files (<code>actions.py</code> or <code>actions.hpp</code> and <code>actions.cpp</code>). All action classes are defined in these files. In contrast, the <code>robot</code> files (<code>robot.py</code> or <code>robot.hpp</code> and <code>robot.cpp</code>) are used only for the <code>Robot</code> class. Instances of actions are often created in the <code>Robot</code> class. For example, the following could be added to the <code>actions</code> files to create an action (this action does nothing, it's just an example).</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code>class MyAction(Action):\n    def begin(self):\n        pass\n\n    def process(self):\n        pass\n\n    def finish(self, was_interrupted: bool):\n        pass\n\n    def should_continue(self) -&gt; bool:\n        return False\n</code></pre> <pre><code>class MyAction : public Action{\nprotected:\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n};\n</code></pre> <pre><code>void MyAction::begin(){\n\n}\n\nvoid MyAction::process(){\n\n}\n\nvoid MyAction::finish(bool wasInterrupted){\n\n}\n\nbool MyAction::shouldContinue(){\nreturn false;\n}\n</code></pre> <p>Then an instance of the action is created in the robot class. This instance can be used as described in later sections.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add somewhere in __init__\nself.my_instance = MyAction()\n</code></pre> <pre><code>// Add somewhere in Robot class declaration\nMyAction myInstance;\n</code></pre> <p>Often, you will only have one instance of an action (or multiple instances that all behave the same way), but in other cases you may have multiple instances that all work differently. Consider an action that waits a certain amount of time (why this is useful will be seen later). It is likely that you would want to wait for different amounts of time (eg 3 seconds, 5 seconds, 10 seconds). Instead of making three actions that all wait for an amount of time, the you can create an action that takes an argument in its constructor for the amount of time to wait. Then, you only need three instances of the action for 3, 5, and 10 seconds.</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code># Note: Add \"import time\" at top of file\n\nclass WaitAction(Action):\n\n    # __init__ function is constructor run when creating instance\n    # Add arguments after \"self\"\n    # In this case one argument for wait time (in seconds) is added\n    def __init__(self, wait_time_sec: float):\n        # ALWAYS CALL PARENT CLASS INIT!!!\n        super().__init__()\n\n        # Store the argument's value in a member variable for use later\n        self.wait_time_sec = wait_time_sec\n\n        # Another member variable to store when the action starts\n        # Just store some value for now. This value won't be used\n        self.start_time: float = 0.0\n\n    def begin(self):\n        # Action is started when begin() runs. Store current time\n        self.start_time = time.time()\n\n    def process(self):\n        # Nothing to do. Just waiting\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Action is done. Done waiting, so nothing needs to be done here\n        pass\n\n    def should_continue(self) -&gt; bool:\n        # Should continue waiting if (now - start) &lt; wait_time\n        return (time.time() - self.start_time) &lt; self.wait_time_sec\n</code></pre> <pre><code>// Note: Import \"chrono\" at top of file\n\nclass WaitAction : public Action {\npublic:\n// Add constructor taking argument\n// Constructor is run when creating instance of action\nWaitAction(double waitTimeSec);\n\nprotected:\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\n// Member variables to store wait time and start time\ndouble waitTimeSec;\nstd::chrono::time_point&lt;std::chrono::steady_clock&gt; startTime;\n}\n</code></pre> <pre><code>// Using initializer list to assign member varible waitTimeSec to argument value\nWaitAction::WaitAction(double waitTimeSec) : waitTimeSec(waitTimeSec) {\n\n}\n\nvoid WaitAction::begin(){\n    // Action is started when begin runs. Store start time.\n    startTime = std::chrono::steady_clock::now();\n}\n\nvoid WaitAction::process(){\n    // Nothing to do. Just waiting.\n}\n\nvoid WaitAction::finish(bool wasInterrupted){\n    // Action is done. Done waiting, so nothing needs to be done here\n}\n\nbool WaitAction::shouldContinue(){\n    // Should continue waiting if (now - start) &lt; wait_time\n    auto now = std::chrono::steady_clock::now();\n    return std::chrono::duration_cast&lt;std::chrono::seconds&gt;(now - startTime).count() &lt; waitTimeSec;\n}\n</code></pre> <p>Then in the robot class, several instances are created as shown below</p> <p>=== \"Python (<code>robot.py</code>)     <pre><code># In __init__\nself.wait3s = WaitAction(3)\nself.wait5s = WaitAction(5)\nself.wait10s = WaitAction(10)\n</code></pre></p> C++ (<code>robot.hpp</code>) <pre><code>// In class declaration\nWaitAction wait3s {3};\nWaitAction wait5s {5};\nWaitAction wait10s {10};\n</code></pre> <p>This method allows the same code to be used for waiting regardless of how long the robot is waiting for.</p>"},{"location":"guide/programming/actions/#using-actions_1","title":"Using Actions","text":"<p>The <code>ActionManager</code> provides two functions <code>start_action</code> / <code>startAction</code> and <code>stop_action</code> / <code>stopAction</code> to start and stop actions respectively. These functions can be used in your robot program when needed to manage actions. For instance, you could start an action in <code>robot_enabled</code> / <code>robotEnabled</code> and stop it in <code>robot_disabled</code> / <code>robotDisabled</code>.</p> PythonC++ <pre><code># Add with imports if not there\nfrom arpirobot.core.action import ActionManager\n\n# Use these where needed\nActionManager.start_action(self.my_instance)\nActionManager.stop_action(self.my_instance)\n</code></pre> <pre><code>// Add with includes if not there\n#include &lt;arpirobot/core/action/ActionManager.hpp&gt;\n\nActionManager::startAction(myInstance);\nActionManager::stopAction(myInstance);\n</code></pre> <p>You can also start an action without holding a reference to the instance, but you will not be able to stop it using the <code>stop_action</code> / <code>stopAction</code> function. This is often useful in <code>robot_started</code> / <code>robotStarted</code> for actions that should always remain running.</p> PythonC++ <pre><code># This is ok because the action manager will keep the action object in scope even if your code does not\nActionManager.start_action(MyAction())\n</code></pre> <pre><code>// When passing dynamically allocated objects the C++ library uses shared_ptrs\n// As such it is necessary to use std::make_shared\n// Statically allocated objects are intended to be passed by reference (as shown previously)\n// Since shared_ptrs are used there is no need to handle deletion of the dynamically allocated action\n// The action manager holds a reference to it while it is running.\nActionManager::startAction(std::make_shared&lt;MyAction&gt;());\n</code></pre> <p>Often, it is useful to be able to determine if an action is already running. before attempting to start / stop it. This can be done using the action's <code>is_running</code> / <code>isRunning</code> function.</p> PythonC++ <pre><code>running = self.my_instance.is_running()\n</code></pre> <pre><code>bool running = myInstance.isRunning();\n</code></pre> <p>This can be used to prevent restarting an action that is already running. By default if you attempt to start an action that is already running it will be restarted. This means that it will be stopped and started again. This behavior can be disabled by using the second (optional) argument of <code>start_action</code> / <code>startAction</code>. If this argument is false, the action will not be restarted if running. It will continue running, but a warning will be added to the robot program log.</p> PythonC++ <pre><code>ActionManager.start_action(self.my_instance, False)\n</code></pre> <pre><code>ActionManger::startAction(myInstance, false);\n</code></pre> <p>Note that the <code>start_action</code> / <code>startAction</code> function also returns a bool indicating if an action was started successfully. This will only return false if the action is already running and is not allowed to be restarted (or if you attempt to start an action before the robot has started which should never happen).</p> <p></p> <p>Using the <code>ActionManager</code> functions is an easy way to manually start and stop actions, however there is also a way to start actions when some even occurs. The <code>ActionManager</code> can have triggers that start a specified action when something occurs. What that event is depends on the type of trigger. The most common trigger is a gamepad related trigger. There are two such triggers <code>ButtonPressedTrigger</code> and <code>ButtonReleasedTrigger</code>. These triggers are used to start an action when a button on the gamepad is pressed or released respectively. Once a trigger is added to the action manager, the action associated with it will be started (or restarted) whenever the event occurs. This will remain the case until the trigger is removed from the <code>ActionManager</code>.</p> PythonC++ <pre><code># Starts action instance my_instance when button 0 on gp0 is pressed\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, 0, self.my_instance))\n\n# If you need to remove later use ActionManager.remove_trigger, but hold an instance of the trigger\nself.trigger = ButtonPressedTrigger(self.gp0, 0, self.my_instance)\nActionManager.add_trigger(self.trigger)\n\n# And later\nActionManager.remove_trigger(self.trigger)\n</code></pre> <pre><code>// Starts action instance myInstance when button 0 on gp0 is pressed\nActionManager::addTrigger(std::make_shared&lt;ButtonPressedTrigger&gt;(gp0, 0, myInstance));\n\n// If you need to remove later use ActionManager::removeTrigger, but hold an instance of the trigger\n// Add \"trigger\" variable as a member in class declaration\nButtonPressedTrigger trigger {gp0, 0, myInstance};\n\n// Then in a function somewhere\nActionManager::addTrigger(trigger);\n\n// And later\nActionManager::removeTrigger(trigger);\n</code></pre> <p>As with <code>start_action</code> / <code>startAction</code>, an trigger will restart an action by default. If this behavior is not desired use the optional argument after the action instance.</p> PythonC++ <pre><code>self.trigger = ButtonPressedTrigger(self.gp0, 0, self.my_instance, False)\n</code></pre> <pre><code>ButtonPressedTrigger trigger {hp0, 0, myInstance, false};\n</code></pre>"},{"location":"guide/programming/actions/#running-actions-sequentially","title":"Running Actions Sequentially","text":"<p>Any actions started will run concurrently, meaning that starting a second action will not wait for the currently running action to finish. While this parallel execution of actions is useful for developing complex routines and maximizing code sharing, it is equally useful to be able to run a set of actions sequentially (one after the other).</p> <p>This is achieved using an <code>ActionSeries</code>. An <code>ActionSeries</code> is itself an action that can be started and stopped with the action manager, however it's task is to manage other actions. When creating an <code>ActionSeries</code> a list of actions is used. This list of actions is run sequentially. The first action is started. When it finishes, the second, then when it finishes the third and so on. The <code>ActionSeries</code> (being an <code>Action</code> itself) remains running until all of its actions finish (or until it is interrupted).</p> PythonC++ <pre><code>self.series = ActionSeries(\n    # List of actions to be run as a part of the series\n    [\n        action1,\n        action2,\n        action3,\n        ...\n        action_n\n    ], \n\n    # finished_action\n    # An action to start when the action series is done\n    # This action is not part of the action series so the action series\n    # will not continue running while this action is running\n    None\n)\n</code></pre> <pre><code>ActionSeries series{\n// List of actions to be run as a part of the series\n{\naction1,\naction2,\naction3,\n...\nactionN\n},\n\n// finishedAction\n// An action to start when the action series is done\n// This action is not part of the action series so the action series\n// will not continue running while this action is running\nnullptr\n};\n</code></pre> <p>There is also an optional \"finished action\" that can be automatically started when the action series finishes. This is often useful to avoid having actions that run \"forever\" be a part of the action series so you can determine when an action series completes its primary task. Consider the following example. The action series is used to drive a square. By making the human drive action the \"finished action\" this ensures that when the square driving is done, human control will resume. However, once human control resumes the \"drive square\" action is no longer running, which makes sense as the square has been driven.</p> PythonC++ <pre><code>self.drive_square_series = ActionSeries(\n    # List of actions to be run as a part of the series\n    [\n        DriveDistanceAction(10),\n        RotateAngleAction(90),\n        DriveDistanceAction(10),\n        RotateAngleAction(90),\n        DriveDistanceAction(10),\n        RotateAngleAction(90),\n        DriveDistanceAction(10),\n        RotateAngleAction(90)\n    ], \n\n    # finished_action\n    # An action to start when the action series is done\n    # This action is not part of the action series so the action series\n    # will not continue running while this action is running\n    HumanDriveAction()\n)\n</code></pre> <pre><code>ActionSeries driveSquareSeries{\n// List of actions to be run as a part of the series\n{\nstd::make_shared&lt;DriveDistanceAction&gt;(10),\nstd::make_shared&lt;RotateAngleAction&gt;(90),\nstd::make_shared&lt;DriveDistanceAction&gt;(10),\nstd::make_shared&lt;RotateAngleAction&gt;(90),\nstd::make_shared&lt;DriveDistanceAction&gt;(10),\nstd::make_shared&lt;RotateAngleAction&gt;(90),\nstd::make_shared&lt;DriveDistanceAction&gt;(10),\nstd::make_shared&lt;RotateAngleAction&gt;(90)\n},\n\n// finishedAction\n// An action to start when the action series is done\n// This action is not part of the action series so the action series\n// will not continue running while this action is running\nstd::make_shared&lt;HumanDriveAction&gt;()\n};\n</code></pre> <p>Since <code>ActionSeries</code> are actions, multiple can run in parallel too. This allows for complex routines to be developed using the action system.</p>"},{"location":"guide/programming/actions/#ownership-of-devices","title":"Ownership of Devices","text":"<p>One final important concept with actions is the ownership of devices. Devices are many of the \"objects\" created on the robot. More specifically, a \"Device\" is anything connected directly to the Raspberry Pi on the robot that has its own object in code (such as motors). Note that currently, devices attached to the arduino (such as sensors) are \"ArduinoDevices\" and are not able to be owned by actions.</p> <p>Often, multiple actions in a robot program control the same device. In many cases, this can cause unintended behaviors. Consider a scenario where one action allows a gamepad to move motors, and another uses motors to drive a square. Which action would \"win\"? It is likely the actions would \"fight\" each other causing the robot to rapidly switch between the tasks (rapidly meaning 20+ times per second).</p> <p>This clearly would prevent either action from working as intended. The solution is to ensure that only one action that controls the motors is ever active at a time. In general, the action that should remain active is the newer one. For example, if the robot is being driven with the gamepad using one action, and another action to drive a square is triggered by a button press, the square should be driven stopping gamepad drive control.</p> <p>To achieve this, it is necessary to know what devices an action uses (or equivalently which action is currently controlling a device). The action controlling a device is said to \"own\" or \"lock\" a device. If a newer action is started, it can take ownership of the device. When this happens, the previous action is automatically stopped.</p> <p>An <code>Action</code> can optionally have a function called <code>lockedDevices</code> / <code>locked_devices</code>. This function returns a list of devices that should be locked when the action starts (<code>LockedDeviceList</code>). When an action with this function is started, any devices in the list returned from <code>lockedDevices</code> / <code>locked_devices</code> are locked by the action. If another action is running that had previously locked any device now locked by the new action, the old action will be stopped to allow the newer action to take control.</p> <p>Additionally, if you have code in <code>enabled_periodic</code> / <code>enabledPeriodic</code> or <code>disabled_periodic</code> / <code>disabledPeriodic</code> that controls a device, you will need to be careful not to control it while an action has locked the device. The device has a function called <code>is_locked</code> / <code>isLocked</code> which can be used to determine if the device is locked by an action. Unlike actions, the periodic functions cannot lock a device. As such, it is highly recommended to either control a device using actions or the periodic functions, not both. However, it is not a problem to control some devices using actions and others from the <code>Robot</code>'s periodic functions.</p>"},{"location":"guide/programming/actions/#making-drive-code-into-an-action","title":"Making Drive Code into an Action","text":"<p>Before attempting to create complex setups with actions, it is a good idea to convert the gamepad drive code into an action. Later, actions will be implemented that are used to drive shapes. Since these actions will control the motors, it is a bad idea to also have <code>enabled_periodic</code> / <code>enabledPeriodic</code> controlling the motors with the gamepad.</p> <p>To start, create a new action in <code>actions.py</code> or <code>actions.hpp</code> and <code>actions.cpp</code></p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code>class JSDriveAction(Action):\n    def locked_devices(self) -&gt; LockedDeviceList:\n        pass\n\n    def begin(self):\n        pass\n\n    def process(self):\n        pass\n\n    def finish(self, was_interrupted: bool):\n        pass\n\n    def should_continue(self) -&gt; bool:\n        pass\n</code></pre> <pre><code>class JSDriveAction : public Action{\nprotected:\nLockedDeviceList lockedDevices() override;\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n};\n</code></pre> <pre><code>LockedDeviceList JSDriveAction::lockedDevices(){\n\n}\n\nvoid JSDriveAction::begin(){\n\n}\n\nvoid JSDriveAction::process(){\n\n}\n\nvoid JSDriveAction::finish(bool wasInterrupted){\n\n}\n\nbool JSDriveAction::shouldContinue(){\n\n}\n</code></pre> <p>Then, in <code>process</code> move the existing drive code from <code>enabled_periodic</code> / <code>enabledPeriodic</code>. You will have to change a few variable names. The drive helper object and gamepad object belong to the <code>Robot</code> instance, not the <code>Action</code> instance the code is now in. As such, you have to refer to them using the <code>Robot</code> instance. This is done using <code>main.robot</code> in python or <code>Main::robot</code> in C++.</p> Python (<code>actions.py</code>)C++ (<code>actions.cpp</code>) <pre><code>def process(self):\n    # Get value for the speed axis\n    speed = main.robot.gp0.get_axis(main.robot.SPEED_AXIS, main.robot.DEADBAND)\n\n    # Get value for the rotation axis\n    rotation = main.robot.gp0.get_axis(main.robot.ROTATE_AXIS, main.robot.DEADBAND)\n\n    # Update speed of all motors using drive helper\n    main.robot.drive_helper.update(speed, rotation)\n</code></pre> <pre><code>void JSDriveAction::process(){\n// Get value for speed axis\ndouble speed = Main::robot-&gt;gp0.getAxis(Main::robot-&gt;SPEED_AXIS, Main::robot-&gt;DEADBAND);\n\n// Get value for the rotation axis\ndouble rotation = Main::robot-&gt;gp0.getAxis(Main::robot-&gt;ROTATE_AXIS, Main::robot-&gt;DEADBAND);\n\n// Update speed of all motors using drive helper\nMain::robot-&gt;driveHelper.update(speed, rotation);\n}\n</code></pre> <p>Then, in <code>locked_devices</code> / <code>lockedDevices</code>, add the following to lock the motors. All four motors are locked as this action (indirectly) controls all four using the drive helper. Note: You cannot lock the drive helper. It is not a device. Locking the motors is not important yet, but having this will be important later.</p> Python (<code>actions.py</code>)C++ (<code>actions.cpp</code>) <pre><code>def locked_devices(self) -&gt; LockedDeviceList:\n    # If your robot only has two motors, only reference those motors\n    return [ main.robot.flmotor, main.robot.frmotor, \n            main.robot.rlmotor, main.robot.rrmotor ]\n</code></pre> <pre><code>LockedDeviceList JSDriveAction::lockedDevices(){\n// If your robot only has two motors, only reference those motors\nreturn { Main::robot-&gt;flmotor, Main::robot-&gt;frmotor, Main::robot-&gt;rlmotor, Main::robot-&gt;rrmotor };\n}\n</code></pre> <p>Next, in the action's <code>finish</code> function add the following line to ensure that motors stop moving if the action is ever stopped. When an action is stopped it should (almost) always make sure anything it was controlling is returned to a safe state. For motors, stopped is a safe state.</p> Python (<code>actions.py</code>)C++ (<code>actions.cpp</code>) <pre><code>def finish(self, was_interrupted: bool):\n    main.robot.drive_helper.update(0, 0)\n</code></pre> <pre><code>void JSDriveAction::finish(){\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n</code></pre> <p>Then, make <code>should_continue</code> / <code>shouldContinue</code> always return true so this action runs forever.</p> Python (<code>actions.py</code>)C++ (<code>actions.cpp</code>) <pre><code>def should_continue(self) -&gt; bool:\n    return True\n</code></pre> <pre><code>bool shouldContinue(){\nreturn true;\n}\n</code></pre> <p>Finally, start the action in <code>robot_started</code> / <code>robotStarted</code>. Since the action never finishes, it will run forever. The action actually remains running whether the robot is enabled or disabled, however the robot's motors are disabled when the robot is disabled so you will still be unable to drive the robot while it is disabled.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Import action at top of file (with other imports)\nfrom actions import JSDriveAction\n\n# Add at the end of robot_started\nActionManager.start_action(JSDriveAction())\n</code></pre> <pre><code>// No need to include anything for C++\n// actions.hpp should already be included\n\n// Add at the end of robotStarted\nActionManager::startAction(std::make_shared&lt;JSDriveAction&gt;());\n</code></pre> <p>After building and deploying this program to the robot, driving with the gamepad will still work as it previously had, but since it is now implemented as an action it is easy to start and stop as needed to allow other actions to run.</p>"},{"location":"guide/programming/actions/#automated-routines-using-actions","title":"Automated Routines using Actions","text":"<p>Actions can be used as building blocks for complex tasks. In this section two tasks will be implemented using actions. The first task will drive a circle. The second will drive a square. When neither task is active, the robot will be able to be controlled using the gamepad (using the <code>JSDriveAction</code> implemented previously).</p> <p>While it would be possible to make an action to drive each shape, this is not the easiest way to do so and does not allow much code reuse. Instead, driving shapes is broken down into simpler actions that can be chained together to make shapes. This also allows the same actions to be used to drive multiple different shapes.</p> <p>Driving both a square and a triangle can be accomplished using two basic actions. First, the robot needs to be able to drive a straight line. Second, it needs to be able to rotate. These two actions can be repeated as many times as necessary to drive the desired shape.</p> <p>Ideally, driving a straight line would be done using encoders on the robot to drive some specific distance and rotation would use a gyroscope to rotate to some angle, however for the sake of simplicity, time will be used instead in this section. This means that instead of an action that drives some number of inches we will have an action that drives for some amount of time. For rotation, it will rotate for some amount of time. Timed driving is not a precise way to create shapes. You may need to change some times (especially for the rotations) to drive the correct shape. The code in this section will behave differently on different robots.</p>"},{"location":"guide/programming/actions/#drive-time-action","title":"Drive Time Action","text":"<p>The first action to be implemented needs to drive a straight line for some amount of time (this will be passed as an argument in the constructor so the same action can be used for different amounts of time). This action will control motors, so they should be locked in <code>begin</code>. Additionally, the robot will drive a constant speed for the given amount of time. As such, the robot can start driving in <code>begin</code> and stop in <code>finish</code> leaving <code>process</code> empty. Finally, <code>should_continue</code> / <code>shouldContinue</code> needs to return true until enough time has passed, when it should return false stopping the action. This requires tracking when the action is started by storing some value in <code>begin</code>. This is all implemented in the code shown below.</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code># Add this import at the top of the file (with other imports)\nimport time\n\nclass DriveTimeAction(Action):\n    # Each instance of the action can drive for a different duration\n    # This allows reusing the same action for various purposes\n    def __init__(self, duration_sec: float):\n        super().__init__()\n\n        # Store the duration this action should run for\n        self.duration_sec = duration_sec / 1000\n\n        # Will be used to store the time when the action starts (begin called)\n        self.start_time = 0.0\n\n    def locked_devices(self) -&gt; LockedDeviceList:\n        # Lock motors as this action controls them\n        # This stops whatever action currently controls the motors (if any)\n        return [ main.robot.flmotor, main.robot.frmotor, \n            main.robot.rlmotor, main.robot.rrmotor ]\n\n    def begin(self):\n        # Store the time this action started\n        self.start_time = time.time()\n\n        # Start moving the motors forward at 70% speed, no rotation\n        main.robot.drive_helper.update(0.7, 0)\n\n    def process(self):\n        # Nothing to do here. Just let motors keep running\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Stop the motors\n        main.robot.drive_helper.update(0, 0)\n\n    def should_continue(self) -&gt; bool:\n        now = time.time()\n        if (now - self.start_time) &gt;= self.duration_sec:\n            return False\n        return True\n</code></pre> <pre><code>// Add with other imports\n#include &lt;chrono&gt;\n\nclass DriveTimeAction : public Action {\npublic:\n// Each instance of the action can drive for a different duration\n// This allows reusing the same action for various purposes\nDriveTimeAction(double durationSec);\n\nprotected:\nLockedDeviceList lockedDevices() override;\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\n// Store the duration this action should run for\ndouble durationSec;\n\n// Will be used to store the time when the action starts (begin called)\nstd::chrono::time_point&lt;std::chrono::steady_clock&gt; startTime;\n};\n</code></pre> <pre><code>DriveTimeAction::DriveTimeAction(double durationSec) : durationSec(durationSec){\n\n}\n\nLockedDeviceList DriveTimeAction::lockedDevices(){\n// Lock motors as this action controls them\n// This stops whatever action currently controls the motors (if any)\nreturn { Main::robot-&gt;flmotor, Main::robot-&gt;frmotor, Main::robot-&gt;rlmotor, Main::robot-&gt;rrmotor };\n}\n\nvoid DriveTimeAction::begin(){        // Store the time this action started \nstartTime = std::chrono::steady_clock::now();\n\n// Start moving the motors forward at 70% speed, no rotation\nMain::robot-&gt;driveHelper.update(0.7, 0);\n}\n\nvoid DriveTimeAction::process(){\n// Nothing to do here. Just let motors keep running\n}\n\nvoid DriveTimeAction::finish(bool wasInterrupted){\n// Stop the motors\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n\nbool DriveTimeAction::shouldContinue(){\ndouble elapsedSec = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(now - startTime).count();\nif(elapsedSec &gt;= durationSec)\nreturn false;\nreturn true;\n}\n</code></pre>"},{"location":"guide/programming/actions/#rotate-time-action","title":"Rotate Time Action","text":"<p>The rotate time action is implemented almost the same way as the drive time action. Instead of driving forward at 70% speed though, the action rotates at 90% speed.</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code># Add this import at the top of the file (with other imports)\nimport time\n\nclass RotateTimeAction(Action):\n    # Each instance of the action can drive for a different duration\n    # This allows reusing the same action for various purposes\n    def __init__(self, duration_sec: float):\n        super().__init__()\n\n        # Store the duration this action should run for\n        self.duration_sec = duration_sec / 1000\n\n        # Will be used to store the time when the action starts (begin called)\n        self.start_time = 0.0\n\n    def locked_devices(self) -&gt; LockedDeviceList:\n        # Lock motors as this action controls them\n        # This stops whatever action currently controls the motors (if any)\n        return [ main.robot.flmotor, main.robot.frmotor, \n            main.robot.rlmotor, main.robot.rrmotor ]\n\n    def begin(self):            \n        # Store the time this action started\n        self.start_time = time.time()\n\n        # Start moving the motors at 90% rotation (no forward / reverse speed)\n        main.robot.drive_helper.update(0, 0.9)\n\n    def process(self):\n        # Nothing to do here. Just let motors keep running\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Stop the motors\n        main.robot.drive_helper.update(0, 0)\n\n    def should_continue(self) -&gt; bool:\n        now = time.time()\n        if (now - self.start_time) &gt;= self.duration_sec:\n            return False\n        return True\n</code></pre> <pre><code>// Add with other imports\n#include &lt;chrono&gt;\n\nclass RotateTimeAction : public Action {\npublic:\n// Each instance of the action can drive for a different duration\n// This allows reusing the same action for various purposes\nRotateTimeAction(double durationSec);\n\nprotected:\nLockedDeviceList lockedDevices() override;\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\n// Store the duration this action should run for\ndouble durationSec;\n\n// Will be used to store the time when the action starts (begin called)\nstd::chrono::time_point&lt;std::chrono::steady_clock&gt; startTime;\n};\n</code></pre> <pre><code>RotateTimeAction::RotateTimeAction(double durationSec) : durationSec(durationSec){\n\n}\n\nLockedDeviceList RotateTimeAction::lockedDevices(){\n// Lock motors as this action controls them\n// This stops whatever action currently controls the motors (if any)\nreturn { Main::robot-&gt;flmotor, Main::robot-&gt;frmotor, Main::robot-&gt;rlmotor, Main::robot-&gt;rrmotor };\n}\n\nvoid RotateTimeAction::begin(){        // Store the time this action started \nstartTime = std::chrono::steady_clock::now();\n\n// Start moving the motors at 90% rotation (no forward / reverse speed)\nMain::robot-&gt;driveHelper.update(0, 0.9);\n}\n\nvoid RotateTimeAction::process(){\n// Nothing to do here. Just let motors keep running\n}\n\nvoid RotateTimeAction::finish(bool wasInterrupted){\n// Stop the motors\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n\nbool RotateTimeAction::shouldContinue(){\ndouble elapsedSec = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(now - startTime).count();\nif(elapsedSec &gt;= durationSec)\nreturn false;\nreturn true;\n}\n</code></pre>"},{"location":"guide/programming/actions/#brake-mode","title":"Brake Mode","text":"<p>Generally, coast mode is better when driving the robot with a gamepad. It results in more natural control of the robot and prevents sudden stops when changing directions. However, when performing automated driving, it is often better to use brake mode. This ensures the robot stops quicker when the action is finished driving and makes driving more consistent.</p> <p>As such, the motors should be in brake mode for the drive time and rotate time actions, but in coast mode for the joystick drive action. This can be achieved by setting the motors to brake / coast mode as needed in an action's <code>begin</code> function.</p> <p>Add the following lines to the end of each action's <code>begin</code> function as indicated. For robots with fewer motors, only set the brake mode for the motors the robot has (and change motor object names as needed).</p> Python (<code>actions.py</code>)C++ (<code>actions.cpp</code>) <pre><code># Add to DriveTimeAction's begin\nmain.robot.flmotor.set_brake_mode(True)\nmain.robot.frmotor.set_brake_mode(True)\nmain.robot.rlmotor.set_brake_mode(True)\nmain.robot.rrmotor.set_brake_mode(True)\n\n# Add to RotateTimeAction's begin\nmain.robot.flmotor.set_brake_mode(True)\nmain.robot.frmotor.set_brake_mode(True)\nmain.robot.rlmotor.set_brake_mode(True)\nmain.robot.rrmotor.set_brake_mode(True)\n\n# Add to JSDriveAction's begin\nmain.robot.flmotor.set_brake_mode(False)\nmain.robot.frmotor.set_brake_mode(False)\nmain.robot.rlmotor.set_brake_mode(False)\nmain.robot.rrmotor.set_brake_mode(False)\n</code></pre> <pre><code>// Add to DriveTimeAction's begin\nMain::robot-&gt;flmotor.setBrakeMode(true);\nMain::robot-&gt;frmotor.setBrakeMode(true);\nMain::robot-&gt;rlmotor.setBrakeMode(true);\nMain::robot-&gt;rrmotor.setBrakeMode(true);\n\n// Add to RotateTimeAction's begin\nMain::robot-&gt;flmotor.setBrakeMode(true);\nMain::robot-&gt;frmotor.setBrakeMode(true);\nMain::robot-&gt;rlmotor.setBrakeMode(true);\nMain::robot-&gt;rrmotor.setBrakeMode(true);\n\n// Add to JSDriveAction's begin\nMain::robot-&gt;flmotor.setBrakeMode(false);\nMain::robot-&gt;frmotor.setBrakeMode(false);\nMain::robot-&gt;rlmotor.setBrakeMode(false);\nMain::robot-&gt;rrmotor.setBrakeMode(false);\n</code></pre>"},{"location":"guide/programming/actions/#using-the-actions","title":"Using the Actions","text":"<p>The <code>DriveTimeAction</code>, <code>RotateTimeAction</code> and <code>WaitAction</code> (shown earlier) can be used to create <code>ActionSeries</code> to drive a square and triangle. These action series will look something like the following, however you will likely need to change the drive and rotate times to suit your specific robot and the surface you are driving on.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code># Add with other imports\nfrom actions import DriveTimeAction, RotateTimeAction, JSDriveAction, WaitAction\n\n################################################################################\n# Add in __init__\n################################################################################\n\n# Constants for button mappings on gamepad\nself.SQUARE_BTN = 0\nself.TRIANGLE_BTN = 1\n\n# Action and ActionSeries instances\nself.js_drive_action = JSDriveAction()\nself.drive_square_series = ActionSeries(\n    # This is a list of actions to run sequentially\n    [\n        DriveTimeAction(2),         # First edge\n        RotateTimeAction(3.5),      # Rotate 90 (adjust time as needed)\n\n        WaitAction(0.5),            # Delay before driving next edge\n\n        DriveTimeAction(2),         # Second edge\n        RotateTimeAction(3.5),      # Rotate 90 (adjust time as needed)\n\n        WaitAction(0.5),            # Delay before driving next edge\n\n        DriveTimeAction(2),         # Third edge\n        RotateTimeAction(3.5),      # Rotate 90 (adjust time as needed)\n\n        WaitAction(0.5),            # Delay before driving next edge\n\n        DriveTimeAction(2),         # Fourth edge\n        RotateTimeAction(3.5),      # Rotate 90 (adjust time as needed)\n\n        WaitAction(0.1)             # Small delay so brake mode has time to work\n\n    ],\n\n    # Start JSDriveAction instance when this action series finishes\n    self.js_drive_action\n)\nself.drive_triangle_series = ActionSeries(\n    # This is a list of actions to run sequentially\n    [\n        DriveTimeAction(2),         # First edge\n        RotateTimeAction(4.5),      # Rotate 120 (adjust time as needed)\n\n        WaitAction(0.5),            # Delay before driving next edge\n\n        DriveTimeAction(2),         # Second edge\n        RotateTimeAction(4.5),      # Rotate 120 (adjust time as needed)\n\n        WaitAction(0.5),            # Delay before driving next edge\n\n        DriveTimeAction(2),         # Third edge\n        RotateTimeAction(4.5),      # Rotate 120 (adjust time as needed)\n\n        WaitAction(0.1)             # Small delay so brake mode has time to work\n    ],\n\n    # Start JSDriveAction instance when this action series finishes\n    self.js_drive_action\n)\n\n\n################################################################################\n# In robot_started\n################################################################################\n\n# Remove this line\nActionManager.start_action(JSDriveAction())\n\n# And replace it with\nActionManager.start_action(self.js_drive_action())\n\n# Finally, add two button triggers to run the drive shape actions\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, self.SQUARE_BTN, self.drive_square_series))\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, self.TRIANGLE_BTN, self.drive_triangle_series))\n</code></pre> <pre><code>////////////////////////////////////////////////////////////////////////////////\n// Add with other member variables at the bottom of the Robot class declaration\n////////////////////////////////////////////////////////////////////////////////\n\n// Constants for button mappings on gamepad\nconst int SQUARE_BUTTON = 0;\nconst int TRIANGLE_BUTTON = 1;\n\n// Action and ActionSeries instances\nJSDriveAction jsDriveAction;\nActionSeries driveSquareSeries{\n// This is a list of actions to run sequentially\n{\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // First edge\nstd::make_shared&lt;RotateTimeAction&gt;(3.5),      // Rotate 90 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),            // Delay before driving next edge\n\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // Second edge\nstd::make_shared&lt;RotateTimeAction&gt;(3.5),      // Rotate 90 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),            // Delay before driving next edge\n\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // Third edge\nstd::make_shared&lt;RotateTimeAction&gt;(3.5),      // Rotate 90 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),            // Delay before driving next edge\n\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // Fourth edge\nstd::make_shared&lt;RotateTimeAction&gt;(3.5),      // Rotate 90 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.1)             // Small delay so brake mode has time to work\n\n},\n\n// Start JSDriveAction instance when this action series finishes\njsDriveAction\n};\nActionSeries driveTriangleSeries {\n// This is a list of actions to run sequentially\n{\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // First edge\nstd::make_shared&lt;RotateTimeAction&gt;(4.5),      // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),            // Delay before driving next edge\n\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // Second edge\nstd::make_shared&lt;RotateTimeAction&gt;(4.5),      // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),            // Delay before driving next edge\n\nstd::make_shared&lt;DriveTimeAction&gt;(2),         // Third edge\nstd::make_shared&lt;RotateTimeAction&gt;(4.5),      // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.1)             // Small delay so brake mode has time to work\n},\n\n// Start JSDriveAction instance when this action series finishes\njsDriveAction\n};\n</code></pre> <pre><code>////////////////////////////////////////////////////////////////////////////////\n// In robotStarted\n////////////////////////////////////////////////////////////////////////////////\n\n// Remove this line\nActionManager::startAction(std::make_shared&lt;JSDriveAction&gt;());\n\n// And replace it with\nActionManager::startAction(jsDriveAction);\n\n// Finally, add two button triggers to run the drive shape actions\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, self.SQUARE_BTN, self.drive_square_series))\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, self.TRIANGLE_BTN, self.drive_triangle_series))\n</code></pre> <p>If built and deployed, the buttons 0 and 1 on the gamepad (see drive station to identify which button is which) will start the drive square series or drive triangle series respectively.</p> <p>Additionally, if one series is started while the other is running the older series will be stopped by the newer one. This behavior is caused by the device locking discussed earlier. When an <code>ActionSeries</code> starts, it locks all devices that its child actions would otherwise lock. The devices are not actually locked by the child actions, only by the action series.</p> <p>In the above example, the \"drive square\" series uses an action that locks the robot's motors. The same is true of the \"drive triangle\" series. As such, if the \"drive square\" series is started the series locks the motors (since they will be used sometime while the series is running). Then, if the \"drive triangle\" series is started while the \"drive square\" series is still running, the \"drive triangle\" series will lock the motors. In doing so, it will stop whatever locked them last, which in this case was the \"drive square\" series.</p> <p>This behavior can be used to ensure that <code>ActionSeries</code> can interrupt (stop) each other to allow the newest one to run, just like individual actions.</p>"},{"location":"guide/programming/actions/#fixing-the-shapes","title":"Fixing the Shapes","text":"<p>As previously mentioned, when using time-based motions, the shapes will likely not be correct on your robot. Each robot will have different physical characteristics and different environments that will affect how long it needs to drive or rotate to make the correct shape.</p> <p>The next section of this guide re-implements the shape <code>ActionSeries</code> using sensor based actions instead, however if you do want to fix the time-based shapes the recommended approach is as follows.</p> <ol> <li>Deploy the code to your robot</li> <li>Press button 0 (which starts driving a square)</li> <li>Observe how far the robot drives before it starts to rotate. A good distance would be between 2 and 5 feet (this partially depends on how much space you have). If it seems too far, reduce the time for drive actions (arguments to constructor of <code>DriveTimeAction</code>). If it seems too short, increase the time. Remember to rebuild (if applicable) and deploy before testing new values.</li> <li>Once you have a good drive distance, it is recommended to use that time for all <code>DriveTimeActions</code> in both <code>ActionSeries</code> instances.</li> <li>Next, the rotation angle needs to be adjusted for the square. This is relatively simple. Run the action, and allow it to reach the first rotation action. Ideally, it would rotate 90 degrees. It doesn't need to be perfect, just close enough. Increase / decrease the rotation time (argument in constructor of <code>RotateTimeAction</code>) until the rotation distance is generally approximately 90 degrees. Remember to rebuild (if applicable) and deploy before testing new values.</li> <li>Use the time determined above for all rotations in the square <code>ActionSeries</code>.</li> <li>The triangle rotations will need to be approximately 120 degrees. A good starting point would be to take the time used for rotation actions, multiply it by 4, then divide by 3. Start with this time (round to two decimal places).</li> <li>Build (if applicable) and deploy the program. Test the triangle action (start running this action by pressing button 1 on the gamepad). If the rotate seems approximately correct, leave it as is. If the rotation time seems very wrong, adjust it in the direction it needs to go. The same time should generally be used for all <code>RotateTimeAction</code>s used in the triangle <code>ActionSeries</code>.</li> </ol>"},{"location":"guide/programming/createproject/","title":"Creating a Project","text":"<p>This portion of the guide will walk you through creating a robot project and running it on your robot. In addition, the basic structure of a robot program will be explained. </p>"},{"location":"guide/programming/createproject/#about-this-guide","title":"About this Guide","text":"<p>This guide is written to be fairly generic in regards to the robot build used. However, the following assumptions are made.</p> <ul> <li>Robot uses a differential drive system. This means that the robot has motorized wheels on both left and right sides of the robot and steers by varying the speeds of each side. Most robots use this style drive system.</li> <li>The Sensors &amp; Network Table section assumes the robot has an ultrasonic sensor facing forward and an IMU. Both are assumed to be connected to an Arduino coprocessor.</li> <li>The Using Sensors with Actions section assumes the robot has an IMU and 2 encoders (one on the left side and one on the right side). The encoders can be single channel or quadrature encoders.</li> <li>The PID Controller section assumes the robot has an IMU.</li> </ul> <p>Additionally, code is written as if it were to run on the 4-wheel drive clipboard (or mini clipboard) robot builds as described in Example Robot Builds. Comments are made in various places about what should be changed for other robots (generally this is just due to a different number of motors).</p> <p>Finally, some sections of this guide build on previous sections. It is generally assumed that this guide is followed in order.</p>"},{"location":"guide/programming/createproject/#creating-a-new-project","title":"Creating a New Project","text":"<p>A project is a collection of code files that makeup one robot program. A new project can be created using VSCode with the ArPiRobot extension installed. When VSCode is opened there will be an <code>ArPiRobot</code> button along the bottom toolbar.</p> <p></p> <p>After clicking this button a menu will open with an option to create an ArPiRobot project. Click this option.</p> <p></p> <p>After clicking this option you will be prompted to choose a programming language. Choose the language you plan to use.</p> <p></p> <p>Once the language has been selected enter the project name. The project name is your choice. In this case, <code>GuideProgram</code> would be a good choice. </p> <p></p> <p>Finally, choose a location to create the project. If in doubt, use your <code>Documents</code> folder.</p> <p></p> <p>Each project has its own folder which will be created in the location selected. The folder name is the same as the project name. For example, if your project is named <code>GuideProgram</code> and the parent directory is <code>Documents</code> the project will be <code>Documents/GuideProgram</code>.</p> <p></p> <p>Once the project has been created it will be opened in VSCode. If you want to open the same project later open VSCode and use the <code>File &gt; Open Folder</code> option (or just <code>File &gt; Open...</code> on macOS) to open the project's folder. The project will be created with several files, described below.</p> <p>If you generated a C++ project you will be prompted to \"configure\" the project when you open it. Click yes to configure the project. If prompted to select a kit choose \"Raspberry Pi Toolchain\"</p> Python Project FilesC++ Project Files <p>A Python project is generated with several source (<code>.py</code>) files in a folder named <code>src</code>. The other files generated are either used on the robot to start the program or used by the deploy tool to deploy the project.</p> <p></p> <p>A C++ project is generated with several source (<code>.cpp</code>) files in a folder named <code>src</code> and headers (<code>.hpp</code>) in a folder named <code>include</code>. The other files generated are used on the robot to start the program, used by the deploy tool to deploy the project, or are part of the build system.</p> <p></p>"},{"location":"guide/programming/createproject/#deploying-to-robot","title":"Deploying to Robot","text":"<p>The project is created with a minimal amount of code to make it a valid robot program. As such, it can be deployed to the robot immediately to verify it runs and to learn how to deploy code.</p> <p>Before deploying a project it is sometimes necessary to \"build\" the project. In simple terms \"building\" means taking the source code and translating it into a form that can be run. What exactly this process entails, and whether it is necessary, depends on the programming language.</p> PythonC++ <p>Python projects do not need to be \"built\". The source code is deployed directly.</p> <p>C++ projects must be built before they can be deployed. Before building, select the Raspberry Pi Toolchain \"kit\" for CMake in VSCode. If you do not see this option, the project is not \"configured\". Press <code>Ctrl+Shift+P</code> (<code>Cmd+Shift+P</code> on macOS) and type \"CMake: Configure\" and run that command. The pictured options should then be on the bottom toolbar.</p> <p></p> <p>Then click the build button to build the project.</p> <p></p> <p>A window will open with build output. It should build with no errors.</p> <p></p> <p>After building, deploying to the robot is done using the Deploy Tool. First, connect your computer to the robot's WiFi network (the robot will of course need to be powered on). After this is done open the Deploy Tool and click the \"Connect\" button.</p> <p></p> <p>Next select the Robot Program tab. In this tab click the three dots button and choose the folder for the project. Finally, click the deploy button. The Deploy Tool will then perform several tasks to deploy the program. No errors should be reported.</p> <p></p> <p>Once the program has been deployed select the \"Robot Program Log\" tab. You should see some output similar to the following. The \"robot started line\" indicates that the robot program has started successfully.</p> <p></p>"},{"location":"guide/programming/createproject/#the-robot-program","title":"The Robot Program","text":"<p>The core of the robot program lies either in the <code>robot.py</code> or <code>robot.cpp</code> (and <code>robot.hpp</code>) file(s). This file implements a class called <code>Robot</code> that inherits from (is based on) <code>BaseRobot</code>. <code>BaseRobot</code> is part of the CoreLib and handles starting and managing the robot program. The <code>Robot</code> class based on it is capable of modifying certain behaviors by implementing some functions. If you look in <code>robot.py</code> or <code>robot.hpp</code> several functions are defined with comments explaining their use. These functions are listed below</p> PythonC++ <ul> <li><code>robot_started</code>: This function runs one time when the robot program starts running. This function is used to configure things that only need to happen once at the start of the robot program.</li> <li><code>robot_enabled</code>: There are two states the robot can be in. When enabled, motors and other devices that could be considered \"potentially harmful\" are allowed to function. This function is run each time the robot becomes enabled (switches from disabled to enabled). This function is used to \"prepare\" for the enabled state.</li> <li><code>robot_disabled</code>: This function is run when the robot becomes disabled. When disabled \"potentially harmful\" devices (such as motors) are disabled automatically. The robot automatically becomes disabled if the Drive Station becomes disconnected (or under some other scenarios). This function is often used to stop anything that should not happen while the robot is disabled. Note that stopping motors manually is not necessary as they are automatically stopped when the robot becomes disabled.</li> <li><code>periodic</code>: This function runs over and over while the robot program is running. By default this function runs once every 50ms. This function runs if the robot is enabled or if it is disabled. It is used to do things that should happen repeatedly always.</li> <li><code>enabled_periodic</code>: This function runs over and over, similar to <code>periodic</code>, but only if the robot is enabled. This function is often used to implement the control of the robot.</li> <li><code>disabled_periodic</code>: This function runs over and over, similar to <code>periodic</code>, but only if the robot is disabled.</li> </ul> <ul> <li><code>robotStarted</code>: This function runs one time when the robot program starts running. This function is used to configure things that only need to happen once at the start of the robot program.</li> <li><code>robotEnabled</code>: There are two states the robot can be in. When enabled, motors and other devices that could be considered \"potentially harmful\" are allowed to function. This function is run each time the robot becomes enabled (switches from disabled to enabled). This function is used to \"prepare\" for the enabled state.</li> <li><code>robotDisabled</code>: This function is run when the robot becomes disabled. When disabled \"potentially harmful\" devices (such as motors) are disabled automatically. The robot automatically becomes disabled if the Drive Station becomes disconnected (or under some other scenarios). This function is often used to stop anything that should not happen while the robot is disabled. Note that stopping motors manually is not necessary as they are automatically stopped when the robot becomes disabled.</li> <li><code>periodic</code>: This function runs over and over while the robot program is running. By default this function runs once every 50ms. This function runs if the robot is enabled or if it is disabled. It is used to do things that should happen repeatedly always.</li> <li><code>enabledPeriodic</code>: This function runs over and over, similar to <code>periodic</code>, but only if the robot is enabled. This function is often used to implement the control of the robot.</li> <li><code>disabledPeriodic</code>: This function runs over and over, similar to <code>periodic</code>, but only if the robot is disabled.</li> </ul> <p>By putting code in these functions, a robot program can be made to perform a wide variety of tasks. For now, to get a better feel for when these functions run, the following modifications can be made to the program to add some custom log messages. When the function containing a log message is run, the message is printed to the log. The added lines are indicated in the code below.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.log import Logger\nfrom arpirobot.core.action import ActionManager\nfrom arpirobot.core.network import NetworkTable\n\n# Import devices and other things here\n\n# Import actions here\n# from actions import ...\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        # Do not remove this line\n        super().__init__()\n\n        # Create devices and constants as member variables here\n        # self.device_var = DeviceClass(args)\n\n        # Only create the devices here. Do not configure them here!\n\n    def robot_started(self):\n        # Run once when the robot starts\n        # Configure devices here\n        Logger.log_info(\"robot_started() run!\")\n\n    def robot_enabled(self):\n        # Runs once each time the robot becomes enabled\n        Logger.log_info(\"robot_enabled() run!\")\n\n    def robot_disabled(self):\n        # Runs once each time the robot becomes disabled\n        Logger.log_info(\"robot_disabled() run!\")\n\n    def enabled_periodic(self):\n        # Runs periodically while the robot is enabled\n        pass\n\n    def disabled_periodic(self):\n        # Runs periodically while the robot is disabled\n        pass\n\n    def periodic(self):\n        # Runs periodically (regardless of robot state)\n\n        # Do not remove this line or some devices will be disabled\n        self.feed_watchdog()\n</code></pre> <pre><code>#include &lt;robot.hpp&gt;\n\n#include &lt;arpirobot/core/log/Logger.hpp&gt;\n#include &lt;arpirobot/core/action/ActionManager.hpp&gt;\n#include &lt;arpirobot/core/network/NetworkTable.hpp&gt;\n\nusing namespace arpirobot;\n\n\nvoid Robot::robotStarted(){\nLogger::logInfo(\"robotStarted() run!\");\n}\n\nvoid Robot::robotEnabled(){\nLogger::logInfo(\"robotEnabled() run!\");\n}\n\nvoid Robot::robotDisabled(){\nLogger::logInfo(\"robotDisabled() run!\");\n}\n\nvoid Robot::enabledPeriodic(){\n\n}\n\nvoid Robot::disabledPeriodic(){\n\n}\n\nvoid Robot::periodic(){\n// Do not remove this line or some devices will be disabled.\nfeedWatchdog();\n}\n</code></pre> <p>The above program adds custom log messages in the <code>robot_started</code> / <code>robotStarted</code>, <code>robot_enabled</code> / <code>robotEnabled</code>, and <code>robot_disabled</code> / <code>robotDisabled</code> functions. The periodic functions do not have log messages in them to avoid logging excessive information (these functions run every 50ms = 20 times per second).</p> <p></p> <p>Build the program (if applicable) and deploy it to the robot. Then, open the drive station and wait for it to connect to the running program (wait for both the \"Network\" and \"Robot Program\" indicators to become green). Once it does click the enable and disable buttons a few times.</p> <p></p> <p>After doing so, log output similar to the following should be visible in the deploy tool. Some of this log output will also be visible in the robot program log tab of the drive station, however the drive station only shows the log messages after the drive station was connected. The deploy tool shows log messages for the entire program.</p> <p></p> <p>As seen above, the <code>robot_started</code> / <code>robotStarted</code> function runs only once, whereas the <code>robot_enabled</code> / <code>robotEnabled</code> and <code>robot_disabled</code> / <code>robotDisabled</code> run multiple times (depending on how many times the robot was enabled / disabled from the drive station).</p>"},{"location":"guide/programming/drivegamepad/","title":"Driving with Gamepad","text":"<p>Now that motor objects are setup and you know the basics of moving motors, it is time to begin driving the robot.</p>"},{"location":"guide/programming/drivegamepad/#motor-positions-and-directions","title":"Motor Positions and Directions","text":"<p>Before starting to drive the robot, it is important to know which motor object in code cooresponds to which physical motor. For example, on a two wheel drive robot, you need to know if motor A is left or right (and the same for motor B). For a four wheel drive robot, you needs to know which motor is front left, front right, rear left, and rear right. This is easily determined by examining the wiring on your robot (follow the wires from a specific motor to the motor controller to determine which motor it is). Once you've done this, it is a good idea to change the name of your motor variables to be something more relevant. For example on a two wheel drive robot instead of <code>motor_a</code> and <code>motor_b</code> you could use <code>lmotor</code> and <code>rmotor</code> (left and right motor). On a four wheel drive robot you could use <code>flmotor</code>, <code>frmotor</code>, <code>rlmotor</code>, and <code>rrmotor</code> (front left, front right, rear left, rear right). You can rename the motor objects using something like what is shown below</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Somewhere in __init__\nself.motor1 = ...\nself.motor2 = ...\nself.motor3 = ...\nself.motor4 = ...\n\n# Change to something like the following\n# Make sure to use the correct numbers for each motor\nself.flmotor = ...\nself.frmotor = ...\nself.rlmotor = ...\nself.rrmotor = ...\n</code></pre> <pre><code>// At the bottom of the Robot class declaration\nMotorType motor1 = ...;\nMotorType motor2 = ...;\nMotorType motor3 = ...;\nMotorType motor4 = ...;\n\n// Change to something like the following\n// Make sure to use the correct numbers for each motor\n// This may also be in the initializer list of a constructor \n// depending on which motor controller you use\nMotorType flmotor = ...;\nMotorType frmotor = ...;\nMotorType rlmotor = ...;\nMotorType rrmotor = ...;\n</code></pre> <p>To check if you have each motor correct add a line like the following to <code>robot_enabled</code> / <code>robotEnabled</code> for the front left motor (or just the left motor on a two-wheel drive robot). Build (if required) and deploy the robot code. When enabled, the front left (or left) wheel should spin. Repeat this for all motors and make changes as needed.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_enabled(self):\n    self.flmotor.set_speed(1)\n</code></pre> <pre><code>void robotEnabled(){\nflmotor.setSpeed(1);\n}\n</code></pre> <p>Now that it is easy to identify which motor is which from your code, it should be easy to make sure all motors spin the \"correct\" direction. In this case \"correct\" means that all motors spin the same direction when given a positive value. Often it is best to choose positive to be forward, therefore for this section \"correct\" will mean that a motor spins such that the robot would move forward when given a positive speed.</p> <p>To determine which motors need to be inverted, replace <code>robot_enabled</code> / <code>robotEnabled</code> with the following. If you have a two wheel drive robot, change the motor names and only keep two lines.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_enabled(self):\n    self.flmotor.set_speed(1)\n    self.frmotor.set_speed(1)\n    self.rlmotor.set_speed(1)\n    self.rrmotor.set_speed(1)\n</code></pre> <pre><code>void robotEnabled(){\nflmotor.setSpeed(1);\nfrmotor.setSpeed(1);\nrlmotor.setSpeed(1);\nrrmotor.setSpeed(1);\n}\n</code></pre> <p>Build and deploy the program to the robot. When enabled all motors should begin spinning. If any are spinning the incorrect direction (incorrect meaning they would make the robot move in reverse) add a line like the following in <code>robot_started</code> / <code>robotStarted</code> to invert its direction.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># If front left motor is incorrect add the following\n# Change motor name as needed\n# Add for multiple motors if needed\nself.flmotor.set_inverted(True)\n</code></pre> <pre><code>// If front left motor is incorrect add the following\n// Change motor name as needed\n// Add for multiple motors if needed\nflmotor.setInverted(true);\n</code></pre> <p>After adding these lines, rebuild and deploy. Enable the robot again and all motors should move the robot forward.</p>"},{"location":"guide/programming/drivegamepad/#drive-helpers","title":"Drive Helpers","text":"<p>Now that you know which motor is which and all spin the correct direction, the problem becomes how to choose a speed for the motors. The plan is to use a gamepad to drive the robot, but what specifically should control the motor movement? One method would be to drive the robot at a fixed speed when a button is held, but that is relatively limited. Another option would be to use a joystick to control a specific motor, or a set of motors, however this may require multiple lines of code to do the same thing to multiple motors or it may require calculations to determine a motor's speed. Two common control schemes are described below</p> <p>Tank Drive is a method where you use the vertical axes on a controller to control the robot. The left stick is moved up / down to control the speed of the left motors. The right stick is moved up / down to control the speed of the right motors. This method requires no special calculations as the motor's speeds come directly from axis values, but you may have to set the same speed to many motors at a time, making it easy to miss one and have an issue in your code. Additionally, this method of control is not very \"easy\" to use.</p> <p>Arcade Drive is a method where a vertical axis controls the robot's speed and a horizontal axis controls the robot's rotation. These could be two axes on the same stick or on different sticks. Often, the left stick would be moved up / down to control the robot's forward speed and the right stick would be moved left / right to rotate the robot. This is a more intuitive method of controlling the robot, however it requires that some calculations be performed using the joystick values to determine how fast each motor should spin.</p> <p>As explained above, using joystick axes to control the robot is sometimes difficult, however the ArPiRobot core library (corelib) provides \"drive helpers\" to enable these control schemes to work easily. The following code will focus on the Arcade drive scheme as it is easier to use and often preferred. The corelib provides a <code>ArcadeDriveHelper</code> object which manages motor speeds. The drive helper is given a \"speed\" and \"rotation\". It calculates how fast each motor should be moving based off this and controls the motor speeds. To use <code>ArcadeDriveHelper</code> add the following to the top of <code>robot.py</code> or <code>robot.hpp</code> with the other imports / includes.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.core.drive import ArcadeDriveHelper\n</code></pre> <pre><code>#include &lt;arpirobot/core/drive/ArcadeDriveHelper.hpp&gt;\n</code></pre> <p>Then add the following at the indicated location</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add in __init__ with other devices (after motors)\nself.drive_helper = ArcadeDriveHelper(\n    [self.flmotor, self.rlmotor],           # Left motors\n    [self.frmotor, self.rrmotor]            # Right motors\n)\n\n# For a 2-wheel robot use this instead\nself.drive_helper = ArcadeDriveHelper(\n    self.lmotor,                            # Left motor\n    self.rmotor                             # Right motor\n)\n</code></pre> <pre><code>// Add with device declarations (after motors)\nArcadeDriveHelper driveHelper {\n{flmotor, rlmotor},                     // Left motors\n{frmotor, rrmotor}                      // Right motors\n};\n\n// For a 2-wheel robot use this instead\nArcadeDriveHelper driveHelper {\nlmotor,                                 // Left motor\nrmotor                                  // Right motor\n};\n</code></pre> <p>Finally, replace <code>robot_enabled</code> / <code>robotEnabled</code> with the following to test the drive helper</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_enabled(self):\n    speed = 1.0\n    rotation = 0.25\n    self.drive_helper.update(speed, rotation)\n</code></pre> <pre><code>void robotEnabled(){\ndouble speed = 1.0;\ndouble rotation = 0.25;\ndriveHelper.update(speed, rotation);\n}\n</code></pre> <p>When the robot is enabled (build and deploy the code first) the robot will drive forward with a slight ark due to the rotation. This <code>update</code> function will be used later with gamepad data to drive the robot. In addition, if you ever want to change the speed value without affecting rotation you can use <code>update_speed</code> / <code>updateSpeed</code>. Likewise the rotation can be changed without affecting the speed using <code>update_rotation</code> / <code>updateRotation</code>.</p> <p>The <code>TankDriveHelper</code> is also included in the corelib and provides support for the tank drive scheme described above. It works similarly to <code>ArcadeDriveHelp</code>, but instead of speed and rotation you provide a left speed and right speed to <code>update(left_speed, right_speed)</code>. This drive helper will not be used in this guide as the arcade drive scheme is more intuitive.</p>"},{"location":"guide/programming/drivegamepad/#using-a-gamepad","title":"Using a Gamepad","text":"<p>Now that your code contains a drive helper, all that remains to drive the robot is to get gamepad data from your computer to the robot. The Drive Station is used to accomplish this. </p>"},{"location":"guide/programming/drivegamepad/#gamepads-in-the-drive-station","title":"Gamepads in the Drive Station","text":"<p>Before modifying the robot code, open the Drive Station on your computer and connect your gamepad. You should see it listed in the bottom left of the drive station.</p> <p></p> <p>Each gamepad in the drive station is assigned a number based on its order in this list. The top gamepad is number zero. You will often only have one gamepad, but if you have multiple you can drag them to reorder them in the list and assign different numbers. For now, we will only be using one gamepad, number zero, so make sure the gamepad you plan to use is at the top of the list if you have multiple.</p> <p>Additionally, each gamepad has a checkbox  by its name. By default, all gamepads are unchecked. When this is the case, the Drive Station will not send data from these gamepads to the robot. You must check the box beside any gamepad you plan to use. You will have to check this box by your gamepad each time you start the Drive Station.</p> <p>If you click on the name of the gamepad in the list you will be able to see a response to pressing buttons or moving the sticks to the right of the gamepad list in the Drive Station. Each axis and button also has a number assigned to it. These numbers are shown in the drive station. If you are unsure what number a certain button is, press the button and look for which indicator lights up. The number will be listed on the lit indicator. Likewise, you can move an axis and see which indicator changes to determine axis numbers.</p> <p></p>"},{"location":"guide/programming/drivegamepad/#adding-a-gamepad-to-code","title":"Adding a Gamepad to Code","text":"<p>To get gamepad data in your code you need to add a <code>Gamepad</code> object. First add the import / include with the others at the top of <code>robot.py</code> or <code>robot.hpp</code>.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.devices.gamepad import Gamepad\n</code></pre> <pre><code>#include &lt;arpirobot/devices/gamepad/Gamepad.hpp&gt;\n</code></pre> <p>The add a new device to your <code>Robot</code> class</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add below drive_helper in __init__\n# Using gamepad number 0\n# Change number in constructor to use other gamepad number\n# You can create multiple gamepad objects to use multiple gamepads\nself.gp0 = Gamepad(0)\n</code></pre> <pre><code>// Add below driveHelper in class declaration\n// Using gamepad number 0\n// Change number in constructor to use other gamepad number\n// You can create multiple gamepad objects to use multiple gamepads\nGamepad gp0 {0};\n</code></pre> <p>This <code>Gamepad</code> object has several functions to get data from the gamepad (note that the drive station must have the corresponding number gamepad checked).</p> PythonC++ <ul> <li><code>get_axis(axis_num, deadband)</code>: Get the value of the given axis (between -1 and 1). A deadband is optional. A deadband is a \"minimum magnitude\" of axis values. Any axis value who's absolute value is smaller than the deadband is treated as zero. For example, if the deadband is 0.1 and the axis reads 0.05 or -0.05 the get_axis function will return 0 not 0.05 or -0.05. Only once the axis reads 0.1 will the value returned by get_axis increase above zero. A deadband is useful as a stick is rarely (if ever) going to read exactly zero when not pressed.</li> <li><code>get_button(button_num</code>): Determine if the given button is pressed (True = pressed, False = not pressed).</li> <li><code>get_dpad(dpad_num</code>): Get the value of the current dpad. Note that currently only one dpad is supported so calling this with any dpad_num other than 0 will always return 0. The direction is given as a number between 0 and 8 (see Drive Station for what these numbers mean).</li> </ul> <ul> <li><code>getAxis(axisNum, deadband)</code>: Get the value of the given axis (between -1 and 1). A deadband is optional. A deadband is a \"minimum magnitude\" of axis values. Any axis value who's absolute value is smaller than the deadband is treated as zero. For example, if the deadband is 0.1 and the axis reads 0.05 or -0.05 the getAxis function will return 0 not 0.05 or -0.05. Only once the axis reads 0.1 will the value returned by getAxis increase above zero. A deadband is useful as a stick is rarely (if ever) going to read exactly zero when not pressed.</li> <li><code>getButton(buttonNum</code>): Determine if the given button is pressed (true = pressed, false = not pressed).</li> <li><code>getDpad(dpadNum</code>): Get the value of the current dpad. Note that currently only one dpad is supported so calling this with any dapdNum other than 0 will always return 0. The direction is given as a number between 0 and 8 (see Drive Station for what these numbers mean).</li> </ul> <p>The above functions can be used to get gamepad data and use it to move the robot.</p>"},{"location":"guide/programming/drivegamepad/#driving-the-robot","title":"Driving the Robot","text":"<p>Up until now, the <code>enabled_periodic</code> / <code>enabledPeriodic</code> function has not been used. However, to drive the robot with a gamepad it must repeatedly check the current gamepad data and adjust motor speeds based on it. Since motors can only be moved while the robot is enabled, <code>enabled_periodic</code> / <code>enabledPeriodic</code> is the place for this code to go. To drive the robot the following set of tasks will be performed in <code>enabled_periodic</code> / <code>enabledPeriodic</code></p> <ul> <li>Get the value for the speed axis</li> <li>Get the value for the rotation axis</li> <li>Update the speed of all motors using the drive helper</li> </ul> <p>Before this code can be added, however, it is necessary to choose a speed axis and a rotation axis. The speed axis will be the left y (vertical) axis or axis number 1. The rotation axis will be the right x (horizontal) axis or axis number 2. To make the code more readable and easier to change later if desired, instead of using the numbers directly constants are created for the axis numbers in <code>robot.py</code> or <code>robot.hpp</code>. Additionally, a deadband of 0.1 will be used as this should be sufficient for most controllers. If a deadband were not used the motors would still try to move slightly even when the joysticks were not pressed.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add in __init__ after device variables\n# Note that python does not support actual constants\n# We will treat any variable in all caps as a constant\nself.SPEED_AXIS = 1\nself.ROTATE_AXIS = 2\nself.DEADBAND = 0.1\n</code></pre> <pre><code>// Add in the Robot class declaration after device variables\nconst int SPEED_AXIS = 1;\nconst int ROTATE_AXIS = 2;\nconst double DEADBAND = 0.1;\n</code></pre> <p>Then the <code>enabled_periodic</code> / <code>enabledPeriodic</code> function can be implemented as follows. Also, remove anything in <code>robot_enabled</code> / <code>robotEnabled</code> that may be left from testing drive helpers (<code>robot_enabled</code> / <code>robotEnabled</code> should be an empty function now; in python use \"pass\").</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def enabled_periodic(self):\n    # Get value for the speed axis\n    speed = self.gp0.get_axis(self.SPEED_AXIS, self.DEADBAND)\n\n    # Get value for the rotation axis\n    rotation = self.gp0.get_axis(self.ROTATE_AXIS, self.DEADBAND)\n\n    # Update speed of all motors using drive helper\n    self.drive_helper.update(speed, rotation)\n</code></pre> <pre><code>void enabledPeriodic(){\n// Get value for speed axis\ndouble speed = gp0.getAxis(SPEED_AXIS, DEADBAND);\n\n// Get value for the rotation axis\ndouble rotation = gp0.getAxis(ROTATE_AXIS, DEADBAND);\n\n// Update speed of all motors using drive helper\ndriveHelper.update(speed, rotation);\n}\n</code></pre> <p>Build and deploy this program to the robot. Open the Drive Station, connect your gamepad and enable it in the drive station (check the box by the gamepad). Also make sure it is gamepad number 0. Then, enable the robot. You should now be able to drive the robot using the gamepad, however directions are probably incorrect.</p> <p>Most likely, your robot drives forward when you press the left stick down. Recall that the motors were configured such that positive was forward. However, most gamepads \"up\" on the stick is negative = reverse. To fix this, multiply the speed by negative 1.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>speed = -1 * self.gp0.get_axis(self.SPEED_AXIS, self.DEADBAND)\n</code></pre> <pre><code>double speed = -1 * gp0.getAxis(SPEED_AXIS, DEADBAND);\n</code></pre> <p>If your rotation is also the incorrect direction this can also be fixed the same way (multiply the rotation variable by negative 1). If you are unable to fix directions with multiplications by negative 1, you have motors numbered incorrectly (motor numbers for left and right motors are mixed up).</p>"},{"location":"guide/programming/drivegamepad/#axis-transforms-advanced-topic","title":"Axis Transforms (Advanced Topic)","text":"<p>Note: This section describes in detail what an axis transform is, how they work mathematically, and why certain transforms are selected for rotation and speed. If you don't care about that, skip to the bottom of this section. Code is shown for how to use the transforms. You can implement this code and just experiment with them to see if you like the results.</p>"},{"location":"guide/programming/drivegamepad/#what-is-an-axis-transform","title":"What is an Axis Transform","text":"<p>An Axis Transform is an object that alters how an axis's value changes as the joystick is moved. It can be considered a mathematical function that takes joystick position (-1 to 1) as an input and returns an altered output to change the \"shape\" of the joystick graph. Unaltered, the value returned by <code>get_axis</code> / <code>getAxis</code> (referred to as the output value) is the same as the value obtained from the drive station (referred to as the input value) provided no deadband is used. This can be considered a simple linear function.</p> <p></p> <p>An axis transform alters this linear relation to have a different shape. Two axis transforms are currently implemented: a cubic transform and a square root transform.</p>"},{"location":"guide/programming/drivegamepad/#square-root-axis-transform","title":"Square Root Axis Transform","text":"<p>The square root transform is very simple. The output is the square root of the input (note that for negative inputs, the output is the negative of the square root of the absolute value of the input). The original intention behind this transform is for use with rotating the robot. In practice, it is often the case that when rotating the robot \"slow\" speeds of rotation are used little if at all. Often rotating the robot even a slow speed requires a significant amount of rotation power. As such, it is desirable that when the joystick is moved a little distance from center (zero) the rotation power (output of <code>get_axis</code> / <code>getAxis</code>) should increase rapidly. However, once the rotation power reaches a certain point small changes in power can quickly alter rotation speed. As such, as the joystick is further from center it is desired to slow the rate of change of output power to increase controllability. This describes a square root graph. Effectively, this means that the joystick must only be pressed a small distance to begin rotating and once rotation starts a large range of the joystick is dedicated to fine tuning of rotation speed making it easy to achieve a constant rotation speed.</p> <p></p> <p>Consider the example where 30% power is necessary to begin rotating the robot. It is desirable to quickly reach this level once the joystick begins to move. With a linear relation (no transform) this is acheived once the stick is pressed 30% of its range of motion, leaving 70% of the range of motion to \"fine tune\" rotation speed. In contrast, with the square root relation 30% output is reached when the stick has moved to only 9% of its range of motion. This leaves 91% of the range of motion to fine tune rotation. As such, the joystick can be held \"less accurately\" in the same spot while still maintaining the \"same\" rotation rate. While an increase of 21% may seem fairly small, the joysticks on gamepads often have a small range of motion. </p> <p></p> <p></p> <p>As is seen in the above graphs, when used for the rotation axis, a square root transform reduces the distance over which there is no effect and increases the \"fine tune\" region making it easier to both start rotation and to maintain a \"fixed\" rotation speed.</p>"},{"location":"guide/programming/drivegamepad/#cubic-axis-transform","title":"Cubic Axis Transform","text":"<p>In addition to the square root transform, a cubic transform is implemented. The cubic transform is designed for use with a drive speed axis and is more complex than the square root transform. The idea behind the square root transform is that most often when driving the robot two speeds are used: full speed and a \"medium\" speed that is sufficient to keep the robot moving, but allow maneuvering the robot to be simpler. Rarely are speeds between these used (other than of course stopped). Attaining full speed is easy, simply press the joystick to the limit. However, attaining and maintaining a \"medium\" controllable speed is more difficult as there is a very limited range of stick motion that is allowable. The goal of the cubic transform is to extend the area of the stick that results in the \"medium\" speed. This speed will be referred to as the \"mid power\" or \"midPower\". Additionally, it is sometimes the case that a minimum speed exist when driving the robot (generally desirable if the robot does not start moving until a fairly high amount of power is applied). This will be referred to as the \"min power\" or \"minPower\".</p> <p>Since the goal of the cubic transform is to dedicate a large area of the joystick to the mid power, it follows that going from zero output to mid power must happen fairly rapidly. The curve then flattens out around mid power before rising fairly rapidly to full power. This is achieved by fitting a cubic curve to the following set of points</p> input output 0 minPower 0.45 midPower 0.5 midPower 0.55 midPower 1 1 <p>Note that when the input is zero the output is minPower. As such using a cubic axis transform with a non-zero minPower requires use of a deadband (otherwise the robot will always move). Additionally, the cubic transform is constructed only for positive inputs. When inputs are negative the transform operates on their absolute value. The output of the transform matches the sign of the input (in other words, the cubic function is rotated about the origin into the third quadrant to yield the correct response for negative inputs). This results in a curve looking something like the following (in the below example minPower = 0.2 and minPower = 0.6)</p> <p></p> <p>Analyzing this curve it is seen that approximately a third of the joystick's range of motion will achieve the \"controllable\" speed discussed before.</p> <p></p>"},{"location":"guide/programming/drivegamepad/#deadbands-with-axis-transforms","title":"Deadbands with Axis Transforms","text":"<p>As mentioned previously, using the cubic transform with a non-zero minPower requires use of a deadband. Additionally, it is rarely desirable to use any transform without a deadband (for the same reasons as it is not desirable to use a linear relation without a deadband). However, this brings up the question of how the deadband is applied and how that affects the transforms. In the <code>Gamepad</code>'s <code>get_axis</code> / <code>getAxis</code> function, the deadband is applied before the transform. If the value is within the deadband (too small) the function returns zero and never applies the transform. Once the deadband is crossed the input value is actually altered. A deadband alters the input value from a controller to make it smooth. If it was unaltered there would be a jump as the deadband is crossed (see picture below). The deadband alters the input by adjusting it to fit a line from (deadband, 0) to (1, 1) as shown in the second picture (or those equivalent points in the third quadrant). In the pictures below the deadband is 0.1</p> <p></p> <p></p> <p>The second graph is how the deadband works in the ArPiRobot CoreLib. The values on this adjusted line are then passed to the transforms. In effect, this compresses any transform slightly horizontally just as the deadband does for a line. Some examples of this are shown below for both the square root and cubic transforms seen earlier. Note that the \"jump\" in the cubic with deadbad graph is due to the minPower of the cubic. If a minPower of zero were used there would be no jump.</p> <p></p> <p></p>"},{"location":"guide/programming/drivegamepad/#using-axis-transforms-in-code","title":"Using Axis Transforms in Code","text":"<p>Implementing either of the two axis transforms described above is simple as they are builtin to the core library. The following shows how to add a Cubic transform (minPower = 0, midPower = 0.5) to the speed axis and a square root transform to the rotate axis.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Add with imports at top\nfrom arpirobot.core.drive import CubicAxisTransform, SquareRootAxisTransform\n\n# Add in robot_started\nself.gp0.set_axis_transform(self.SPEED_AXIS, CubicAxisTransform(0, 0.5))\nself.gp0.set_axis_transform(self.ROTATE_AXIS, SquareRootAxisTransform())\n</code></pre> <pre><code>// Add with includes at top\n#include &lt;arpirobot/core/drive/CubicAxisTransform.hpp&gt;\n#include &lt;arpirobot/core/drive/SquareRootAxisTransform.hpp&gt;\n\n// Add in robotStarted\ngp0.setAxisTransform(SPEED_AXIS, std::make_shared&lt;CubicAxisTransform&gt;(0, 0.5));\ngp0.setAxisTransform(ROTATE_AXIS, std::make_shared&lt;SquareRootAxisTransform&gt;());\n</code></pre>"},{"location":"guide/programming/examplesrepo/","title":"Examples Repo","text":"<p>Full example code and additional examples are available in the ArPiRobot-Examples repository on GitHub. The examples in this repository are designed to work on the Mini Clipboard Robot example build.</p>"},{"location":"guide/programming/movingmotors/","title":"Moving Motors","text":"<p>One of the most important devices on a robot are the motors. Controlling the motors allows your robot to perform many tasks, one of the most basic and essential of which is driving. This section will cover different motor controller options and writing code to control the motors.</p>"},{"location":"guide/programming/movingmotors/#motor-controllers","title":"Motor Controllers","text":"<p>Many different motor controllers are supported by the ArPiRobot framework. Each one requires slightly different code to use. The ArPiRobot framework is object oriented, meaning your program will have one object for each motor on your robot, and sometimes one for the motor controller itself. The objects for the motors all have the same set of functions, but must be created differently based on the motor controller in use. This section covers creating the objects for the motors depending on which motor controller you use on your robot. The following section shows how to use the motor objects. Use of the motor objects is the same regardless of which motor type. In this section, you need only add the code for the motor controller you use on your robot.</p> DRV8833 Motor Controller <p></p> <p>Image Credit: Adafruit</p> <p>The DRV8833 motor controller is a PWM driven motor controller chip capable of controlling two motors. The module pictured above is Adafruit's DRV8833 breakout board. Battery power is input using the terminal block (labeled Vmotor), motors are connected to Aout pins and Bout pins, and several I/O pins from the Raspberry Pi are connected to the control pins opposite the Aout and Bout pins. The Ain pins are used to control motor A and the Bin pins are used to controller motor B. The SLP (sleep) pin is used to enable / disable sleep mode on the entire controller. When in sleep mode, neither motor will respond. As such, it is necessary to make the following connections to the Raspberry Pi</p> DRV8833 Pin Raspberry Pi Pin Ain1 Any GPIO (eg. 23) Ain2 Any GPIO (eg. 24) SLP Any GPIO (eg. 25) Bin1 Any GPIO (eg. 17) Bin2 Any GPIO (eg. 27) GND Any GND* <p>* This only needs to be connected on one motor controller if multiple are used on the robot. This ensures that motor battery GND (usually AA batteries) and robot power GND (usually a USB battery pack) are connected. This is important for some sensors.</p> <p>Each control pin (all but GND) must use a different GPIO. As such, 5 GPIO pins are needed per DRV8833 module. In the robot code, an object is constructed for the DRV8833 module. This object for the module constructs objects for both motors (A and B). This object is constructed using the pin numbers (broadcom pin numbering). Pinout and pin numbers can be found at pinout.xyz. You can choose any 5 GPIO pins. This pinout also shows which pins on the Pi are GND pins.</p> <p>An object for the DRV8833 module and both of its motors can be used in robot code as shown below</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.log import Logger\nfrom arpirobot.core.action import ActionManager\nfrom arpirobot.core.network import NetworkTable\n\n# Import devices and other things here\n\n# ADDED: Imports for DRV8833\nfrom arpirobot.devices.drv8833 import DRV8833Module\n\n# Import actions here\n# from actions import ...\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        # Do not remove this line\n        super().__init__()\n\n        # Create devices and constants as member variables here\n        # self.device_var = DeviceClass(args)\n\n        # ADDED: Creation of DRV8833 module and motor variables\n        # Duplicate this code for each DRV8833 in use, but use different\n        # variable names. When constructing DRV8833Module arguments are pin\n        # numbers in order Ain1, Ain2, Bin1, Bin2, SLP\n        self.drv8833 = DRV8833Module(23, 24, 17, 27, 25)\n        self.motor_a = self.drv8833.get_motor_a()\n        self.motor_b = self.drv8833.get_motor_b()\n\n        # Only create the devices here. Do not configure them here!\n\n    def robot_started(self):\n        # Run once when the robot starts\n        # Configure devices here\n        pass\n\n    def robot_enabled(self):\n        # Runs once each time the robot becomes enabled\n        pass\n\n    def robot_disabled(self):\n        # Runs once each time the robot becomes disabled\n        pass\n\n    def enabled_periodic(self):\n        # Runs periodically while the robot is enabled\n        pass\n\n    def disabled_periodic(self):\n        # Runs periodically while the robot is disabled\n        pass\n\n    def periodic(self):\n        # Runs periodically (regardless of robot state)\n\n        # Do not remove this line or some devices will be disabled\n        self.feed_watchdog()\n</code></pre> <pre><code>#pragma once\n\n#include &lt;arpirobot/core/robot/BaseRobot.hpp&gt;\n\n#include &lt;actions.hpp&gt;\n\n// Other includes (for devices and other objects) here\n\n// ADDED: Includes for DRV8833\n#include &lt;arpirobot/devices/drv8833/DRV8833Module.hpp&gt;\n#include &lt;arpirobot/devices/drv8833/DRV8833Motor.hpp&gt;\n\n\nusing namespace arpirobot;\n\n\nclass Robot : public BaseRobot{\npublic:\n\n// Run when the robot starts\nvoid robotStarted();\n\n// Runs once each time the robot becomes enabled\nvoid robotEnabled();\n\n// Runs once each time the robot becomes disabled\nvoid robotDisabled();\n\n// Runs periodically while the robot is enabled\nvoid enabledPeriodic();\n\n// Runs periodically while the robot is disabled\nvoid disabledPeriodic();\n\n// Runs periodically (regardless of robot state)\nvoid periodic();\n\n\n// Add devices and constants here as member objects\n// These should be public so actions can access them using Main::robot\n\n// ADDED: Creation of DRV8833 module and motor variables\n// Duplicate this code for each DRV8833 in use, but use different\n// variable names. When constructing DRV8833Module arguments are pin \n// numbers in order Ain1, Ain2, Bin1, Bin2, SLP\nDRV8833Module drv8833 {23, 24, 17, 27, 25};\nDRV8833Motor &amp;motorA {drv8833.getMotorA()};\nDRV8833Motor &amp;motorB {drv8833.getMotorB()};\n};\n</code></pre> TB6612 Motor Controller <p></p> <p>Image Credit: Adafruit</p> <p>The TB6612 motor controller is a PWM driven motor controller chip capable of controlling two motors. The module pictured above is Adafruit's TB6612 breakout board. Battery power is input using the terminal block (labeled Vmotor), motors are connected to MotorA pins and MotorB pins, and several I/O pins from the Raspberry Pi are connected to the control pins opposite the MotorA and MotorB pins. The Ain pins and PwmA are used to control motor A and the Bin pins and PwmB are used to controller motor B.  As such, it is necessary to make the following connections to the Raspberry Pi</p> TB6612 Pin Raspberry Pi Pin Ain1 Any GPIO (eg. 23) Ain2 Any GPIO (eg. 24) PwmA Any GPIO (eg. 25) Bin1 Any GPIO (eg. 17) Bin2 Any GPIO (eg. 27) PwmB Any GPIO (eg. 22) GND Any GND* <p>* This only needs to be connected on one motor controller if multiple are used on the robot. This ensures that motor battery GND (usually AA batteries) and robot power GND (usually a USB battery pack) are connected. This is important for some sensors.</p> <p>Each control pin (all but GND) must use a different GPIO. As such, 6 GPIO pins are needed per TB6612 module. In the robot code, an object is constructed for the TB6612 module. This object for the module constructs objects for both motors (A and B). This object is constructed using the pin numbers (broadcom pin numbering). Pinout and pin numbers can be found at pinout.xyz. You can choose any 6 GPIO pins. This pinout also shows which pins on the Pi are GND pins.</p> <p>An object for the TB6612 module and both of its motors can be used in robot code as shown below</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.log import Logger\nfrom arpirobot.core.action import ActionManager\nfrom arpirobot.core.network import NetworkTable\n\n# Import devices and other things here\n\n# ADDED: Imports for TB6612\nfrom arpirobot.devices.tb6612 import TB6612Module\n\n# Import actions here\n# from actions import ...\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        # Do not remove this line\n        super().__init__()\n\n        # Create devices and constants as member variables here\n        # self.device_var = DeviceClass(args)\n\n        # ADDED: Creation of TB6612 module and motor variables\n        # Duplicate this code for each TB6612 in use, but use different\n        # variable names. When constructing TB6612Module arguments are pin\n        # numbers in order Ain1, Ain2, PwmA, Bin1, Bin2, PwmB\n        self.tb6612 = TB6612Module(23, 24, 25, 17, 27, 22)\n        self.motor_a = self.tb6612.get_motor_a()\n        self.motor_b = self.tb6612.get_motor_b()\n\n        # Only create the devices here. Do not configure them here!\n\n    def robot_started(self):\n        # Run once when the robot starts\n        # Configure devices here\n        pass\n\n    def robot_enabled(self):\n        # Runs once each time the robot becomes enabled\n        pass\n\n    def robot_disabled(self):\n        # Runs once each time the robot becomes disabled\n        pass\n\n    def enabled_periodic(self):\n        # Runs periodically while the robot is enabled\n        pass\n\n    def disabled_periodic(self):\n        # Runs periodically while the robot is disabled\n        pass\n\n    def periodic(self):\n        # Runs periodically (regardless of robot state)\n\n        # Do not remove this line or some devices will be disabled\n        self.feed_watchdog()\n</code></pre> <pre><code>#pragma once\n\n#include &lt;arpirobot/core/robot/BaseRobot.hpp&gt;\n\n#include &lt;actions.hpp&gt;\n\n// Other includes (for devices and other objects) here\n\n// ADDED: Includes for TB6612\n#include &lt;arpirobot/devices/tb6612/TB6612Module.hpp&gt;\n#include &lt;arpirobot/devices/tb6612/TB6612Motor.hpp&gt;\n\n\nusing namespace arpirobot;\n\n\nclass Robot : public BaseRobot{\npublic:\n\n// Run when the robot starts\nvoid robotStarted();\n\n// Runs once each time the robot becomes enabled\nvoid robotEnabled();\n\n// Runs once each time the robot becomes disabled\nvoid robotDisabled();\n\n// Runs periodically while the robot is enabled\nvoid enabledPeriodic();\n\n// Runs periodically while the robot is disabled\nvoid disabledPeriodic();\n\n// Runs periodically (regardless of robot state)\nvoid periodic();\n\n\n// Add devices and constants here as member objects\n// These should be public so actions can access them using Main::robot\n\n// ADDED: Creation of TB6612 module and motor variables\n// Duplicate this code for each TB6612 in use, but use different\n// variable names. When constructing TB6612Module arguments are pin \n// numbers in order Ain1, Ain2, PwmA, Bin1, Bin2, PwmB\nTB6612Module tb6612 {23, 24, 25, 17, 27, 22};\nTB6612Motor &amp;motorA {tb6612.getMotorA()};\nTB6612Motor &amp;motorB {tb6612.getMotorB()};\n};\n</code></pre> L298N Motor Controller <p></p> <p>The L298N motor controller is a PWM driven motor controller chip capable of controlling two motors. The module pictured above is a common breakout board / module using the L298N chip. Battery power is input using the V+ and GND pins. The 5V pin should have nothing connected to it generally. The 5V pin is used to supply 5V power if the input voltage (between V+ and GND) exceeds 12V. If the input voltage exceeds 12V disconnect the jumper for the builtin 5V regulator (circled in green) and supply 5V power from elsewhere (Pi, Arduino, etc). The L298N module supports two motors. Motor A is connected to OUT1 and OUT2. Motor B is connected to OUT3 and OUT4. The pins in the bottom right area of the module are connected to the Pi to control both motors. The IN1, IN2, and ENA control motor A and IN3, IN4, and ENB control motor B. Often the EN pins have a jumper connecting them to 5V. Remove these jumpers (circled in yellow) as the ENA and ENB pins will be connected to the Pi instead. The following connections should be made between the L298N module and the Pi</p> L298N Pin Raspberry Pi Pin IN1 Any GPIO (eg. 23) IN2 Any GPIO (eg. 24) ENA Any GPIO (eg. 25) IN3 Any GPIO (eg. 17) IN4 Any GPIO (eg. 27) ENB Any GPIO (eg. 22) GND Any GND* <p>* This only needs to be connected on one motor controller if multiple are used on the robot. This ensures that motor battery GND (usually AA batteries) and robot power GND (usually a USB battery pack) are connected. This is important for some sensors.</p> <p>Each control pin (all but GND) must use a different GPIO. As such, 6 GPIO pins are needed per L298N module. In the robot code, an object is constructed for the L298N module. This object for the module constructs objects for both motors (A and B). This object is constructed using the pin numbers (broadcom pin numbering). Pinout and pin numbers can be found at pinout.xyz. You can choose any 6 GPIO pins. This pinout also shows which pins on the Pi are GND pins.</p> <p>An object for the L298N module and both of its motors can be used in robot code as shown below</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.log import Logger\nfrom arpirobot.core.action import ActionManager\nfrom arpirobot.core.network import NetworkTable\n\n# Import devices and other things here\n\n# ADDED: Imports for L298N\nfrom arpirobot.devices.l298n import L298NModule\n\n# Import actions here\n# from actions import ...\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        # Do not remove this line\n        super().__init__()\n\n        # Create devices and constants as member variables here\n        # self.device_var = DeviceClass(args)\n\n        # ADDED: Creation of L298N module and motor variables\n        # Duplicate this code for each L298N in use, but use different\n        # variable names. When constructing L298NModule arguments are pin\n        # numbers in order IN1, IN2, ENA, IN3, IN4, ENB\n        self.l298n = L298NModule(23, 24, 25, 17, 27, 22)\n        self.motor_a = self.l298n.get_motor_a()\n        self.motor_b = self.l298n.get_motor_b()\n\n        # Only create the devices here. Do not configure them here!\n\n    def robot_started(self):\n        # Run once when the robot starts\n        # Configure devices here\n        pass\n\n    def robot_enabled(self):\n        # Runs once each time the robot becomes enabled\n        pass\n\n    def robot_disabled(self):\n        # Runs once each time the robot becomes disabled\n        pass\n\n    def enabled_periodic(self):\n        # Runs periodically while the robot is enabled\n        pass\n\n    def disabled_periodic(self):\n        # Runs periodically while the robot is disabled\n        pass\n\n    def periodic(self):\n        # Runs periodically (regardless of robot state)\n\n        # Do not remove this line or some devices will be disabled\n        self.feed_watchdog()\n</code></pre> <pre><code>#pragma once\n\n#include &lt;arpirobot/core/robot/BaseRobot.hpp&gt;\n\n#include &lt;actions.hpp&gt;\n\n// Other includes (for devices and other objects) here\n\n// ADDED: Includes for L298N\n#include &lt;arpirobot/devices/l298n/L298NModule.hpp&gt;\n#include &lt;arpirobot/devices/l298n/L298NMotor.hpp&gt;\n\n\nusing namespace arpirobot;\n\n\nclass Robot : public BaseRobot{\npublic:\n\n// Run when the robot starts\nvoid robotStarted();\n\n// Runs once each time the robot becomes enabled\nvoid robotEnabled();\n\n// Runs once each time the robot becomes disabled\nvoid robotDisabled();\n\n// Runs periodically while the robot is enabled\nvoid enabledPeriodic();\n\n// Runs periodically while the robot is disabled\nvoid disabledPeriodic();\n\n// Runs periodically (regardless of robot state)\nvoid periodic();\n\n\n// Add devices and constants here as member objects\n// These should be public so actions can access them using Main::robot\n\n// ADDED: Creation of L298N module and motor variables\n// Duplicate this code for each L298N in use, but use different\n// variable names. When constructing L298NModule arguments are pin \n// numbers in order IN1, IN2, ENA, IN3, IN4, ENB\nL298NModule l298n {23, 24, 25, 17, 27, 22};\nL298NMotor &amp;motorA {l298n.getMotorA()};\nL298NMotor &amp;motorB {l298n.getMotorB()};\n};\n</code></pre> Adafruit Motor Hat / Bonnet <p>Note: The Geekworm motor hat uses the same code as the Adafruit Motor Hat.</p> <p></p> <p>Image Credit: Adafruit</p> <p>Adafruit's motor hat / bonnet are connected to the Pi's GPIO header. The hat covers the entire header, although most pins are not used by the hat. As such, if the hat / bonnet is assembled using stacking headers (highly recommended) many GPIO pins are still accessible for other purposes. Additionally, the hat has a row of pads that headers can be soldered on to to access GPIO pins. This row of headers is directly below the header used to connect to the Pi.</p> <p>Unlike most other motor controllers, the motor hat does not require the Pi generate PWM signals. Instead the motor hat includes its own PWM driver that communicates with the Pi via I2C. This is often better as the Pi generates PWM signals using software. The motor hat also supports four motors.</p> <p>In addition to connecting the motor hat to the Pi, it is necessary to connect motors and battery power to the hat. Battery power is connected to the two-pin terminal block header in the bottom right (labeled \"+\" and \"-\"). The motor hat itself connects \"-\" (battery GND) and GND on the Pi, so no additional ground connections are needed. The motors are connected to the ports labeled M1, M2, M3, and M4. If using the Geekworm motor hat, the code will not use the numbering order printed on the hat (by default). It will instead use the same physical ordering as the Adafruit hat (far left is M1, then M2, then M3, then M4). This can be disabled if desired, but improves compatibility between the two hats.</p> <p>Once connected, the following code can be used to access each motor on the hat</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.log import Logger\nfrom arpirobot.core.action import ActionManager\nfrom arpirobot.core.network import NetworkTable\n\n# Import devices and other things here\n\n# ADDED: Imports for Adafruit Motor Hat\nfrom arpirobot.devices.adafruitmotorhat import AdafruitMotorHatMotor\n\n# Import actions here\n# from actions import ...\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        # Do not remove this line\n        super().__init__()\n\n        # Create devices and constants as member variables here\n        # self.device_var = DeviceClass(args)\n\n        # ADDED: Creation of AdafruitMotorHatMotor for each of 4 motors\n        # When creating motors, I2C address of the hat can be specified\n        # as an optional second argument. If not specified, it will try the\n        # default address of the Adafruit hat. If that fails it will try\n        # the default address of the Geekworm hat. If your motor hat is\n        # not using the default address, it must be specified.\n        # There is also an optional third argument which can be set to false\n        # to disable the \"remapping\" of Geekworm hat motors to match the \n        # Adafruit hat layout\n        # self.my_motor = AdafruitMotorHatMotor(motor_num, hat_addr, remap)\n        self.motor1 = AdafruitMotorHatMotor(1)\n        self.motor2 = AdafruitMotorHatMotor(2)\n        self.motor3 = AdafruitMotorHatMotor(3)\n        self.motor4 = AdafruitMotorHatMotor(4)\n\n        # Only create the devices here. Do not configure them here!\n\n    def robot_started(self):\n        # Run once when the robot starts\n        # Configure devices here\n        pass\n\n    def robot_enabled(self):\n        # Runs once each time the robot becomes enabled\n        pass\n\n    def robot_disabled(self):\n        # Runs once each time the robot becomes disabled\n        pass\n\n    def enabled_periodic(self):\n        # Runs periodically while the robot is enabled\n        pass\n\n    def disabled_periodic(self):\n        # Runs periodically while the robot is disabled\n        pass\n\n    def periodic(self):\n        # Runs periodically (regardless of robot state)\n\n        # Do not remove this line or some devices will be disabled\n        self.feed_watchdog()\n</code></pre> <pre><code>#pragma once\n\n#include &lt;arpirobot/core/robot/BaseRobot.hpp&gt;\n\n#include &lt;actions.hpp&gt;\n\n// Other includes (for devices and other objects) here\n\n// ADDED: Includes for Adafruit Motor Hat\n#include &lt;arpirobot/devices/adafruitmotorhat/AdafruitMotorHatMotor.hpp&gt;\n\n\nusing namespace arpirobot;\n\n\nclass Robot : public BaseRobot{\npublic:\n\n// Run when the robot starts\nvoid robotStarted();\n\n// Runs once each time the robot becomes enabled\nvoid robotEnabled();\n\n// Runs once each time the robot becomes disabled\nvoid robotDisabled();\n\n// Runs periodically while the robot is enabled\nvoid enabledPeriodic();\n\n// Runs periodically while the robot is disabled\nvoid disabledPeriodic();\n\n// Runs periodically (regardless of robot state)\nvoid periodic();\n\n\n// Add devices and constants here as member objects\n// These should be public so actions can access them using Main::robot\n\n// ADDED: Creation of AdafruitMotorHatMotor for each of 4 motors\n// When creating motors, I2C address of the hat can be specified\n// as an optional second argument. If not specified, it will try the\n// default address of the Adafruit hat. If that fails it will try\n// the default address of the Geekworm hat. If your motor hat is\n// not using the default address, it must be specified.\n// There is also an optional third argument which can be set to false\n// to disable the \"remapping\" of Geekworm hat motors to match the \n// Adafruit hat layout\n// AdafruitMotorHatMotor myMotor {motor_num, hat_addr, remap};\nAdafruitMotorHatMotor motor1 {1};\nAdafruitMotorHatMotor motor2 {2};\nAdafruitMotorHatMotor motor3 {3};\nAdafruitMotorHatMotor motor4 {4};\n};\n</code></pre>"},{"location":"guide/programming/movingmotors/#using-the-motors","title":"Using the Motors","text":"<p>Once you have added motor objects to your robot program, they can all be used the same way (regardless of which motor controller you are using). The motor objects all share a common set of functions and features.</p>"},{"location":"guide/programming/movingmotors/#motor-speed-direction","title":"Motor Speed &amp; Direction","text":"<p>Motor speeds are represented as values between -1 and 1. The sign controls direction so -0.5 is 50% in the opposite direction of 0.5 (which is still 50% power). Whether negative is forward or reverse depends on several factors, which will be discussed later.</p> <p>The following code show how to use a motor's <code>set_speed</code> (or <code>setSpeed</code> in C++) function to control a motor's speed. Replace the <code>robot_enabled</code> and <code>robot_disabled</code> functions in your progam with the following.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_enabled(self):\n    self.motor1.set_speed(0.75)\n\ndef robot_disabled(self):\n    self.motor1.set_speed(0)\n</code></pre> <pre><code>void robotEnabled(){\nmotor1.setSpeed(0.75);\n}\n\nvoid robotDisabled(){\nmotor1.setSpeed(0);\n}\n</code></pre> <p>The above code will set the motor called <code>motor1</code> to a speed of 75% when the robot is enabled. When disabled, the motor will be stopped by setting the speed to 0. Note that even if the speed were not set to zero, motors are still disabled and stopped when the robot is disabled. If needed, change the name of the motor from <code>motor1</code> to <code>motor_a</code> or <code>motorA</code> depending on what you named the motor in your code.</p> <p>In the above example, a speed of positive 75% was used. Often it is desired to make positive forward for all motors. If your motor spins in reverse when you run the above code you have a few options. First, you could switch how the motor is connected. A motor has two wires (often a red and a black). Switching the order of the wires connected to the motor controller will reverse the motor direction. However, the motor direction can also be inverted in software. To invert the direction of <code>motor</code> add the following to <code>robot_started</code></p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_started(self):\n    # Add this line to robot_started\n    self.motor1.set_inverted(True)\n</code></pre> <pre><code>void robotStarted(){\n// Add this line to robotStarted\nmotor1.setInverted(true);\n}\n</code></pre>"},{"location":"guide/programming/movingmotors/#brake-mode-coast-mode","title":"Brake Mode &amp; Coast Mode","text":"<p>In addition to setting speed and direction, motor controllers have one other common setting handling what happens when a motor is stopped (speed 0). When a motor is not moving it can either spin freely or it can attempt to resist motion. The latter is referred to as \"brake mode\". To enable brake mode for a motor add a line like the following to <code>robot_started</code>. Brake mode can be disabled later by using the same function, but replacing <code>True</code> with <code>False</code> (or <code>true</code> with <code>false</code>).</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>def robot_started(self):\n    # Add this line to robot_started\n    self.motor1.set_brake_mode(True)\n</code></pre> <pre><code>void robotStarted(){\n// Add this line to robotStarted\nmotor1.setBrakeMode(true);\n}\n</code></pre>"},{"location":"guide/programming/pid/","title":"PID Controller","text":""},{"location":"guide/programming/pid/#about-pid-controllers","title":"About PID Controllers","text":"<p>Note: This is a very high-level overview of PID controllers as they exist in and pertain to the ArPiRobot Core Library. This is not intended to be a heavily mathematical discussion. For more details on PID controllers it is recommended to read Wikipedia's Page on the topic. Additionally, this guide often oversimplifies or generalizes some concepts to how they often apply in the ArPiRobot Core Library or in robotics applications.</p> <p>PID controllers are a common way of using sensor data to make a robot perform some measurable action. In very oversimplified terms, a PID controller is given a target (or setpoint). This setpoint is a target sensor value to reach. The PID controller is then repeatedly given the current sensor value. Using this value and some parameters (which will be discussed later) it calculates a value. This value is to be used to make the robot progress towards having the sensor reach its setpoint. The exact value depends on several factors, but by default it is between <code>-1.0</code> and <code>1.0</code> allowing it to be easily passed to a drive helper to move motors. The exact value returned depends on the \"error\" (or the difference between setpoint and current sensor value) and the values of parameters described below.</p> <p>A PID controller uses three parameters (or gains). - Proportional Gain (kP): The proportional gain is typically used to drive the behavior of the controller. The kP value is multiplied by the error, meaning the output is larger when the error is large, and becomes smaller as the error shrinks. Generally too large of a kP term will cause the robot to oscillate about the setpoint (and never settle at the setpoint) and too small of a kP may result in a significant \"steady state error\" (which is when the robot stops moving, but is not at the setpoint). - Integral Gain (kI): An integral gain is used to reduce steady state error. It is multiplied by error over time. Note that the kI value will often be very small and should generally be much smaller than the kP value. Increasing KI also increases oscillation before the robot settles at the setpoint. Generally, too large of a kI will cause oscillation that never settles at the setpoint and too small of a kI will result in steady state error taking \"too long\" to eliminate. - Derivative Gain (kD): This term is used to reduce how quickly the error changes (and thus has the effect of reducing oscillation). Increasing kD is commonly a way of reducing oscillation due to kP and / or kI. However, too high of a kD will cause unpredictable results. Generally, kD is much smaller than kP.</p> <p>Generally speaking, the following combinations of parameters may be used - P alone is sometimes sufficient (typically if steady state error is not really an issue) - PI is good enough in some cases (typically if small amounts of oscillation before reaching the setpoint) - PD is rarely used, but has some uses (typically if there is just a little too much oscillation). However, it is often better to reduce kP (allowing some steady state error) and increase kI (to correct the error) before adding a kD term.</p> <p>Additionally, the PID controller object in the ArPiRobot Core Library has one more term. An \"F\" or feed-forward term. This is a very simple term that is only useful in certain scenarios. The kF value is multiplied by the setpoint to produce a \"baseline\" output. This is useful with velocity control for example. The kF can get close to the target and a small kP and / or kI (and sometimes kD) can correct for error / changes in resistance.</p>"},{"location":"guide/programming/pid/#code-for-a-pid-controller","title":"Code for a PID Controller","text":"<p>The ArPiRobot Core Library includes a <code>PID</code> object. This object supports setting all four gains previously described, as well as a min and max output (defaulting to -1.0 and 1.0 respectively). The gains can be changed at any time.</p> <p>The <code>set_setpoint</code> / <code>setSetpoint</code> function is used to assign a setpoint for the PID controller. The <code>get_output</code> / <code>getOutput</code> function is used to calculate the current output. This function is passed the current sensor value as an argument and returns the output. For mathematical reasons, this function should be called at fairly regular intervals. As such, this makes <code>Action</code>s a good candidate to use PID objects. However, it is generally recommended to keep all PID object instances in the <code>Robot</code> class. This makes it easier to use the network table to help with tuning and allows multiple actions to reuse the same PID (without having to use the same gains in multiple places in the code).</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code>class PIDAction(Action):\n    # Assumes my_pid is defined as a member of Robot class\n    # Assumes tuning is somewhere in robot_started or elsewhere in Robot class\n    # For example, it could be hard coded during instantiation\n    # Ex: In Robot __init__\n    #       self.my_pid = PID(1.0, 0.0, 0.0)\n\n    def begin(self):\n        # Reset before each use (clears previous state info)\n        main.robot.my_pid.reset()\n\n        # Use the setpoint for this action\n        main.robot.my_pid.set_setpoint(setpoint_for_this_action)\n\n    def process(self):\n        # Get sensor value\n        current_pv = main.robot.sensor.get_value()\n\n        # Calculate output from PID\n        out = main.robot.my_pid.get_output(current_pv)\n\n        # Do something with PID output\n        # Maybe move motors\n\n    def finish(self, was_interrupted: bool):\n        # Stop any motors or anything the PID was moving\n        pass\n\n    def should_continue(self) -&gt; bool:\n        # Once setpoint is reached, stop\n        # Note: determining if setpoint is reached is not always trivial\n        #       due to possible oscillations\n        if pid_done:\n            return False\n        return True\n</code></pre> <pre><code>// Assumes myPid is defined as a member of Robot class\n// Assumes tuning is somewhere in robot_started or elsewhere in Robot class\n// For example, it could be hard coded during instantiation\n// Ex: In Robot class declaration\n//       PID myPid { 1.0, 0.0, 0.0 };\nclass PIDAction : public Action {\nprotected:\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n};\n</code></pre> <pre><code>void PIDAction::begin(){\n// Reset before each use (clears previous state info)\nMain::robot-&gt;myPid.reset();\n\n// Use the setpoint for this action\nMain::robot-&gt;myPid.setSetpoint(setpointForThisAction);\n}\n\nvoid PIDAction::process(){\n// Get sensor value\ndouble currentPv = Main::robot-&gt;sensor.getValue();\n\n// Calculate output from PID\ndouble out = Main::robot.myPid.getOutput(currentPv);\n\n// Do something with PID output\n// Maybe move motors\n}\n\nvoid PIDAction::finish(bool wasInterrupted){\n// Stop any motors or anything the PID was moving\n}\n\nbool PIDAction::shouldContinue(){\n// Once setpoint is reached, stop\n// Note: determining if setpoint is reached is not always trivial\n//       due to possible oscillations\nif(pidDone){\nreturn false;\n}\nreturn true;\n}\n</code></pre>"},{"location":"guide/programming/pid/#rotate-angle-action-using-pid","title":"Rotate Angle Action using PID","text":"<p>To improve the <code>RotateAngleAction</code> from the previous section, a PID can be used. This will help reduce overshooting the angle and will improve consistency of arriving at the correct angle after rotation actions complete.</p> <p>Before implementing the action, a rotation PID controller needs to be added to the <code>Robot</code> class.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add with other imports\nfrom arpirobot.core.control import PID\n\n# in Robot's __init__ function\n# Arguments: kp, ki, kd, kf, min, max\n# If arguments are omitted, they default to 0.0 for gains or -1.0 / 1.0 for min / max\n# min / max define range of PID controller's output values\n# -1.0 to 1.0 is used as this is the range of rotation speeds accepted by a drive helper\nself.rotate_pid = PID(1.0, 0.0, 0.0, 0.0, -1.0, 1.0)\n</code></pre> <pre><code>// Add with other includes\n#include &lt;arpirobot/core/control/PID.hpp&gt;\n\n// With other member variables in Robot class\n// Arguments: kp, ki, kd, kf, min, max\n// If arguments are omitted, they default to 0.0 for gains or -1.0 / 1.0 for min / max\n// min / max define range of PID controller's output values\n// -1.0 to 1.0 is used as this is the range of rotation speeds accepted by a drive helper\nPID rotatePid { 1.0, 0.0, 0.0, 0.0, -1.0, 1.0 };\n</code></pre> <p>The initial gains and output range for the PID controller are passed as arguments to the constructor, but they can all be changed later using set functions.</p> <p>An action to rotate using the PID controller can be implemented as shown below</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (actions.cpp`) <pre><code>class RotatePIDAction(Action):\n    def __init__(self, degrees: float):\n        super().__init__()\n\n        # Store the angle this action instance should rotate\n        self.degrees = degrees\n\n        # This will be used to detect when the robot has reached its target\n        self.correct_counter = 0\n\n\n    def begin(self):\n        # Reset correct counter to zero\n        self.correct_counter = 0\n\n        # Put motors in brake mode (often better for automated actions)\n        main.robot.flmotor.set_brake_mode(True)\n        main.robot.frmotor.set_brake_mode(True)\n        main.robot.rlmotor.set_brake_mode(True)\n        main.robot.rrmotor.set_brake_mode(True)\n\n        # Configure rotate PID controller for use\n        # Reset it to a clean state and set a new setpoint\n        # Setpoint is target angle, which is self.degrees away from where the robot is currently facing\n        main.robot.rotate_pid.reset()\n        main.robot.rotate_pid.set_setpoint(main.robot.imu.get_gyro_z() + self.degrees)\n\n    def process(self):\n        # Calculate the rotation speed using the PID\n        rot = main.robot.rotate_pid.get_output(main.robot.imu.get_gyro_z())\n\n        # Update the current rotation speed\n        # Note: it is possible that rotating the robot with positive power makes the IMU angle more negative\n        # If this is the case, the PID will rotate forever. To fix, use \"-rot\" instead of \"rot\" below\n        main.robot.drive_helper.update(0, rot)\n\n    def finish(self, was_interrupted: bool):\n        # Stop moving motors\n        main.robot.drive_helper.update(0, 0)\n\n    def should_continue(self) -&gt; bool:\n        # This action should stop when the robot has been \"close enough\" to the target angle for \"long enough\"\n        # For this action, allow within 3 degrees of target angle\n        # Require 10 iterations of being at the correct angle\n        # 10 iterations at 50ms between each iteration = 0.5 second\n        # Requiring the robot to be within 3 degrees of the correct angle for 0.5 seconds\n        # prevents the action from stopping if the robot is oscillating through the correct angle\n        angle_error = abs(main.robot.imu.get_gyro_z() - main.robot.rotate_pid.get_setpoint())\n\n        if angle_error &lt;= 3.0:\n            # Within 3 degrees. Angle is correct\n            self.correct_counter += 1\n        else:\n            # Not within 3 degrees. Reset correct counter\n            # Must be correct for 10 consecutive iterations before exit is valid\n            self.correct_counter = 0\n\n        # Stop if correct_counter is at least 10, therefore continue if less than 10\n        return self.correct_counter &lt; 10\n</code></pre> <pre><code>class RotatePIDAction : public Action {\npublic:\nRotatePIDAction(double degrees);\n\nprotected:\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\n// Store angle passed to action (angle to rotate)\ndouble degrees;\n\n// Used to detect when robot has reached its target\nint correctCounter = 0;\n};\n</code></pre> <pre><code>RotatePIDAction::RotatePIDAction(double degrees) : degrees(degrees){\n\n}\n\nvoid RotatePIDAction::begin(){\n// Reset correct counter to zero\ncorrectCounter = 0;\n\n// Put motors in brake mode (often better for automated actions)\nMain::robot-&gt;flmotor.setBrakeMode(true);\nMain::robot-&gt;frmotor.setBrakeMode(true);\nMain::robot-&gt;rlmotor.setBrakeMode(true);\nMain::robot-&gt;rrmotor.setBrakeMode(true);\n\n// Configure rotate PID controller for use\n// Reset it to a clean state and set a new setpoint\n// Setpoint is target angle, which is self.degrees away from where the robot is currently facing\nMain::robot-&gt;rotatePid.reset();\nMain::robot-&gt;rotatePid.setSetpoint(Main::robot-&gt;imu.getGyroZ() + degrees);\n}\n\nvoid RotatePIDAction::process(){\n// Calculate the rotation speed using the PID\ndouble rot = Main::robot-&gt;pid.get_output(Main::robot-&gt;imu.getGyroZ());\n\n// Update the current rotation speed\n// Note: it is possible that rotating the robot with positive power makes the IMU angle more negative\n// If this is the case, the PID will rotate forever. To fix, use \"-rot\" instead of \"rot\" below\nMain::robot-&gt;driveHelper.update(0, rot);\n}\n\nvoid RotatePIDAction::finish(){\n// Stop moving motors\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n\nbool RotatePIDAction::shouldContinue(){\n// This action should stop when the robot has been \"close enough\" to the target angle for \"long enough\"\n// For this action, allow within 3 degrees of target angle\n// Require 10 iterations of being at the correct angle\n// 10 iterations at 50ms between each iteration = 0.5 second\n// Requiring the robot to be within 3 degrees of the correct angle for 0.5 seconds\n// prevents the action from stopping if the robot is oscillating through the correct angle\ndouble angleError = std::abs(Main::robot-&gt;imu.getGyroZ() - Main::robot-&gt;rotatePid.getSetpoint());\n\nif(angleError &lt;= 3.0){\n// Within 3 degrees. Angle is correct\ncorrectCounter++;\n}else{\n// Not within 3 degrees. Reset correct counter\n// Must be correct for 10 consecutive iterations before exit is valid\ncorrectCounter = 0;\n}\n\n// Stop if correctCounter is at least 10, therefore continue if less than 10\nreturn correctCounter &lt; 10;\n}\n</code></pre> <p>To make tuning the PID easier, it is recommended to create an instance of the action that rotates 90 degrees and add a trigger to run this action when a button is pressed. This will allow testing just this one action while tuning.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code># In Robot class's __init__ method\nTEST_BTN = 2\n\n# In robot_started method\nActionManager.add_trigger(ButtonPressedTrigger(self.gp0, TEST_BTN, RotatePIDAction(90)))\n</code></pre> <pre><code>// Add with other constants (member variables)\nconst int ROTATE_TEST_BTN = 2;\n</code></pre> <pre><code>// In robotStarted method\nActionManager::addTrigger(std::make_shared&lt;ButtonPressedTrigger&gt;(gp0, ROTATE_TEST_BTN, std::make_shared&lt;RotatePIDAction&gt;(90)))\n</code></pre> <p>The PID is then ready to be tuned. It is advised to read the following section on tuning fully before tuning the PID if you are not familiar with tuning PID controllers. Additionally, if you wish to avoid having to rebuild / redeploy the robot program each time a gain is changed for the PID controller see the section on adding PID info to the Network Table below the tuning section.</p>"},{"location":"guide/programming/pid/#tuning-a-pid","title":"Tuning a PID","text":"<p>Tuning a PID is not a trivial process. The method described here is a basic \"guess and check\" method. There are mathematical methods of tuning, however a guess and check approach is often used in real world applications.</p> <p>To tune a PID, choose a reasonable setpoint. The setpoint should be realistic for the use of the PID controller, but large enough to \"see\" what is happening if possible. For the rotation example above, 90 degrees is a good setpoint to tune with.</p> <p>Generally, it is recommended to start with either only a kP (optionally with a kF). A kF is useful if the output should vary proportionally to the setpoint. For example, if the PID were to attempt to achieve a certain speed, the motor power (output of PID) would grow if speed grew. However, with rotation this is not the case (output of PID goes to motors, but a higher angle does not mean higher motor power forever).</p> <p>If no kF is used, start with kP = 1.0, kI = 0.0, and kD = 0.0. If a kF is used, use 0.1 as the initial kP value. Note that an initial kF value can be selected by applying an output power and measuring the sensor value. Then kF = sensor_measurement \u00f7 output_power. Note that for the rotate PID, no kF should be used.</p> <p>Once the initial values have been set, the following process is recommended for tuning.</p> <ul> <li>Multiply or divide by 10 for \"coarse\" tuning (larger changes)</li> <li>Multiply of divide by 2 for \"fine\" tuning (smaller changes)</li> <li>Finally, add and subtract small amounts for final tweaks.</li> </ul> <p>Tune parameters in the following order. Note that specific value recommendations are just guidelines, not rules that must be followed.</p> <ul> <li>Start with kP. If there is oscillation around the setpoint, reduce kP. If it never reaches the setpoint, increase kP. In a lot of cases with robotics, a small steady state error (slightly too small kP) is preferable to oscillation (slightly too large kP). Steady state error will be corrected with kI anyway.</li> <li>Then tune kI. Start with 1 / 1000 of kP or 0.000001 (whichever is smaller). If steady state error is too large (or is corrected for too slowly) increase kI. If oscillation occurs and prevents the robot from ever settling at the target decrease kI. Some oscillation is ok as long as the robot reaches its target eventually (oscillation needs to decay and die off).</li> <li>Finally tune kD. Start with 1 / 100 of kP or 0.0001 (whichever is smaller). If the oscillation is still too large, increase kD. If the robot behaves \"erratically\" decrease kD. Too large of a kD will cause unpredictable results. In many cases a kD of larger than 0.01 is a very bad idea.</li> </ul>"},{"location":"guide/programming/pid/#extra-adding-pid-info-gains-to-network-table","title":"Extra: Adding PID Info / Gains to Network Table","text":"<p>When tuning a PID it is often useful to be able to edit the gains (kp, ki, kd and sometimes kf) without changing the code. The NetworkTable makes this possible. Indicators can be created for each gain and changed from the drive station. Changes will affect the PID controller in realtime. Once a good set of values is determined, they can be coped into the code and the NetworkTable code can optionally be removed.</p> <p>The following example shows how to add controls for kp, ki, and kd, and kf for a PID controller in the <code>Robot</code> class called <code>pid</code>.</p> <p>Add the following function to your <code>Robot</code> class</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code>def pid_network_table(self, name: str, pid: PID):\n    # Create net table keys for the given name of the PID\n    KP_KEY = \"{0} kP\".format(name)\n    KI_KEY = \"{0} kI\".format(name)\n    KD_KEY = \"{0} kD\".format(name)\n    KF_KEY = \"{0} kF\".format(name)\n\n    # Add to network table if not already there\n    if not NetworkTable.has(KP_KEY):\n        NetworkTable.set(KP_KEY, str(pid.get_kp()))\n    if not NetworkTable.has(KI_KEY):\n        NetworkTable.set(KI_KEY, str(pid.get_ki()))\n    if not NetworkTable.has(KD_KEY):\n        NetworkTable.set(KD_KEY, str(pid.get_kd()))\n    if not NetworkTable.has(KF_KEY):\n        NetworkTable.set(KF_KEY, str(pid.get_kf()))\n\n    # If drive station edited a gain, update the pid object\n    # If the value entered in the drive station is not a valid number,\n    # the value will be discarded and reset to what the PID controller uses\n    if NetworkTable.changed(KP_KEY):\n        try:\n            pid.set_kp(float(NetworkTable.get(KP_KEY)))\n        except:\n            NetworkTable.set(KP_KEY, str(pid.get_kp()))\n    if NetworkTable.changed(KI_KEY):\n        try:\n            pid.set_ki(float(NetworkTable.get(KI_KEY)))\n        except:\n            NetworkTable.set(KI_KEY, str(pid.get_ki()))\n    if NetworkTable.changed(KD_KEY):\n        try:\n            pid.set_kd(float(NetworkTable.get(KD_KEY)))\n        except:\n            NetworkTable.set(KD_KEY, str(pid.get_kd()))\n    if NetworkTable.changed(KF_KEY):\n        try:\n            pid.set_kf(float(NetworkTable.get(KF_KEY)))\n        except:\n            NetworkTable.set(KF_KEY, str(pid.get_kf()))\n</code></pre> <pre><code>void pidNetworkTable(std::string name, PID &amp;pid);\n</code></pre> <pre><code>void Robot::pidNetworkTable(std::string name, PID &amp;pid){\n// Create net table keys for the given name of the pid\nauto KP_KEY = name + \" kP\";\nauto KI_KEY = name + \" kI\";\nauto KD_KEY = name + \" kD\";\nauto KF_KEY = name + \" kF\";\n\n// Add to network table if not already there\nif(!NetworkTable::has(KP_KEY)){\nNetworkTable::set(KP_KEY, std::to_string(pid.getKp()));\n}\nif(!NetworkTable::has(KI_KEY)){\nNetworkTable::set(KI_KEY, std::to_string(pid.getKi()));\n}\nif(!NetworkTable::has(KD_KEY)){\nNetworkTable::set(KD_KEY, std::to_string(pid.getKd()));\n}\nif(!NetworkTable::has(KF_KEY)){\nNetworkTable::set(KF_KEY, std::to_string(pid.getKf()));\n}\n\n// If drive station edited a gain, update the pid object\n// If the value entered in the drive station is not a valid number,\n// the value will be discarded and reset to what the PID controller uses\nif(NetworkTable::changed(ROTATE_KP_KEY)){\ntry{\nrotatePid.setKp(std::stod(NetworkTable::get(ROTATE_KP_KEY)));\n}catch(const std::invalid_argument &amp;e){\nNetworkTable::set(ROTATE_KP_KEY, std::to_string(rotatePid.getKp()));\n}\n}\nif(NetworkTable::changed(ROTATE_KI_KEY)){\ntry{\nrotatePid.setKi(std::stod(NetworkTable::get(ROTATE_KI_KEY)));\n}catch(const std::invalid_argument &amp;e){\nNetworkTable::set(ROTATE_KI_KEY, std::to_string(rotatePid.getKi()));\n}\n}\nif(NetworkTable::changed(ROTATE_KD_KEY)){\ntry{\nrotatePid.setKd(std::stod(NetworkTable::get(ROTATE_KD_KEY)));\n}catch(const std::invalid_argument &amp;e){\nNetworkTable::set(ROTATE_KD_KEY, std::to_string(rotatePid.getKd()));\n}\n}\n}\n</code></pre> <p>Then, for each PID you want on the NetworkTable, add a line like the following to the <code>Robot</code>'s <code>process</code> function. Make sure to use a unique name for each PID controller you add.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>self.pid_network_table(\"Rotate PID\", self.rotate_pid)\n</code></pre> <pre><code>pidNetworkTable(\"Rotate PID\", rotatePid);\n</code></pre> <p>When run, this will crate network table entries that can be used to edit PID gains while the code is running.</p>"},{"location":"guide/programming/sensoractions/","title":"Using Sensors with Actions","text":""},{"location":"guide/programming/sensoractions/#using-sensors-instead-of-time","title":"Using Sensors instead of Time","text":"<p>The previous section of this guide implemented <code>ActionSeries</code> that drove two shapes, a square and a triangle, using time-based drive actions. In reality, this time-based method of driving a distance or rotating to a certain angle is not ideal. There are many things that affect the relationship between time in motion and distance / angle reached including, battery level, the surface being driven on, and what robot is running the code. These factors make driving shapes using time, difficult and inconsistent.</p> <p>To improve this, sensor data will be used instead. Two types of sensors will be used in this section. First, a gyroscope will be used to determine what angle the robot is at relative to where it started. Second, encoders will be used to determine how many times the wheels have rotated, which can be used to determine how far the robot has driven.</p> <p>Code to use an <code>Mpu6050</code> sensor's IMU via an Arduino coprocessor was shown in the Sensor Data &amp; NetworkTable section of this guide. The following code can be added to use encoders (assumed to be single channel encoders, not quadrature encoders)</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code># Add with other imports\nfrom arpirobot.arduino.sensor import SingleEncoder\n\n# Create the devices in __init__\n# Assuming encoders are connected to pins 2 and 3 on the Arduino\n# Change if this is not the case\nself.lenc = SingleEncoder(2)\nself.renc = SingleEncoder(3)\n\n# In robot_started, before self.arduino.begin()\nself.arduino.add_device(self.lenc)\nself.arduino.add_device(self.renc)\n</code></pre> <pre><code>// Add with other includes\n#include &lt;arpirobot/arduino/sensor/SingleEncoder.hpp&gt;\n\n// Create devices with other member variables\n// Assuming encoders are connected to pins 2 and 3 on the Arduino\n// Change if this is not the case\nSingleEncoder lenc {2};\nSingleEncoder renc {3};\n</code></pre> <pre><code>// In robotStarted, before arduino.begin()\narduino.addDevice(lenc);\narduino.addDevice(renc);\n</code></pre>"},{"location":"guide/programming/sensoractions/#rotate-angle-action","title":"Rotate Angle Action","text":"<p>The following code implements an action that rotates a certain number of degrees from where it starts. This is done using the Z-Axis gyroscope on the robot.</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code>class RotateAngleAction(Action):\n    def __init__(self, degrees: float):\n        super().__init__()\n        self.degrees = degrees\n        self.target_angle = 0       # This will be set in begin()\n\n    def locked_devices(self) -&gt; LockedDeviceList:\n        # This needs to be the only action using motors while running\n        return [ main.robot.flmotor, main.robot.frmotor, \n            main.robot.rlmotor, main.robot.rrmotor ]\n\n    def begin(self):\n        # Calculate target angle\n        # Action should rotate self.degrees degrees from where robot is initially facing\n        self.target_angle = main.robot.imu.get_gyro_z() + self.degrees\n\n        # Use brake mode to reduce how much the robot continues rotating after the action stops\n        main.robot.flmotor.set_brake_mode(True)\n        main.robot.frmotor.set_brake_mode(True)\n        main.robot.rlmotor.set_brake_mode(True)\n        main.robot.rrmotor.set_brake_mode(True)\n\n        # Start rotating in the correct direction\n        # Note: It is assumed that positive rotation in the drive helper \n        #       results in positive change in IMU angle. If this is not the\n        #       case, swap the +0.9 and -0.9 in the if / else below.\n        #       If these signs are incorrect, the robot will rotate forever\n        #       as it never reaches its target angle.\n        if self.degrees &gt;= 0:\n            main.robot.drive_helper.update(0, 0.9)\n        else:\n            main.robot.drive_helper.update(0, -0.9)\n\n    def process(self):\n        # Nothing to do here. Just let it keep rotating.\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Stop rotating\n        main.robot.drive_helper.update(0, 0)\n\n    def should_continue(self) -&gt; bool:\n        if self.degrees &gt;= 0:\n            # Rotating in positive direction\n            # This means that the angle will be increasing\n            # Done rotating when angle is at greater than or equal to target\n            # If not done, should continue running (continue if less than target)\n            return main.robot.imu.get_gyro_z() &lt; self.target_angle\n        else:\n            # Rotating in negative direction\n            # This means that the angle will be decreasing\n            # Done rotating when angle is less than or equal to target\n            # If not done, should continue running (continue if greater than target)\n            return main.robot.imu.get_gyro_z() &gt; self.target_angle\n</code></pre> <pre><code>class RotateAngleAction : public Action{\npublic:\nRotateAngleAction(double degrees);\n\nprotected:\nLockedDeviceList lockedDevices() override;\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\ndouble degrees;\ndouble targetAngle = 0;     // Will be set in begin()\n};\n</code></pre> <pre><code>RotateAngleAction::RotateAngleAction(double degrees) : degrees(degrees){\n\n}\n\nLockedDeviceList RotateAngleAction::lockedDevices(){\n// This needs to be the only action using motors while running\nreturn { Main::robot-&gt;flmotor, Main::robot-&gt;frmotor, Main::robot-&gt;rlmotor, Main::robot-&gt;rrmotor };\n}\n\nvoid RotateAngleAction::begin(){\n// Calculate target angle\n// Action should rotate this-&gt;degrees degrees from where the robot is initially facing\ntargetAngle = degrees + Main::robot-&gt;imu.getGyroZ();\n\n// Use brake mode to reduce how much the robot continues rotating after the action stops\nMain::robot-&gt;flmotor.setBrakeMode(true);\nMain::robot-&gt;frmotor.setBrakeMode(true);\nMain::robot-&gt;rlmotor.setBrakeMode(true);\nMain::robot-&gt;rrmotor.setBrakeMode(true);\n\n// Start rotating in the correct direction\n// Note: It is assumed that positive rotation in the drive helper \n//       results in positive change in IMU angle. If this is not the\n//       case, swap the +0.9 and -0.9 in the if / else below.\n//       If these signs are incorrect, the robot will rotate forever\n//       as it never reaches its target angle.\nif(degrees &gt;= 0){\nMain::robot-&gt;driveHelper.update(0, 0.9);\n}else{\nMain::robot-&gt;driveHelper.update(0, -0.9);\n}\n}\n\nvoid RotateAngleAction::process(){\n// Nothing to do here. Just let it keep rotating.\n}\n\nvoid RotateAngleAction::finish(bool wasInterrupted){\n// Stop rotating\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n\nbool RotateAngleAction::shouldContinue(){\nif(degrees &gt;= 0){\n// Rotating in positive direction\n// This means that the angle will be increasing\n// Done rotating when angle is at greater than or equal to target\n// If not done, should continue running (continue if less than target)\nreturn Main::robot-&gt;imu.getGyroZ() &lt; targetAngle;\n}else{\n// Rotating in negative direction\n// This means that the angle will be decreasing\n// Done rotating when angle is less than or equal to target\n// If not done, should continue running (continue if greater than target)\nreturn Main::robot-&gt;imu.getGyroZ() &gt; targetAngle;\n}\n}\n</code></pre> <p>When the action starts, it calculates the target angle (the angle it should go to) which is a sum of the angle the robot starts at and the angle the action is supposed to rotate (passed as a constructor argument). The robot continues rotating at a constant speed until it reaches (or passes) this angle. The <code>should_continue</code> / <code>shouldContinue</code> function is used to stop the action once it has rotated far enough. Note that negative rotation is simply rotating in the opposite direction. As such, it is necessary to know which way the robot is rotating to determine if it has rotated far enough (hence the if statement in <code>should_continue</code> / <code>shouldContinue</code>).</p>"},{"location":"guide/programming/sensoractions/#drive-distance-action","title":"Drive Distance Action","text":"<p>A drive distance action can be implemented similarly. Since <code>SingleEncoders</code> are used, it is not possible to determine the direction the robot is moving using encoders, only how far it has moved (the encoder count will always be positive). In other words, rotating the wheel one revolution forward increases the encoder count and rotating the wheel one revolution backward increases the encoder count (no rotation decreases the encoder count). As such, to move in the negative direction, the motors move in reverse (negative speed), but the encoder count still grows. The action below is implemented to handle this. Note that if your robot has Quadrature encoders, this action will not work without modifications. You could either adapt this action to handle directions (similar to <code>RotateAngleAction</code> above), or use <code>SingleEncoder</code> objects in code instead of <code>QuadEncoder</code> objects (just pick one signal wire per encoder).</p> Python (<code>actions.py</code>)C++ (<code>actions.hpp</code>)C++ (<code>actions.cpp</code>) <pre><code>class DriveDistanceAction(Action):\n    def __init__(self, distance_ticks: int):\n        super().__init__()\n\n        # Absolute value of distance_ticks = distance to travel with no sign\n        self.distance_ticks = abs(distance_ticks)\n\n        # True if robot is moving forward (positive direction). Otherwise False.\n        self.forward = (distance_ticks &gt;= 0)\n\n    def locked_devices(self) -&gt; LockedDeviceList:\n        # This needs to be the only action using motors while running\n        return [ main.robot.flmotor, main.robot.frmotor, \n            main.robot.rlmotor, main.robot.rrmotor ]\n\n    def begin(self):\n        # Reset encoder counts to zero (starting from zero ticks)\n        main.robot.lenc.set_position(0)\n        main.robot.renc.set_position(0)\n\n        # Use brake mode to reduce how much the robot continues rotating after the action stops\n        main.robot.flmotor.set_brake_mode(True)\n        main.robot.frmotor.set_brake_mode(True)\n        main.robot.rlmotor.set_brake_mode(True)\n        main.robot.rrmotor.set_brake_mode(True)\n\n        # Move the robot in the correct direction\n        if(self.forward):\n            main.robot.drive_helper.update(0.8, 0)\n        else:\n            main.robot.drive_helper.update(-0.8, 0)\n\n\n    def process(self):\n        # Nothing to do here. Just let it keep driving.\n        pass\n\n    def finish(self, was_interrupted: bool):\n        # Stop driving\n        main.robot.drive_helper.update(0, 0)\n\n    def should_continue(self) -&gt; bool:\n        # Average the distance traveled by left and right encoders\n        # Treat this as the distance traveled\n        distance_traveled = (main.robot.lenc.get_position() + main.robot.renc.get_position()) / 2.0\n\n        # Continue if robot has not traveled far enough (distance traveled is less than target distance)\n        # Target distance = self.distance_ticks since initial position is always zero\n        return distance_traveled &lt; self.distance_ticks\n</code></pre> <pre><code>class DriveDistanceAction : pubic Action{\npublic:\nDriveDistanceAction(int distanceTicks);\n\nprotected:\nLockedDeviceList lockedDevices() override;\nvoid begin() override;\nvoid process() override;\nvoid finish(bool wasInterrupted) override;\nbool shouldContinue() override;\n\nprivate:\n\n// Set in constructor initializer list.\n// Always positive number = distance to travel without sign\nint distanceTicks;\n\n// Set in constructor initializer list\n// true if robot is moving forward (positive direction). Otherwise false.\nbool forward;\n};\n</code></pre> <pre><code>DriveDistanceAction::DriveDistanceAction(int distanceTicks) :\ndistanceTicks(std::abs(distanceTicks)), forward(distanceTicks &gt;= 0){\n\n}\n\nLockedDeviceList DriveDistanceAction::lockedDevices(){\n// This needs to be the only action using motors while running\nreturn { Main::robot-&gt;flmotor, Main::robot-&gt;frmotor, Main::robot-&gt;rlmotor, Main::robot-&gt;rrmotor };\n}\n\nvoid DriveDistanceAction::begin(){\n// Reset encoder counts to zero (starting from zero ticks)\nMain::robot-&gt;lenc.setPosition(0);\nMain::robot-&gt;renc.setPosition(0);\n\n// Use brake mode to reduce how much the robot continues rotating after the action stops\nMain::robot-&gt;flmotor.setBrakeMode(true);\nMain::robot-&gt;frmotor.setBrakeMode(true);\nMain::robot-&gt;rlmotor.setBrakeMode(true);\nMain::robot-&gt;rrmotor.setBrakeMode(true);\n\n// Move the robot in the correct direction\nif(forward){\nMain::robot-&gt;driveHelper.update(0.8, 0);\n}else{\nMain::robot-&gt;driveHelper.update(-0.8, 0);\n}\n}\n\nvoid DriveDistanceAction::process(){\n// Nothing to do here. Just let it keep driving.\n}\n\nvoid DriveDistanceAction::finish(bool wasInterrupted){\n// Stop driving\nMain::robot-&gt;driveHelper.update(0, 0);\n}\n\nbool DriveDistanceAction::shouldContinue(){\n// Average the distance traveled by left and right encoders\n// Treat this as distance traveled\nint distanceTraveled = (Main::robot-&gt;lenc.getPosition() + Main::robot-&gt;renc.getPosition()) / 2.0;\n\n// Continue if robot has not traveled far enough (distance traveled is less than target distance)\n// Target distance = this-&gt;distanceTicks since initial position is always zero\nreturn distanceTraveled &lt; distanceTicks;\n}\n</code></pre> <p>When the action starts, it resets encoder counts to zero. This makes detecting when the robot has driven far enough easy, as both encoders always start from zero. The robot will then begin driving (forward if distance given to the action in the constructor was positive, reverse if negative). The robot continues driving while the action is running. The <code>should_continue</code> / <code>shouldContinue</code> function is used to determine if the robot has driven far enough. If so, the function returns false stopping the action. The function uses both encoder values by averaging them to determine how far the robot has driven.</p>"},{"location":"guide/programming/sensoractions/#using-the-actions","title":"Using the Actions","text":"<p>The actions implemented above can be used to replace the \"drive square\" and \"drive triangle\" <code>ActionSeries</code> from the previous section of this guide. Time based rotations are replaced with angle-based rotations and time-based drives are replaced with distance-based drives. The only challenging part is determining how far to drive.</p> <p>The <code>DriveDistanceAction</code> drives a certain number of encoder \"ticks\" or \"counts\". An encoder \"tick\" (for a <code>SingleEncoder</code>) is any rising or falling edge of the signal. This means that for a typical optical encoder there will be twice as many \"ticks\" per wheel revolution as there are slots in the disk. For example, when using a standard 20-slot disk, there are 40 \"ticks\" per wheel revolution. Converting wheel revolutions into distance traveled (linear distance traveled by the robot) is also fairly simple. Each revolution, the robot drives a distance equal to the circumference of the wheel. The circumference of the wheel is pi (\u03c0 \u2248 3.14) times the diameter of the wheel. If using standard black and yellow TT motor wheels the diameter is 2.5 inches.</p> <p>The following equation can be used to calculate how many \"ticks\" should be used with the <code>DriveDistanceAction</code> to drive a given distance (note that distance and wheel_diameter must have the same unit). Always round to the nearest whole number.</p> <p> ticks = distance \u00f7 (\u03c0 \u00d7 wheel_diameter) \u00d7 ticks_per_revolution</p> <p>For example, to drive two feet (24 inches) with the encoder disk and wheels mentioned earlier:</p> <p> ticks = 24 \u00f7 (\u03c0 \u00d7 2.5) \u00d7 40</p> <p> ticks \u2248 122</p> <p>This number is used in the code below to implement the \"drive square\" and \"drive triangle\" <code>ActionSeries</code>.</p> <p>The following code can replace the same <code>ActionSeries</code> from the previous section to use the sensor-based actions instead of the time-based ones.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code>self.drive_square_series = ActionSeries(\n    # This is a list of actions to run sequentially\n    [\n        DriveDistanceAction(122),       # First edge\n        RotateAngleAction(90),          # Rotate 90\n\n        WaitAction(0.5),                # Delay before driving next edge\n\n        DriveDistanceAction(122),       # Second edge\n        RotateAngleAction(90),          # Rotate 90\n\n        WaitAction(0.5),                # Delay before driving next edge\n\n        DriveDistanceAction(122),       # Third edge\n        RotateAngleAction(90),          # Rotate 90\n\n        WaitAction(0.5),                # Delay before driving next edge\n\n        DriveDistanceAction(122),       # Fourth edge\n        RotateAngleAction(90),          # Rotate 90\n\n        WaitAction(0.1)                 # Small delay so brake mode has time to work\n\n    ],\n\n    # Start JSDriveAction instance when this action series finishes\n    self.js_drive_action\n)\nself.drive_triangle_series = ActionSeries(\n    # This is a list of actions to run sequentially\n    [\n        DriveDistanceAction(122),       # First edge\n        RotateAngleAction(120),         # Rotate 120\n\n        WaitAction(0.5),                # Delay before driving next edge\n\n        DriveDistanceAction(122),       # Second edge\n        RotateAngleAction(120),         # Rotate 120\n\n        WaitAction(0.5),                # Delay before driving next edge\n\n        DriveDistanceAction(122),       # Third edge\n        RotateAngleAction(120),         # Rotate 120\n\n        WaitAction(0.1)                 # Small delay so brake mode has time to work\n    ],\n\n    # Start JSDriveAction instance when this action series finishes\n    self.js_drive_action\n)\n</code></pre> <pre><code>ActionSeries driveSquareSeries{\n// This is a list of actions to run sequentially\n{\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // First edge\nstd::make_shared&lt;RotateAngleAction&gt;(90),        // Rotate 90\n\nstd::make_shared&lt;WaitAction&gt;(0.5),              // Delay before driving next edge\n\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // Second edge\nstd::make_shared&lt;RotateAngleAction&gt;(90),        // Rotate 90\n\nstd::make_shared&lt;WaitAction&gt;(0.5),              // Delay before driving next edge\n\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // Third edge\nstd::make_shared&lt;RotateAngleAction&gt;(90),        // Rotate 90\n\nstd::make_shared&lt;WaitAction&gt;(0.5),              // Delay before driving next edge\n\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // Fourth edge\nstd::make_shared&lt;RotateAngleAction&gt;(90),        // Rotate 90\n\nstd::make_shared&lt;WaitAction&gt;(0.1)               // Small delay so brake mode has time to work\n\n},\n\n// Start JSDriveAction instance when this action series finishes\njsDriveAction\n};\nActionSeries driveTriangleSeries {\n// This is a list of actions to run sequentially\n{\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // First edge\nstd::make_shared&lt;RotateAngleAction&gt;(120),       // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),              // Delay before driving next edge\n\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // Second edge\nstd::make_shared&lt;RotateAngleAction&gt;(120),       // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.5),              // Delay before driving next edge\n\nstd::make_shared&lt;DriveDistanceAction&gt;(122),     // Third edge\nstd::make_shared&lt;RotateAngleAction&gt;(120),       // Rotate 120 (adjust time as needed)\n\nstd::make_shared&lt;WaitAction&gt;(0.1)               // Small delay so brake mode has time to work\n},\n\n// Start JSDriveAction instance when this action series finishes\njsDriveAction\n};\n</code></pre> <p>Build and deploy the code. This should result in much more accurate and consistent shapes than the time-based method. </p> <p>Note: If your robot rotates forever at the first rotation, you probably need to swap the +0.9 and -0.9 in the <code>if</code> / <code>else</code> statement in <code>RotateAngleAction</code>'s <code>begin</code> function.</p>"},{"location":"guide/programming/sensoractions/#limitations","title":"Limitations","text":"<p>While better than the time-based method, this method of using sensor data still has some limitations. Most significantly, drive and rotate actions will often \"overshoot\" or go too far. This is because the robot does not stop until it reaches the target. Once it does attempt to stop, it will still continue moving for a short time (mostly due to momentum) before actually stopping. This often causes <code>DriveDistanceActions</code> to drive too far and <code>RotateAngleActions</code> to rotate too far. There are a few ways to address this, listed below.</p> <p>Note: Easiest solutions are listed at the top, but also are the least effective solutions. Solutions at the bottom are \"better\" but more complex to implement.</p> <ul> <li>Reduce distances and angles: The distances the robot drives and angles it rotates could be reduces to account for this. This is an easy \"fix\" however it is far from perfect. The amount of adjustment necessary will depend on the surface the robot is driving on, how weak the batteries are, motor characteristics, etc. In other words, it is inconsistent.</li> <li>Reduce speed as the robot gets close to its target: Instead of driving or rotating at a constant speed, the robot could slow down until it reaches its target. If the robot is moving slowly when it reaches its target, it will overshoot less. This solution has some challenges though. If the robot does not slow down enough, it will still overshoot. However, if the robot slows down too much, it may stop moving before reaching the target and get \"suck\". The is due to the fact that there will be some minimum amount of power necessary to make the robot rotate or drive. Below this power, the motors will be too \"weak\" to move the robot (and the motor becomes stalled, which is bad for the motors). Unfortunately, this \"minimum power\" varies with the surface, battery level, etc as described previously still leaving some inconsistency (although it's still better than the previous solution).</li> <li>PID control: A more proper fix would be to use a more complex controller to handle driving or rotating. A PID controller can be used to slow down as the robot approaches a target, but also has controls to compensate for steady state error (which is what that \"stalling\" before reaching the target is called in the previous example). While this would be the best solution (assuming the goal is to accurately and consistently reach the target) it has its own challenges. Primarily, the PID controller must be tuned for the specific use case. This is not a trivial process. As such (especially for beginners) this method may be impractical and other solutions (above two) may be good enough anyway. However, if one does want to use PID controllers one more problem remains: the single channel encoders. A PID controller for <code>DriveDistanceAction</code> would require detecting which direction the wheels are rotating. This would require quadrature encoders. The rotate action is easier to implement with a PID as the IMU can measure angle changes and in which direction (positive or negative). This is shown in the next section of the guide.</li> </ul>"},{"location":"guide/programming/sensordata/","title":"Sensor Data &amp; NetworkTable","text":"<p>Now that your robot can move around, it's time to add support for sensors. Sensors enable the robot to determine information about itself or the world around it. In this section, we will add support for measuring motor battery voltage, measuring distance to an object with an ultrasonic sensor, and measuring robot rotation using an IMU (gyroscope + accelerometer).</p>"},{"location":"guide/programming/sensordata/#arduino-interface-sensors","title":"Arduino Interface &amp; Sensors","text":"<p>Many sensors do not work well with the Raspberry Pi directly. In some cases the Pi may lack support for certain functions (such as analog readings) or in other cases a Pi may not provide fine enough control over timing (a big issue for something like a gyroscope). Often, a microcontroller is better suited to working with sensors. Arduinos are microcontroller development boards. Being a development board, it contains extra circuitry needed to program the device and make it easy to interface with. This makes an Arduino an ideal device to use on the robot as a sensor coprocessor. The Arduino manages the sensors and collects the required data and sends it back to the Raspberry Pi where it can be used in the robot program. The Arduino communicates with the Pi using a UART (a Serial port) over USB. This allows the Arduino to be connected to the Pi and powered from the Pi by a USB cable.</p>"},{"location":"guide/programming/sensordata/#arpirobot-arduino-firmware","title":"ArPiRobot Arduino Firmware","text":"<p>The ArPiRobot Arduino Firmware is a program written using the Arduino framework. This allows the firmware itself to support many different Arduino boards (and other microcontroller development boards too) using the same program. The source code for the firmware can be downloaded on the downloads page. To build the firmware and upload it to your board, you need to have the board and a USB cable to connect it to your computer. You also need to have the Arduino IDE installed. Once installed, open the program.</p> <p>Depending on your board you may also need to install a boards package to support your board in the Arduino IDE. Follow the instructions below for the board you are using. Note: This may not include instructions for every supported board. Check the README on the ArPiRobot Arduino Firmware GitHub repo for more information about supported boards.</p> Arduino Nano &amp; Clones <p>The Arduino Nano (and clones of the Arduino Nano) have support builtin to the Arduino IDE. Under the <code>Tools</code> menu change the board to \"Arduino Nano\" (under a category called <code>Arduino AVR Boards</code>). If you are using a clone (or an older nano) you probably need to change the <code>Processor</code> to <code>ATmega328P (Old Bootloader)</code>.</p> <p></p> Arduino Nano Every <p>The Arduino Nano Every is officially supported, but the <code>megaAVR</code> boards package must be installed first. Under <code>Tools &gt; Board</code> open <code>Board Manger...</code>. Search <code>megaAVR</code> and install the <code>Arduino megaAVR Boards</code> package (latest version). </p> <p></p> <p>Then, close the boards manager and select <code>Arduino Nano Every</code> under <code>Tools &gt; Board</code> (under the <code>Arduino megaAVR Boards</code> category).</p> <p></p> Raspberry Pi Pico <p>The Raspberry Pi Pico is supported by the ArPiRobot Arduino Firmware using the arduino-pico core, not the official Mbed OS core. Follow the install instructions for <code>arduino-pico</code>. Then choose <code>Raspberry Pi Pico</code> under <code>Tools &gt; Board</code> in the Arduino IDE. This will be under a category called <code>Raspberry Pi RP2040 Boards</code> not <code>Arduino Mbed OS RP2040 Boards</code>.</p> <p></p> <p>Once you've configured the correct board extract the source code you downloaded earlier to the <code>Arduino</code> folder that has been created in your <code>Documents</code> folder.</p> <p></p> <p>Then in the Arduino IDE click <code>File &gt; Open</code> and choose the extracted project. Open the <code>ArPiRobot-ArduinoFirmware.ino</code> file.</p> <p></p> <p>Next install the required libraries for the firmware. These can be installed using the library manager by selecting <code>Tools &gt; Manage Libraries...</code>. Search for and install the latest version of the <code>FastCRC</code> library.</p> <p>Then, plug in your Arduino using the USB cable. You should now have a port listed under <code>Tools &gt; Ports</code>. Select it (the number / name will likely not be the same as in the screenshot below).</p> <p></p> <p>Finally, to build and upload the firmware to your board click the upload button (the arrow) along the top bar.</p> <p></p>"},{"location":"guide/programming/sensordata/#connecting-sensors","title":"Connecting Sensors","text":"<p>Specific information about how each sensor must be connected and how connections can be made is located in the \"Building a Robot\" section of the guide.</p> <p>Now that the board is programmed, it is time to disconnect it from your computer. Connect it to the Pi on the robot by USB cable.</p> <p>The ArPiRobot Arduino Firmware is fairly simple and does not need to be modified before use. The firmware is built with support for various sensors, but it does not know how sensors are connected to the Arduino. This information is provided to the Arduino from the Pi by your robot program. As such, it is necessary to know what sensors are connected and how they are connected when writing the code for your sensors. In this section of the guide three sensors are used: a voltage monitor, an ultrasonic sensor, and an IMU (Inertial Measurement Unit) containing both a gyroscope (measures rotation) and an accelerometer (measures acceleration). The code is written assuming the sensors are connected to the Arduino as follows</p> <p>Voltage Monitor (Voltage Divider Module)</p> Voltage Monitor Pin Arduino Pin Use S A0 Voltage reading (S = signal; A0 = analog input 0). Any analog input could be used instead of A0. <p>Ultrasonic Sensor (HC-SR04)</p> Ultrasonic Sensor Pin Arduino Pin Use TRIG 7 TRIG = trigger pin. Arduino writes a pulse to this pin to start a distance measurement. Any digital input / output pin can be used. ECHO 8 ECHO = echo pin. Arduino reads a pulse back in response to the triggered pulse to measure distance. Any digital input / output pin can be used. <p>IMU (Mpu6050)</p> IMU PIN Arduino Pin Use SCL SCL I2C clock. SCL pin on Arduino may be shared with another pin depending on your board. Search for your board's pinout to determine which pin. SDA SDA I2C data. SDA pin on Arduino may be shared with another pin depending on your board. Search for your board's pinout to determine which pin. <p>The above information is provided to make clear the assumptions that were used when writing the code in the next section. You can change connections as desired, just make sure the connection is valid for the sensor and change the code appropriately.</p> <p>Likewise, if you are using a different supported IMU, you may need to change connections (tough at the time of writing this all supported IMUs are I2C devices and connected the same way) and you will need to change the code to use the correct device. </p> <p>For more information on each supported sensor see the Arduino Interface and Sensors section of the programming reference.</p>"},{"location":"guide/programming/sensordata/#the-robot-code","title":"The Robot Code","text":""},{"location":"guide/programming/sensordata/#creating-arduino-interface","title":"Creating Arduino Interface","text":"<p>An Arduino Interface is an object used in robot code to represent a board running the ArPiRobot Arduino Firmware connected to the Pi on the robot. Currently, only UART is supported as a connection method, therefore the <code>ArduinoUartInterface</code> class will be used.</p> <p>In order to setup UART communication with the Arduino two pieces of information are required: the name of the serial / UART of the device and the baud rate for UART communication. The baud rate must be the same on both the Arduino and the Pi. The ArPiRobot ArduinoFirmware uses a baud rate of <code>57600</code> (unless you modify it) so use this on the Pi as well. Determining which UART port is a little more difficult. In Windows serial ports are named <code>COM</code> followed by some number. On linux systems they are <code>/dev/tty[TYPE][NUMBER]</code>. For most Arduinos type will be <code>USB</code> (although it is <code>ACM</code> for some). Generally, since only one USB serial device will be connected to the Pi, the number will be <code>0</code> making the device <code>/dev/ttyUSB0</code>. This name will be used when creating the Arduino interface object as shown in the code below.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add with the other imports at the top of the file\nfrom arpirobot.arduino.iface import ArduinoUartInterface\n\n# Add in __init__ under the other devices\n# (below motors, drive helper, etc)\nself.arduino = ArduinoUartInterface(\"/dev/ttyUSB0\", 57600)\n</code></pre> <pre><code>// Add with the other includes at the top of the file\n#include &lt;arpirobot/arduino/iface/ArduinoUartInterface.hpp&gt;\n\n// Add below the other devices at the bottom of the class declaration\n// (below motors, drive helper, etc)\nArduinoUartInterface arduino { \"/dev/ttyUSB0\", 57600 };\n</code></pre> <p>Then, in <code>robot_started</code> / <code>robotStarted</code> add the following so the Pi begins communicating with the Arduino when your robot program starts.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Add at the end of robot_started\nself.arduino.begin()\n</code></pre> <pre><code>// Add at the end of robotStarted\narduino.begin();\n</code></pre> <p>Build and deploy the code to your robot. Look for some lines similar to the following in the robot program log (in Deploy Tool). This line will appear after the robot started message is logged.</p> <pre><code>[DEBUG]: ArduinoUartInterface(/dev/ttyUSB0, 57600) - Opened interface.\n[DEBUG]: ArduinoUartInterface(/dev/ttyUSB0, 57600) - Arduino is ready. Creating devices.\n[DEBUG]: ArduinoUartInterface(/dev/ttyUSB0, 57600) - Done creating devices. Starting sensor processing.\n[DEBUG]: ArduinoUartInterface(/dev/ttyUSB0, 57600) - Sensor processing started successfully.\n</code></pre> <p>If you instead see a message similar to the following, the uart port name is probably wrong. Try <code>/dev/ttyACM0</code>.</p> <pre><code>[ERROR]: ArduinoUartInterface(/dev/ttyUCB0, 57600) - Unable to open arduino interface.\n</code></pre>"},{"location":"guide/programming/sensordata/#creating-the-sensors","title":"Creating the Sensors","text":"<p>Now that your program has an Arudino Interface object, sensors can be added to it. Start by creating an object for each sensor as shown below</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add with other device imports at the top of file\nfrom arpirobot.arduino.sensor import VoltageMonitor, Ultrasonic4Pin, Mpu6050Imu\n\n# Add in __init__ below arduino interface creation\n\n# A0 is what pin signal (\"S\") is connected to\n# 30000, 7500 are resistor values used in the voltage divider module\nself.vmon = VoltageMonitor(\"A0\", 30000, 7500)\n\n# Arguments are trigger pin, echo pin\nself.usonic = Ultrasonic4Pin(7, 8)\n\n# No arguments for IMU\nself.imu = Mpu6050Imu()\n</code></pre> <pre><code>// Add with other device includes at top of file\n#include &lt;arpirobot/arduino/sensor/VoltageMonitor.hpp&gt;\n#include &lt;arpirobot/arduino/sensor/Ultrasonic4Pin.hpp&gt;\n#include &lt;arpirobot/arduino/sensor/Mpu6050Imu.hpp&gt;\n\n// Add in Robot class declaration below arduino interface creation\n\n// A0 is what pin signal (\"S\") is connected to\n// 30000, 7500 are resistor values used in the voltage divider module\nVoltageMonitor vmon {\"A0\", 30000, 7500};\n\n// Arguments are trigger pin, echo pin\nUltrasonic4Pin usonic {7, 8};\n\n// No arguments for IMU\nMpu6050Imu imu;\n</code></pre> <p>Then, in <code>robot_started</code> / <code>robotStarted</code> add each device to the arduino interface object before calling <code>arduino.begin</code>.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Add BEFORE self.arduino.begin() in robot_started\nself.arduino.add_device(self.vmon)\nself.arduino.add_device(self.usonic)\nself.arduino.add_device(self.imu)\n\n# self.arduino.begin() is HERE\n</code></pre> <pre><code>// Add BEFORE arduino.begin() in robotStarted\narduino.addDevice(vmon);\narduino.addDevice(usonic);\narduino.addDevice(imu);\n\n// arduino.begin() is HERE\n</code></pre> <p>If you build and deploy this code now, you should see messages indicating the devices are being created in the robot program log in the Deploy Tool (don't worry about the ID numbers).</p> <pre><code>[DEBUG]: VoltageMonitor(A0) - Created device with ID 0\n[DEBUG]: Ultrasonic4Pin(7, 8) - Created device with ID 1\n[DEBUG]: Mpu6050Imu - Created device with ID 2\n</code></pre> <p>If you don't see the output above you probably added the devices after running <code>begin</code>.</p>"},{"location":"guide/programming/sensordata/#getting-sensor-values","title":"Getting sensor values","text":"<p>Now your robot program has objects that can be used to get sensor data and the arduino has been setup and told what sensors are connected to it. As such, you can not get values from your sensors.</p> <p>The easiest sensor to start with is the voltage monitor. The voltage monitor should be wired into the motor batteries (usually AA batteries). In the Drive Station there is a battery indicator. This indicator is used to show the \"main\" battery voltage (in this case the voltage of the motor batteries). To make this show up, the voltage monitor object must be made the \"main\" voltage monitor. This can be done by adding the following line of code.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Add in robot_started AFTER self.arduino.begin\nself.vmon.make_main_vmon()\n</code></pre> <pre><code>// Add in robotStarted AFTER arduino.begin()\nvmon.makeMainVmon()\n</code></pre> <p>Only one voltage monitor can be the \"main\" voltage monitor. The \"main\" voltage monitor's voltage reading will be displayed in the drive station. If you build and deploy the program now, you should see the motor battery voltage when you open the drive station (after it connects to the robot program).</p> <p></p> <p>The battery indicator in the drive station will change colors based on the current battery voltage (red = dead, orange = low, yellow = medium, green = full). Don't worry if the voltage drops while quickly changing motor direction (this is expected). If the robot is still and the indicator is orange or red you probably want to replace the batteries.</p> <p>The ultrasonic sensor and IMU do not have any dedicated place in the drive station to show their values. So for now, they will be printed to the log. Add the following in <code>periodic</code></p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>Logger.log_info(\"Gyro: \" + str(self.imu.get_gyro_z()))\nLogger.log_info(\"Distance: \" + str(self.usonic.get_distance()))\n</code></pre> <pre><code>Logger::logInfo(\"Gyro: \" + std::to_string(imu.getGyroZ()));\nLogger::logInfo(\"Distance: \" + std::to_string(usonic.getDistance()));\n</code></pre> <p>If you build and deploy this code now you should see rapid log messages appearing in the Deploy Tool and Drive Station with sensor readings. While this does let you see the sensor values, it is often not useful because it adds so much information to the log.</p> <p>Generally, if you want to see a sensor value you only care about the current value. It is not necessary to save all old values by logging them. It is also inconvenient to read a rapidly scrolling log to determine sensors values. This is where the Network Table can help.</p>"},{"location":"guide/programming/sensordata/#network-table","title":"Network Table","text":"<p>The Network Table is a simple way of sharing data between the drive station and the robot. The network table holds a set of values. Each value is \"named\" with a unique \"key\". The key generally indicates what the value is showing. The value itself is often just a number. You can think of the network table as a set of \"variables\" shared between the drive station and the robot program. The \"key\" is the variable's name and special functions are used to set or get the variable's value.</p> <p>In our example above we could use two network table keys: - \"Gyro\" would be used to hold the current angle of the robot - \"Distance\" would be used to hold the current reading from the ultrasonic sensor</p> <p>To implement this, replace the log messages in <code>periodic</code> with the following</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Replace the log messages with the following\n# Set function takes two arguments key, value\n# Keys and values are always strings\nNetworkTable.set(\"Gyro\", str(self.imu.get_gyro_z()))\nNetworkTable.set(\"Distance\", str(self.usonic.get_distance()))\n</code></pre> <pre><code>// Replace the log messages with the following\n// Set function takes two arguments key, value\n// Keys and values are always strings\nNetworkTable::set(\"Gyro\", std::to_string(imu.get_gyro_z()));\nNetworkTable::set(\"Distance\", std::to_string(usonic.get_distance()));\n</code></pre> <p>If you build and deploy this code, you won't notice anything at first. The drive station will not automatically show network table values when connecting. Instead indicators must be added to show certain \"variables\". After the drive station connects to the robot, you can add an indicator using the <code>Network Table</code> &gt; <code>Add From Robot</code> menu. You should see both the <code>Gyro</code> and <code>Distance</code> keys there. Click one of them to add it. It will be added to the center of the Network Table section. You can drag it by its name to move it to a different location. It can also be resized by dragging corners with your mouse. Add both the <code>Gyro</code> and <code>Distance</code> indicators. Move them so you can see both at the same time.</p> <p></p> <p>As you move the robot you should see the gyro angle and ultrasonic distance changing in the indicators. Whenever your robot program runs the <code>NetworkTable</code>'s <code>set</code> function the value shown in the drive station will change. This makes it easy to determine current measurements and keeps your log from being filled up with sensor data messages.</p>"},{"location":"guide/programming/sensordata/#doing-something-useful","title":"Doing something Useful","text":"<p>While the above shows how to display sensor values, they have not really been used in the robot program to do anything useful yet. However, one simple task using sensors would be to prevent the robot from driving into an object (while moving forward). Since the ultrasonic sensor faces the front of the robot, it measures the distance to the nearest object in the front of the robot. If aimed straight ahead, this can be used to detect if the robot is about to run into something. When we detect this, we want to only allow the robot to rotate or drive backwards (negative speed), but prevent it from driving forward (positive speed). Additionally, when an object is detected too close, brake mode should be activated to stop the robot quickly enough to prevent it from running into the object, however when far enough away brake mode should be disabled. It should also be disabled if the robot is no longer moving toward the object.</p> <p>This might sound a little complicated, but it is not too bad. Breaking it down into simple steps that can be placed in <code>enabled_periodic</code> / <code>enabledPeriodic</code> - Get the speed and rotation amounts from the gamepad - If the robot sees an object \"too close\" and trying to drive forward (positive speed)     - Set speed to zero     - Enable brake mode - Else     - Enable coast mode and don't change speed - Use drive helper to update speed / rotation</p> <p>If we let 30 cm be the threshold for \"too close\" the code looks like the following</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code># Add to enabled_periodic between getting axis values and drive_helper.update\nif self.usonic.get_distance() &lt;= 30 and speed &gt; 0:\n    speed = 0\n    self.flmotor.set_brake_mode(True)\n    self.frmotor.set_brake_mode(True)\n    self.rlmotor.set_brake_mode(True)\n    self.rrmotor.set_brake_mode(True)\nelse:\n    self.flmotor.set_brake_mode(False)\n    self.frmotor.set_brake_mode(False)\n    self.rlmotor.set_brake_mode(False)\n    self.rrmotor.set_brake_mode(False)\n</code></pre> <pre><code>// Add to enabledPeriodic between getting axis values and driveHelper.update\nif(self.usonic.getDistance() &lt;= 30 &amp;&amp; speed &gt; 0){\nspeed = 0;\nflmotor.setBrakeMode(true);\nfrmotor.setBrakeMode(true);\nrlmotor.setBrakeMode(true);\nrrmotor.setBrakeMode(true);\n}else{\nflmotor.setBrakeMode(false);\nfrmotor.setBrakeMode(false);\nrlmotor.setBrakeMode(false);\nrrmotor.setBrakeMode(false);\n}\n</code></pre> <p>Test this code by slowly driving towards an object. Make sure the ultrasonic sensor is working by checking the Network Table indicator in the drive station. Once the distance is 30 or less, the robot should stop and no longer let you drive forward, but you sill still be able to rotate or drive in reverse. Once you are no longer within 30 cm of an object, you can drive forward again.</p> <p>The number 30 is arbitrarily chosen. You can (carefully) try driving your robot more quickly toward an object and see if it stops in time. If not, you may need to increase the distance higher than 30.</p>"},{"location":"guide/setup/setupcomputer/","title":"Setup your Development Computer","text":"<p>Before you can start programming or using ArPiRobots you will need to setup a few tools on the computer you plan to use to write code / work with the robot. This will be referred to as the \"development computer\". This is not the computer on the robot (Raspberry Pi, or other single board computers) which is referred to as the \"main computer\". </p> <p>Some of these tools are programming language specific, so it is good to choose which programming language(s) you plan to use first.</p>"},{"location":"guide/setup/setupcomputer/#choosing-a-programming-language","title":"Choosing a Programming Language","text":"<p>In general, it does not matter too much which language you use for robot code, as the same core library is used in all cases. Therefore, the biggest thing you should consider is familiarity with the language. If you're new to programming, it is recommended to use python as it is easy to learn and uses simpler syntax than many other languages.</p> <p>In addition to familiarity with the language you should consider the complexity of setting up to use the language. Programming the robot using C++ requires a cross compiler toolchain setup as well as other tools installed on your computer. In contrast, python is easier to setup requiring only a python interpreter on your computer.</p> <p>Finally, consider what your robot code will be doing. Most robot code is not performing computationally demanding tasks in user code. Generally, computationally demanding tasks are performed by the core library. In this case, there is minimal difference in performance between Python and C++. However, if computationally demanding code is needed in user code C++ will often perform better than Python due to Python's GIL.</p>"},{"location":"guide/setup/setupcomputer/#editor-development-environment","title":"Editor / Development Environment","text":"<p>In order to write code you will need a text editor or code editor installed on your system. While you can use any text editor or code editor it is generally recommended to use Visual Studio Code (VSCode). VSCode can run on Windows, macOS, or Linux systems and has extensions to support both Python and C++ development. Additionally, an ArPiRobot extension for VSCode exists that enables creation of robot projects.</p> <p>Visual Studio Code can be downloaded from https://code.visualstudio.com/. Once installed it is recommended to install the ArPiRobot extension. Currently, this extension is not on the VSCode marketplace so you will need to download it from the downloads page. The downloaded file will be a <code>.vsix</code> file. It can be installed by opening VSCode, navigating to the extensions panel (fourth item down on the left menu bar) and choosing <code>Install from VSIX...</code> in the menu in the top right of the extensions panel.</p> <p>Finally, it is recommended to install the following extensions (depending on which programming language you plan to use). These can be installed from the VSCode marketplace by searching in the extensions panel.</p> <p>C++ Programming: C/C++ Extension Pack (By Microsoft)</p> <p>Python Programming: Python Extension (By Microsoft)</p>"},{"location":"guide/setup/setupcomputer/#language-specific-tools","title":"Language-Specific Tools","text":"<p>Depending on the programming language you plan to use you will need to install certain tools on your computer.</p>"},{"location":"guide/setup/setupcomputer/#c","title":"C++","text":"<p>Cross Compiler Toolchain:</p> <p>C++ development requires you have a compiler, linker, and necessary C libraries to build code for a different system (a Raspberry Pi). This collection of software is called a toolchain. Since software is being built for a different system than you are building it on, this is called cross compilation. </p> <p>Prebuilt cross compiler toolchains for the Raspberry Pi are available to be downloaded from the ArPiRobot-Toolchain Releases page. Prebuilt toolchains are currently provided for Windows (64-bit), macOS (x86_64 = 64-bit Intel CPUs), and Linux (x86_64). For other systems, you can build a cross compiler toolchain yourself, but you might prefer to use Python to program robots instead. Building a cross compiler can be a complex task.</p> <p>A toolchain is intended to be used with a specific version of the Raspberry Pi OS (ArPiRobot images are modified versions of the Raspberry Pi OS). Each release of the Raspberry Pi OS is based on a version of debian, identified by the version's codename. For example, on the downloads page, if an image's RasPiOS version is listed as <code>2020-05-27-raspios-buster-lite</code>, the image is based on Raspberry Pi OS Buster. \"Buster\" is the codename. As such, you need a toolchain designed to target a Raspberry Pi OS Buster system. All prebuilt ArPiRobot toolchains are listed under a specific codename. While it may be possible to use an older toolchain (for example, using a RasPiOS 10 \"buster\" toolchain and running the program on RasPiOS 11 \"bullseye\"), it is generally not recommended.</p> <p>Alternatively, prebuilt toolchains can be downloaded from other sources. These toolchains have not been tested with the ArPiRobot project, but there is no reason they should not work. However, be aware that not all toolchains support the Pi Zero (<code>armv6</code> architecture). The ArPiRobot images are also 32-bit images, so a compiler targeting a 64-bit system will not work.</p> <ul> <li>SysProgs Toolchains (Windows Machine):  link<ul> <li>These are compatible with the Pi Zero</li> </ul> </li> <li>raspberry-pi-cross-compilers project (Linux Machine): link<ul> <li>There are multiple builds of each toolchain. Generally, use the same version of gcc as is installed on the Pi.</li> <li>When you download the toolchain, you will be taken to a sourceforge page with multiple folders. If you want the version with Pi zero support, choose that folder.</li> </ul> </li> </ul> <p>The ArPiRobot toolchain packages can be installed using the Deploy Tool. Other toolchains must be installed manually. The toolchain should be placed in <code>$HOME/.arpirobot/toolchain</code>. The <code>toolchain</code> directory should contain <code>bin</code>, <code>include</code>, <code>lib</code>, etc (they should not be in another subdirectory). With third party toolchains it may be necessary to run an installer or extract it elsewhere and copy the correct directories.</p> <p>CMake</p> <p>You will also need CMake installed. As usual, if using Linux or BSD you should be able to install this from the system repos. If using Windows or macOS, you can download an installer from cmake.org. Alternatively, the Homebrew package manager for macOS includes cmake and the scoop package manager for windows include cmake.</p> <p>GNU Make</p> <p>Make should be installed by default on macOS and Linux (if not use system packages). </p> <p>For windows, the easiest method is to use download from the ezwin32 project. This will download a zip file, not an installer. You need to extract the zip somewhere on your system and add the \"bin\" folder to your <code>PATH</code> environment variable. Alternatively, the scoop package manager for windows includes make and will automatically add it to your path.</p>"},{"location":"guide/setup/setupcomputer/#python","title":"Python","text":"<p>You will need to install Python on your PC. You can download python installers for windows and macOS from python.org. Generally, it is recommended to use a version of python that matches the first two numbers of the minimum version on the Pi (listed on the downloads page under the OS image section). For example, if the \"minimum python version\" is listed as <code>3.7</code> it is recommended to install a python <code>3.7.x</code> version (where <code>x</code> can be any number). Note that some images will have newer python versions (the specific python version on the robot depends on which main computer your robot uses).</p> <p>Alternatively, you can use the Homebrew package manger on macOS or the scoop package manager on windows to install specific versions of python.</p> <p>On Linux / BSD systems you should be able to install a recent version of python from the system repositories. You can use pyenv to build and install a specific version. On Ubuntu you can use the deadsnakes PPA to install specific versions of python.</p>"},{"location":"guide/setup/setupcomputer/#drive-station-and-deploy-tool","title":"Drive Station and Deploy Tool","text":"<p>Finally, there are two ArPiRobot specific tools that need to be installed. The Drive Station is used to connect to a program running on the robot and control the robot using a game controller. If you do not have a game controller that can be connected to your PC there is also a Mobile Drive station app for Android phones and tablets with a virtual gamepad.</p> <p>The Deploy Tool connects to the Raspberry Pi on the robot. The Deploy Tool is used to configure things such as WiFi networks and camera streaming, but most importantly it is used to deploy code from your computer to the robot with the click of a button.</p> <p>Windows</p> <p>Download the exe installers for both (see downloads page). Run the installer. The installer will create a start menu shortcut (and optionally a Desktop shortcut) as well.</p> <p>macOS</p> <p>Download the <code>.zip</code> macOS packages (see downloads page). Extract the zip files and move the resulting <code>.app</code> files to the <code>Applications</code> folder. Each app is unsigned, so when you first run it you will have to approve the app in System Preferences &gt; Security.</p> <p>Linux</p> <p>A <code>.deb</code> package has been provided for Ubuntu. It has generally been tested on the latest LTS release. While not guaranteed it should still work on other ubuntu releases or other distributions that use deb packages. If you have trouble with the <code>.deb</code> package or use a different distribution, a <code>.tar.gz</code> package is provided that should work on any linux distro (however, you must install python3 before using). If using the <code>.tar.gz</code> package run the <code>install.sh</code> script after extracting.</p> <p>Other</p> <p>The drive station and deploy tool are written in python and require python 3.6 or newer. In addition, several python packages are required (most notably <code>PySide6</code> and <code>PySDL2</code>). Download the zip of the repository (source code) and extract it on your system. Then install the required python packages (optionally in a virtual environment) by running <code>pip install -r requirements.txt</code> in the directory where you extracted the program. Then run the program with <code>python src/main.py</code>. Note that often one must replace <code>python</code> in the above commands with <code>python3</code>, but this is system dependent.</p>"},{"location":"guide/setup/setupcomputer/#arpirobot-corelib-update-package","title":"ArPiRobot CoreLib Update Package","text":"<p>Finally, it is necessary to download a CoreLib update package (see downloads page). The CoreLib update package contains a build of the ArPiRobot core library that can run on the robot along with other files needed when writing programs for the robot (in both C++ and Python). The same CoreLib update package is used for Python and C++. A CoreLib update package must be installed on your PC before deploying a program to the robot.</p> <p>To install the downloaded update package open the Deploy Tool (installed perviously) and select the \"This PC\" tab. Click the \"Install Update Package\" button and select the CoreLib update package that was downloaded.</p>"},{"location":"guide/setup/setuppi/","title":"Setup the Robot's Main Computer","text":"<p>Before using the robot, you need to setup the Main Computer (often a Raspberry Pi) with the custom ArPiRobot OS image. </p> <p>For most supported devices this just entails downloading an OS image and flashing it to an SD card. OS images for supported boards can be found on the downloads page.</p> <p>The ArPiRobot OS images are modified versions of operating system images for the board that include required software and proper configuration for use on an ArPiRobot robot.</p>"},{"location":"guide/setup/setuppi/#requirements","title":"Requirements","text":"<p>Before starting you will need a computer (laptop or desktop used for development)*, a supported Main Computer, a power supply for the main computer (this can be the battery pack used to power the computer on the robot).</p> <p>*The software used in this section (balenaEtcher) is available for Windows, macOS, and Linux computers. If using another OS you will need to find another program to write the image file to the SD Card.</p>"},{"location":"guide/setup/setuppi/#choosing-an-image","title":"Choosing an Image","text":"<p>It is always recommended to use the latest ArPiRobot image, available on the downloads page. Make sure to download the correct image for your main computer board. Also note that some images are distributed as multiple files (all parts must be downloaded).</p>"},{"location":"guide/setup/setuppi/#flash-the-image","title":"Flash the Image","text":"<p>WARNING: Flashing an image to the SD card will erase the entire contents of the SD card!</p> <p>The image must be written to a micro SD Card. To do so, we will use USBImager. Download and run it.</p> <p>Select the image file to write in the top box and select the SD card to write it to in the dropdown menu. Then click \"Write\" and wait for the process to finish.</p> <p></p> <p>When done, insert the SD Card in the your robot's main computer and power it on.  Wait for it to finish booting (about 30-60 seconds for most boards). The first boot will take longer than most as it will expand the root partition to fill the SD card then reboot.</p> <p>Once the main computer boots it will be generating a WiFi network called \"ArPiRobot-Robot\" with a default password of \"arpirobot123\". This network is how we will interface with the robot later. When working with the robot, keep in mind that there will be no internet access via this network, it is just used to communicate with the robot. While connected to the Pi's network you can open the deploy tool and connect it to the robot (by clicking the connect button in the deploy tool). There is a network settings tab in the deploy tool where you can change the robot's WiFi SSID and password (useful if you want multiple robots running at once or if you want a non-default password).</p>"},{"location":"ref/actionsystem/","title":"Action System","text":"<p>See the What is an Action Section of the \"Using Actions\" page of the \"Programming the Robot\" guide.</p>"},{"location":"ref/arduino/","title":"Arduino Sensor Coprocessor","text":"<p>A \"main computer\" on the robot (a single board computer running a Linux based operating system) is not well suited to interface with many types of sensors. However, low cost Arduino and Arduino compatible microcontroller development boards are.</p> <p>On ArPiRobot robots, an Arduino acts as a \"coprocessor\" that connects to and gets data from various sensors. It may also perform some calculations using the data. It then provides information from the sensors to the main computer of the robot.</p> <p>This is done by using the ArPiRobot Arduino Firmware (see downloads page). The firmware supports several Arduino compatible development boards (see the repository on GitHub for a list).</p>"},{"location":"ref/arduino/#arduinointerface","title":"ArduinoInterface","text":"<p>An <code>ArduinoInterface</code> object is used to connect to an Arduino coprocessor from an ArPiRobot program. Currently, it is only possible to connect to an Arduino coprocessor via UART (typically over a USB cable). This uses the <code>ArduinoUartInterface</code> object.</p>"},{"location":"ref/arduino/#creating-a-uart-interface-object","title":"Creating a UART Interface Object","text":"<p>An <code>ArduinoUartInterface</code> object can be created as shown below. The device requires two pieces of information: a port name and a baud rate. The name of the port is in the form <code>/dev/tty[TYPE][NUM]</code>. <code>[TYPE]</code> is typically either <code>USB</code> or <code>ACM</code> depending on which arduino is used. <code>NUM</code> will typically be <code>0</code>, being the first UART device of that type. The baud rate is a \"speed\" that must be the same on both devices. Unless you modified the ArPiRobot Arduino Firmware running on the coprocessor, this will be <code>57600</code>.</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>) <pre><code># Add with other imports\nfrom arpirobot.arduino.iface import ArduinoUartInterface\n\n# Add in __init__ of Robot class\nself.arduino = ArduinoUartInterface(\"/dev/ttyUSB0\", 57600)\n</code></pre> <pre><code>// Add with other includes\n#include &lt;arpirobot/arduino/iface/ArduinoUartInterface.hpp&gt;\n\n// Add with other member variables in Robot class\nArduinoUartInterface arduino { \"/dev/ttyUSB0\", 57600 };\n</code></pre>"},{"location":"ref/arduino/#adding-devices-to-the-interface","title":"Adding Devices to the Interface","text":"<p>Before the interface can be started, devices must be added to the interface. Various devices can be created and added to an interface (each is described in the \"Arduino Devices\" section below).</p> <p>The ArPiRobot framework relies on the main computer to tell the Arduino coprocessor what is connected to it. This means the Arduino firmware will not need to be modified, only a robot program. However, it is necessary to tell an arduino what is connected to it (by adding devices) before \"starting\" the arduino. The process shown below can be repeated for multiple devices on the same arduino interface. In the example below <code>DeviceClass</code> is a placeholder and should be replaced with the name of an actual device (described in \"Arduino Devices\" section).</p> Python (<code>robot.py</code>)C++ (<code>robot.hpp</code>)C++ (<code>robot.cpp</code>) <pre><code># Add with imports\nfrom arpirobot.arduino.sensor import DeviceClass\n\n# Add in __init__\nself.device = DeviceClass(deice_arg1, device_arg2, ...)\n\n# Add in robot_started\nself.arduino.add_device(self.device)\n</code></pre> <pre><code>// Add with includes\n#include &lt;arpirobot/arduino/sensor/DeviceClass.hpp&gt;\n\n// Add as a member variable\nDeviceClass device { deviceArg1, deviceArg2, ... };\n</code></pre> <pre><code>// Add in robotStarted\narduino.addDevice(device);\n</code></pre>"},{"location":"ref/arduino/#starting-the-interface","title":"Starting the Interface","text":"<p>Once all devices have been added, the arduino interface must be \"started\". When \"started\" the Arduino coprocessor will begin acquiring sensor data and performing required calculations. Once started, the Arduino coprocessor no longer accept new devices (<code>add_device</code> / <code>addDevice</code> on the interface) will have no effect. As such, the following line should be added in <code>robot_started</code> / <code>robotStarted</code> after all devices are added.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>self.arduino.begin()\n</code></pre> <pre><code>arduino.begin();\n</code></pre>"},{"location":"ref/arduino/#arduino-devices","title":"Arduino Devices","text":"<p>The following section lists information on each supported sensors for an arduino coprocessor. Each of these devices can be added to an Arduino Interface as described in the above section.</p>"},{"location":"ref/arduino/#voltagemonitor","title":"VoltageMonitor","text":"<p>This sensor supports reading a voltage using an analog pin on the Arduino. Typically, a voltage divider is also used to measure higher inputs than the Arduino's board voltage. This is often used to measure the voltage of the battery powering motors.</p> <p>Configuring this sensor requires the following information:</p> <ul> <li><code>pin</code>: The analog pin on the Arduino that the voltage should be read on. This can either be an integer (0, 1, 2, etc) or it can be a string prefixed with \"A\" (\"A0\", \"1\", \"A2\", etc). The prefix is ignored (meaning 0 is the same as \"A0\", 1 is the same as \"A1\", etc).</li> <li><code>vboard</code>: The \"board voltage\" of the Arduino coprocessor. This is either 3.3V or 5V. This can be measured with a voltmeter to get a more exact reading, or you can just enter either 3.3 or 5.0 depending on the board.</li> <li><code>r1</code>: The value of the \"top\" resistor of the voltage divider (if any)</li> <li><code>r2</code>: The value of the \"bottom\" resistor of the voltage divider (if any)</li> </ul> <p>Note that to use the <code>VoltageMonitor</code> device with no voltage divider (no <code>r1</code> or <code>r2</code>) you cannot set both to zero. <code>r2</code> cannot be zero. Instead, set <code>r1</code> to zero and <code>r2</code> to any non-zero positive number (eg one).</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import VoltageMonitor\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/VoltageMonitor.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#ultrasonic4pin","title":"Ultrasonic4Pin","text":"<p>This <code>ArduinoDevice</code> supports 4-pin ultrasonic rangefinder sensors. Note that 3-pin variants are not supported. The common 4-pin variants (eg HC-SR04) have a \"trigger\" and \"echo\" pin in addition to power and ground. Other devices with this type of pinout should be supported.</p> <p>Configuring this sensor requires the following information:</p> <ul> <li><code>trigger_pin</code>: What pin on the Arduino is connected to the sensor's trigger pin. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0.</li> <li><code>echo_pin</code>: What pin on the Arduino is connected to the sensor's echo pin. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0. It is highly recommended to use an interrupt enabled pin for the echo pin. Different Arduinos have different pins that support interrupts.</li> </ul> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import Ultrasonic4Pin\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/Ultrasonic4Pin.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#singleencoder","title":"SingleEncoder","text":"<p>This sensor supports any single channel digital encoder. A single channel encoder will have only one signal line. Such encoders are typically optical encoders (beam of light is interrupted by a slotted disk). This device supports measuring distance traveled and speed (without accounting for direction).</p> <p>Configuring this sensor requires the following information:</p> <ul> <li><code>pin</code>: The signal pin for the encoder. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0. It is highly recommended to use an interrupt enabled pin for SingleEncoder devices. Different Arduinos have different interrupt enabled pins.</li> <li><code>use_internal_pullup</code>: Some single channel encoders require the signal line have a pullup resistor. For such devices, set this to true to use the pullup builtin to the Arduino for that pin. This must be connected to a pin supporting a pullup resistor to have any effect. On most Arduinos, all pins support pullup resistors.</li> </ul> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import SingleEncoder\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/SingleEncoder.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#irreflectormodule","title":"IRReflectorModule","text":"<p>Supports infrared reflection detector modules (typically used for line followers). These modules include an IR led and an IR detector (photoresistor, photodiode, or phototransistor). Typically these include a comparator and tuning potentiometer to generate a digital \"detected\" / \"not detected\" signal. Some also give direct access to an analog signal.</p> <p>Configuring this sensor requires the following information:</p> <ul> <li><code>digital_pin</code>: What pin the digital signal from the comparator is connected to. This is typically labeled \"out\" or \"D0\" on the modules. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0.</li> <li><code>analog_pin</code>: What analog pin the analog signal from the sensor is connected to. This can either be an integer (0, 1, 2, etc) or it can be a string prefixed with \"A\" (\"A0\", \"1\", \"A2\", etc). The prefix is ignored (meaning 0 is the same as \"A0\", 1 is the same as \"A1\", etc).</li> </ul> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import IRReflectorModule\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/IRReflectorModule.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#oldadafruit9dof","title":"OldAdafruit9Dof","text":"<p>Image Credit: Adafruit</p> <p>Adafruit's now-discontinued 9-DOF IMU w/ the L3DG20H &amp; LSM303DLHC. Currently, the gyroscope and accelerometer are supported. The magnetometer is not currently supported.</p> <p>No configuration information is required for this sensor. However, only one sensor of this type is supported per Arduino coprocessor.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import OldAdafruit9Dof\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/OldAdafruit9Dof.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#nxpadafruit9dof","title":"NxpAdafruit9Dof","text":"<p>Image Credit: Adafruit</p> <p>Adafruit's NXP 9-DOF IMU w/ the FXOS8700 &amp; FXAS21002. Currently, the gyroscope and accelerometer are supported. The magnetometer is not currently supported.</p> <p>No configuration information is required for this sensor. However, only one sensor of this type is supported per Arduino coprocessor.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import NxpAdafruit9Dof\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/NxpAdafruit9Dof.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#mpu6050imu","title":"Mpu6050Imu","text":"<p>Image Credit: Adafruit</p> <p>MPU-6050 based IMUs such as Adafruit's Breakout. Both the gyroscope and accelerometer are supported. This IMU has no accelerometer.</p> <p>No configuration information is required for this sensor. However, only one sensor of this type is supported per Arduino coprocessor.</p> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import Mpu6050Imu\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/Mpu6050Imu.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#quadencoder","title":"QuadEncoder","text":"<p>This sensor supports any quadrature encoder. A quadrature channel encoder will have two signal lines. This device supports measuring displacement traveled and velocity (and is capable of distinguishing between directions).</p> <p>Configuring this sensor requires the following information:</p> <ul> <li><code>pin_a</code>: The A channel pin for the encoder. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0. It is highly recommended to use an interrupt enabled pin for QuadratureEncoder devices. Different Arduinos have different interrupt enabled pins.</li> <li><code>pin_b</code>: The B channel pin for the encoder. This can either be a number (0, 1, 2, etc) for a digital pin or a string prefixed with \"A\" if connected to one of the analog input pins (\"A0\", \"A1\", etc). Note that the analog pin will be used in digital mode thus \"A0\" is not the same as 0. It is highly recommended to use an interrupt enabled pin for QuadratureEncoder devices. Different Arduinos have different interrupt enabled pins.</li> <li><code>use_internal_pullup</code>: Some single channel encoders require the signal line have a pullup resistor. For such devices, set this to true to use the pullup builtin to the Arduino for that pin. This must be connected to a pin supporting a pullup resistor to have any effect. On most Arduinos, all pins support pullup resistors.</li> </ul> Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.arduino.sensor import QuadEncoder\n</code></pre> <pre><code>#include &lt;arpirobot/arduino/sensor/QuadEncoder.hpp&gt;\n</code></pre>"},{"location":"ref/arduino/#static-devices-in-arduino-firmware","title":"Static Devices in Arduino Firmware","text":"<p>Note: Most users will have no reason to use static devices. This is mostly useful for custom additions to the Arduino Firmware.</p> <p>In rare cases, it may be desirable to \"statically\" add devices in the Arduino Firmware itself (by modifying the firmware). A \"static\" device is one that is created in the Arduino Firmware and always exists. Such devices are assigned predetermined id numbers and are not created / configured by the robot program.</p> <p>In such cases, it is necessary that a corresponding device is added to the <code>ArduinoInterface</code> in the robot program with all the same configuration (arguments) as in the Arduino Firmware. However, the device must be added to the interface without creating a new device. Instead, the device must be given it's predetermined id number.</p> <p>To do this, there are two optional arguments for each Arduino Device. These options are at the end (after all configuration arguments for the sensor). The first argument is set to false to indicate that the arduino interface should not attempt to create the sensor. The second argument is the predetermine id number of the sensor.</p> PythonC++ <pre><code># Attach to static device with id 1\ndevice = DeviceClass(device_arg1, device_arg2, ..., False, 1)\n</code></pre> <pre><code>// Attach to static device with id 1\nDeviceClass device { deviceArg1, deviceArg2, ..., false, 1 };\n</code></pre> <p>After this, the device can be added to the interface as usual with <code>add_device</code> / <code>addDevice</code>.</p>"},{"location":"ref/baserobot/","title":"BaseRobot","text":"PythonC++ <pre><code>from arpirobot.core.robot import BaseRobot\n</code></pre> <pre><code>#include &lt;arpirobot/core/robot/BaseRobot.hpp&gt;\n</code></pre> <p><code>BaseRobot</code> is the foundation of any ArPiRobot program. Each program must have exactly one instance of a child class of <code>BaseRobot</code> (the child class is generally called <code>Robot</code>). The functions in this child class are used to define the robot's behavior.</p>"},{"location":"ref/baserobot/#overridden-functions","title":"Overridden Functions","text":"<p>The following functions must be overridden in the child class. These are run at different times and are used to define a robot's behavior. Their use will be explained in more detail later.</p> PythonC++ <pre><code>def robot_started(self):\n    pass\n\ndef robot_enabled(self):\n    pass\n\ndef robot_disabled(self):\n    pass\n\ndef enabled_periodic(self):\n    pass\n\ndef disabled_periodic(self):\n    pass\n\ndef periodic(self):\n    pass\n</code></pre> <pre><code>void robotStarted();\n\nvoid robotEnabled();\n\nvoid robotDisabled();\n\nvoid enabledPeriodic();\n\nvoid disabledPeriodic();\n\nvoid periodic();\n</code></pre> <p>There are two types of functions listed above. The <code>periodic</code> functions run once every x milliseconds. By default this is configured for 50 milliseconds. The other functions run when some specific event occurs.</p>"},{"location":"ref/baserobot/#robot-states","title":"Robot States","text":"<p>A robot has two basic states. The state is tracked by the underlying <code>BaseRobot</code> implementation. When stared, a robot is in the \"Disabled\" state. In this state the robot is unable to perform any \"potentially dangerous\" actions and will just sit idle. The other state is the \"Enabled\" state. In this state the robot is able to perform tasks.</p> <p>While disabled some devices will become disabled. For example, motor controllers will become disabled when the robot is disabled and become enabled when the robot is enabled. While a motor controller is disabled, it can be configured but is unable to move its motor. Once the robot is enabled (and the motor controller becomes enabled) the motor controller is able to move its motor.</p> <p>In addition to controlling the state of \"potentially dangerous\" devices, the state of the robot is useful for defining core robot functionality. Some of the functions listed above run only if the robot is in a specific state. Others run regardless of state. - <code>robot_started</code> / <code>robotStarted</code> runs when the robot program is started. This will always occur while the robot is disabled. This function will only ever run once. - <code>robot_enabled</code> / <code>robotEnabled</code> runs when the robot switches from the disabled state to the enabled state. - <code>robot_disabled</code> / <code>robotDisabled</code> runs when the robot switches from the enabled state to the disabled state. It also runs after <code>robot_started</code> / <code>robotStarted</code> runs when the program first starts (as the robot first becomes disabled on startup). - There are also three periodic functions. The generic <code>periodic</code> function will run regardless of state. The <code>enabled_periodic</code> / <code>enabledPeriodic</code> and <code>disabled_periodic</code> / <code>disabledPeriodic</code> functions run only in the corresponding state. - This makes <code>enabledPeriodic</code> a common location for the bulk of the robot program's logic (unless the Action system is used as it commonly is for more complex robot programs).</p> <p>Once a robot program is running its state is only able to be changed by the Drive Station. After the Drive Station connects to  a running robot program it is able to change the state of the program. The \"Enable\" and \"Disable\" buttons in the Drive Station UI send commands to the robot to change its state. Furthermore, if a drive station becomes disconnected the robot program will detect this and automatically disable itself. This behavior is not intended to be user modifiable, however if a fully autonomous robot is required it is trivial to implement a \"virtual Drive Station\" that connects to the robot program and sends an enabled command. This \"virtual Drive Station\" could even be part of the robot program itself. The network commination protocol is documented in the comments in the CoreLib's NetworkManager source files.</p>"},{"location":"ref/baserobot/#watchdog","title":"Watchdog","text":"<p>In addition to robot states there is one more feature to ensure safe operation of the robot, the watchdog. The watchdog is used to automatically disable \"potentially dangerous\" devices if the robot program is frozen or running too slowly to safely manage devices.</p> <p>If the watchdog is not \"fed\" for 500* milliseconds, all \"potentially dangerous\" devices become disabled. They will be automatically re-enabled when the watchdog is next \"fed\".</p> <p>This helps avoid scenarios where the CPU is overloaded and the robot is unable to respond to inputs in time to avoid bad scenarios. Additionally, if user code ever causes the robot program to freeze (eg infinite loops) this ensures the motors will be able to be stopped without relaunching the robot program to take control back of the motors.</p> <p>*This duration can be configured in the <code>RobotProfile</code></p> <p>The watchdog should be fed in the <code>periodic</code> function by calling the <code>feed_watchdog</code> / <code>feedWatchdog</code> function (member of <code>BaseRobot</code>). </p> <p>The <code>periodic</code> functions are run by an internal scheduler thread pool, the same thread pool which runs user code such as actions. Feeding the watchdog in <code>periodic</code> ensures that if user code ever slows down the program too much (which also slows down <code>periodic</code>) devices are disabled. Note that the watchdog is not run on the scheduler and thus is not directly able to be delayed by user code. The watchdog runs on the program's main thread in an infinite loop with a sleep to keep CPU usage from being too high. This sleep is short enough, however, that the task should not be slowed down too much by kernel scheduling.</p>"},{"location":"ref/baserobot/#robotprofile","title":"RobotProfile","text":"PythonC++ <pre><code>from arpirobot.core.robot import RobotProfile\n</code></pre> <pre><code>#include &lt;arpirobot/core/robot/RobotProfile.hpp&gt;\n</code></pre> <p>The <code>RobotProfile</code> is a class containing only static members. The variables are used to configure various settings about how the robot is run including:</p> <ul> <li>How many threads are in the main scheduler's thread pool (used for running actions, periodic functions, etc). Defaults to 10.</li> <li>How frequently periodic functions should run (in milliseconds). Defaults to 50.</li> <li>How old gamepad data is allowed to be (in milliseconds). Data older than this age will be discarded (this prevents scenarios where network slowdowns prevent the robot from being controllable). Defaults to 100.</li> <li>How frequently action's periodic functions are run (in milliseconds). Defaults to 50.</li> <li>Duration before BaseRobot watchdog disables motors and other devices (in milliseconds). Defaults to 500.</li> <li>Which IO provider is used when the program runs. An IO provider is an underlying library which allows using GPIO pins and communication busses. Which ones are available / used by default is platform specific. Setting this to an empty string will use the default provider for the platform.</li> </ul> <p>Any variables in <code>RobotProfile</code> must be modified before the <code>BaseRobot</code> instance is started. In a typical project, this means that variables must either be changed in the <code>main</code> source file (before it calls start on the <code>Robot</code> class instance) or they must be changed in the constructor of the <code>Robot</code> class (where <code>Robot</code> is the class derived from <code>BaseRobot</code>).</p>"},{"location":"ref/devices/","title":"Devices","text":"<p>A device is an object in code that represents any component on the robot that is directly controlled or used by the robot program. This includes motor controllers, gamepads, sensors, coprocessors, and generic digital input / output devices.</p>"},{"location":"ref/devices/#basedevice","title":"BaseDevice","text":"PythonC++ <pre><code>from arpirobot.core.device import BaseDevice\n</code></pre> <pre><code>#include &lt;arpirobot/core/device/BaseDevice.hpp&gt;\n</code></pre> <p><code>BaseDevice</code> is the base class upon which all devices are based. Most functions in this device are not intended to be called on device instances. Rather, they are used when implementing a new device object.</p> <p>When implementing a device the following functions must be implemented (note that devices cannot be implemented via python bindings, and must be implemented in C++).</p> C++ <pre><code>void begin(){\n// Run when the device is ready to be started\n// This will occur just before robot_started / robotStart is run, \n// but after calling start() on the BaseRobot child class instance\n// This is where communication with the device should be started\n// Note that a custom destructor should be used to \"stop\" a device and close communication with the device\n}\n\nbool isEnabled(){\n// Must return true if the device is enabled\n// Each device must track this itself.\n// Typically a variable set in enable() / disable() is sufficient\n}\n\nbool shouldMatchRobotState(){\n// Return true if this device should be disabled when the robot becomes disabled\n// If this device is \"potentially dangerous\" it should not be allowed to run when the robot is disabled\n// Thus return true for \"potentially dangerous\" devices\n}\n\nbool shouldDisableWithWatchdog(){\n// Return true if this device should be disabled by the watchdog\n// If this device is \"potentially dangerous\" it should not be disabled by the watchdog\n// Thus return true for \"potentially dangerous\" devices\n}\n\nvoid enable(){\n// Do anything necessary to enable the device\n}\n\nvoid disable(){\n// Do anything necessary to disable the device\n// This should return the device to a \"safe\" state\n}\n\nstd::string getDeviceName(){\n// Should return the name of this device\n// This should closely match the constructor of the class\n// For example, if the device is for Sensor A (with a class name SensorA)\n// This would return \"SensorA()\"\n// If the class takes arguments (pin numbers, addresses, etc) these should be included in the name\n// For example, if the sensor has one pin\n// return \"SensorA(\" + std::to_string(pin) + \")\";\n}\n</code></pre>"},{"location":"ref/devices/#motorcontroller","title":"MotorController","text":"PythonC++ <pre><code>from arpirobot.core.device import MotorController\n</code></pre> <pre><code>#include &lt;arpirobot/core/device/MotorController.hpp&gt;\n</code></pre> <p><code>MotorController</code> is a base class for motor controller devices. It cannot be instantiated directly, but serves as a base class for all motor controllers. This ensures that all motor controllers have the same function set available (making them easily interchangeable in code). It also abstracts some of the underlying functions of <code>BaseDevice</code> to make implementing a motor controller object easier.</p> <p>The following function set must be implemented for any motor controller</p> C++ <pre><code>void begin(){\n// Just like BaseDevice::begin\n// Setup communication with the device so it is ready to use\n}\n\nvoid run(){\n// This function is run when the motor's speed should be changed\n// This needs to use the internal \"speed\" variable and \n// \"brakeMode\" variable to determine what the motor should be doing\n}\n\nvoid close(){\n// Stop the motor (zero speed) and close communication\n// It is important to stop the device here as the code\n// will loose control of it afterwards (most motor controller continue latest motion when communication closed)\n}\n</code></pre>"},{"location":"ref/devices/#device-objects","title":"Device Objects","text":"<p>If you are using supported components there will be no need to implement custom devices. The CoreLib provides code for supported devices in the following locations (where \"DEVICE\" is replaced with a specific device package and name).</p> PythonC++ <pre><code>from arpirobot.devices.DEVICE import DEVICE\n</code></pre> <pre><code>#include &lt;arpirobot/devices/DEVICE/DEVICE.hpp&gt;\n</code></pre> <p>See Python source or C++ source for a full list of devices.</p>"},{"location":"ref/devices/#using-devices","title":"Using Devices","text":"<p>Devices should generally be public members of the <code>BaseRobot</code> child class that will be instantiated. This allows other objects, such as actions, to access the devices too. Keeping them member variables preserves a logical organization where devices are parts of the robot.</p> <p>While devices should be instantiated in the constructor* of the <code>Robot</code> class (<code>BaseRobot</code> child) they should not be configured until <code>robot_started</code> / <code>robotStarted</code>.</p> <p>*Or using initializer lists / inline initialization in C++.</p>"},{"location":"ref/nettable/","title":"Network Table","text":"<p>The network table is a way of transferring information between a running robot program and the Drive Station. The network table can be thought of as a set of values shared between the Drive Station and robot program. </p>"},{"location":"ref/nettable/#network-table-key-value-pairs","title":"Network Table Key / Value Pairs","text":"<p>The network table is a collection of key / value pairs. Both keys and values are strings only. Other data types are not supported. A key is a unique identifier. Each key has a value associated with it. In some sense, a key is like a \"name\" of a \"variable\" in the network  table. Each key has an associated value. Multiple keys can have the same value.</p> <p>This creates a \"table\" like structure. For example, </p> NetTable Key NetTable Value speed 90 direction -1 action drive <p>Each key's value can be written (set) or read (get) by either the robot program or the Drive Station. Changes on one side are sent to the other side (thus values on the network table are kept in sync).</p>"},{"location":"ref/nettable/#network-table-sync","title":"Network Table Sync","text":"<p>Before the Drive Station connects to the robot program, the Network Table will be out of sync. It is possible for both the robot and the Drive Station to have key / value pairs before connecting. When connecting the following actions are performed (in this order):</p> <ul> <li>The robot program sends all key / value pairs to the Drive Station</li> <li>The Drive Station updates its network table with the data it received from the robot</li> <li>For any keys the Drive Station has that the robot did not (keys that did not get sent previously) the Drive Station will send this set of keys to the robot.</li> <li>The robot will update its network table with the data it received from the robot.</li> </ul> <p>In effect, this is a \"merge\" of the two network tables when a Drive Station connects. If both the robot program and the Drive Station have a key, the robot program's value is kept.</p>"},{"location":"ref/nettable/#network-table-functions","title":"Network Table Functions","text":"<p>This set of functions is used in a robot program to manipulate the network table. For information on using the Network Table from the Drive Station, see the Drive Station Manual or the Mobile Drive Station Manual.</p> <p>The <code>ArPiRobot CoreLib</code> includes a <code>NetworkTable</code> class with several static functions to manipulate or access the network table.</p> PythonC++ <pre><code>from arpirobot.core.network import NetworkTable\n</code></pre> <pre><code>#include &lt;arpirobot/core/network/NetworkTable.hpp&gt;\n</code></pre> <p>The <code>NetworkTable</code> class includes the following functions</p> <ul> <li><code>set(key, value)</code>: Sets the given key / value pair. If the key did not previously exist, it will be crated (and initialized with the provided value). Both <code>key</code> and <code>value</code> are strings.</li> <li><code>get(key)</code>: Gets the current value of a given key. This function returns the value (a string). If the requested key does not exist, it returns an empty string (<code>\"\"</code>).</li> <li><code>has(key)</code>: Checks if the network table has a value for the given key. Return a boolean (true / false) indicating if the network table has the given key.</li> <li><code>changed(key)</code>: Checks if the given key's value was changed by the drive station since the last time <code>get</code> was called for that key. This will not return true if the robot changes the key's value (ie <code>set</code> is called).</li> </ul>"},{"location":"ref/nettable/#example-robot-program","title":"Example Robot Program","text":"Python (<code>robot.py</code>)C++ (<code>robot.cpp</code>) <pre><code>from arpirobot.core.robot import BaseRobot\nfrom arpirobot.core.network import NetworkTable\nfrom arpirobot.core.log import Logger\n\n\nclass Robot(BaseRobot):\n    def __init__(self):\n        super().__init__()\n\n    def robot_started(self):\n        NetworkTable.set(\"test1\", \"\")\n        NetworkTable.set(\"test2\", \"\")\n\n    def robot_enabled(self):\n        NetworkTable.set(\"test1\", \"enabled\")\n\n    def robot_disabled(self):\n        NetworkTable.set(\"test1\", \"disabled\")\n\n    def enabled_periodic(self):\n        pass\n\n    def disabled_periodic(self):\n        pass\n\n    def periodic(self):\n        if NetworkTable.changed(\"test2\"):\n            Logger.log_info(\"DS changed test2 to '{}'\".format(NetworkTable.get(\"test2\")))\n        self.feed_watchdog()\n</code></pre> <pre><code>#include &lt;robot.hpp&gt;\n\n#include &lt;arpirobot/core/log/Logger.hpp&gt;\n#include &lt;arpirobot/core/action/ActionManager.hpp&gt;\n#include &lt;arpirobot/core/network/NetworkTable.hpp&gt;\n\nusing namespace arpirobot;\n\n\nvoid Robot::robotStarted(){\nNetworkTable::set(\"test1\", \"\");\nNetworkTable::set(\"test2\", \"\");\n}\n\nvoid Robot::robotEnabled(){\nNetworkTable::set(\"test1\", \"enabled\");\n}\n\nvoid Robot::robotDisabled(){\nNetworkTable::set(\"test1\", \"disabled\");\n}\n\nvoid Robot::enabledPeriodic(){\n\n}\n\nvoid Robot::disabledPeriodic(){\n\n}\n\nvoid Robot::periodic(){\nif(NetworkTable::changed(\"test2\")){\nLogger::logInfo(\"DS changed test2 to '\" + NetworkTable::get(\"test2\") + \"'\");\n}\nfeedWatchdog();\n}\n</code></pre>"},{"location":"ref/projectstructure/","title":"Project Structure","text":""},{"location":"ref/projectstructure/#files-and-organization","title":"Files and Organization","text":"<p>Each ArPiRobot program has a file <code>arpirobot-proj.json</code>. This file is used by the deploy tool to determine which files to deploy to the robot. While the contents of this file will differ based on the programming language used, this file will be present for a project using any language. Typically, this file does not need to be edited.</p> <p>Additionally, there is a <code>main.sh</code> file that defines how the robot should run the program once it is deployed. This file should almost never be edited and is present for any language (again, its contents depend on the language). </p> <p>The other files present in the project depend on the language used by the project.</p> PythonC++ <p>A python project is very simple and includes only source files. These are located in a directory named <code>src</code>. By default a project will have three source files <code>robot.py</code>, <code>actions.py</code>, and <code>main.py</code>. <code>main.py</code> generally should not be edited as it determines what to do when the program is run. The use of the other two files is described in more detail below.</p> <p>A C++ project includes more than just source files. </p> <p>In addition to the code of the project, files for the cmake build system are included. This is mainly just <code>CMakeLists.txt</code> which defines how to compile the robot program. Additionally, there is a file named <code>arpirobot-cross.cmake</code> which is used to help cmake fine the cross compiler for the raspberry pi. Neither of these files should generally be edited.</p> <p>Aside from the build system there are two folders: <code>include</code> and <code>src</code>. The <code>include</code> folder contains header files and <code>src</code> contains source files. Headers are <code>.hpp</code> files and sources are <code>.cpp</code> files. There is a source and header file for each of <code>main</code>, <code>robot</code> and <code>actions</code>. Their uses are detail in more detail below.</p>"},{"location":"ref/projectstructure/#manually-creating-a-project","title":"Manually Creating a Project","text":"<p>If you are not using VSCode you can still create a project. It is recommended to duplicate the structure of the projects generated by the VSCode extension. This can be done by downloading / referencing the templates used by the extension located here</p>"},{"location":"ref/projectstructure/#use-of-each-source-file","title":"Use of Each Source File","text":"<p>By default, a project has three source files (and also three corresponding headers in a C++ project).</p>"},{"location":"ref/projectstructure/#main","title":"Main","text":"<p>The <code>main</code> source file is used to start the robot program defined by the other source files when the program is run. This file should generally not be edited.</p> <p>The <code>robot</code> source file contains the <code>Robot</code> class definition. This class is a child class of <code>BaseRobot</code> and defines the core behavior of the robot program, as well as the components that make up the robot. Any device instances should be created in the <code>Robot</code> class.</p> <p>The <code>actions</code> source file is generally used to define custom actions (classes that inherit from <code>Action</code>). Typically, any action used in a robot program is defined in this source file. Actions use the devices in the <code>Robot</code> class and the <code>Robot</code> class controls which action(s) run at any given time.</p>"},{"location":"ref/manuals/android_drive_station/","title":"Mobile Drive Station Manual","text":"<p>There is currently no iOS version of the Mobile Drive Station available. An Android phone or tablet is required.</p> <p>The mobile version of the Drive Station performs the same basic function: allowing you to control the robot, however it was created to allow you to control the robot without the use of a gamepad. The Mobile Drive Station includes an on-screen virtual gamepad which is used to control the robot.</p> <p>Currently the Mobile Drive Station lacks some of the features present in the PC Drive Station such as editing key/value pairs on the network table and using multiple gamepads, however it does work for basic control of the robot.</p>"},{"location":"ref/manuals/android_drive_station/#uses-features","title":"Uses / Features","text":"<ul> <li>Connect to a running robot program over the Raspberry Pi's WiFi network</li> <li>Enable and Disable the robot</li> <li>Show the status (enabled / disabled) of the robot</li> <li>Use the on-screen virtual gamepad to control the robot</li> <li>Show logs sent from the robot after connecting the Mobile Drive Station</li> <li>Show the value of NetworkTable key / value pairs form the robot</li> </ul>"},{"location":"ref/manuals/android_drive_station/#installing","title":"Installing","text":"<p>To install the Mobile Drive Station you will need an Android Device running Android KitKat (version 4.4) or newer. You can download the APK file (see the downloads page) to install on your device. You will need to download this on the device you want to install it on. Then open the file. You will need to enable installing from \"Unknown Sources\" (meaning not the Play Store) in your settings first. Once installed you can find the app in your device's app drawer.</p>"},{"location":"ref/manuals/android_drive_station/#connecting-to-the-robot","title":"Connecting to the Robot","text":"<p>Before attempting to connect to the robot you will need to make sure your device is connected to the WiFi network created by the robot. You will also generally need to make sure you are disconnected from other networks (including mobile data connections). Your device may notify you that there is no internet access and ask if you want to stay connected to the robot's WiFi network. If this happens choose to stay connected.</p> <p>The connect button is the left-most button located along the ActionBar at the top of the app. Tap it to connect to the robot. Once connected this button will become a disconnect button which can be tapped again to disconnect from the robot. If the connect button is not visible check under the three-dots menu in the top right.</p> <p>Only one Drive Station can be connected to the robot at a time (this includes PC Drive Stations and Mobile Drive Stations).</p> <p>If you are not using the robot's WiFi network or have modified the network configuration on the robot such that the robot has a non-default IP address you can change the IP address used when connecting to the robot in the Drive Station's setting. The settings options is usually under the three-dots menu. Hostnames can also be used and will be resolved using DNS.</p>"},{"location":"ref/manuals/android_drive_station/#enabling-and-disabling-the-robot","title":"Enabling and Disabling the Robot","text":"<p>At the bottom of the screen in the center there are two buttons: one labeled \"Disable\" and other labeled \"Enable\". These disable and enable the robot respectively. If the robot is already in the matching state the robot will just ignore the command, however you will still be able to click the button in the Mobile Drive Station.</p> <p>Above the Enable and Disable buttons there is a label that indicates the robot's state. It may read \"Enabled\", \"Disabled\", or \"Not Connected\" (if the Drive Station is not connected to the robot). It could also read \"Unknown\" if connected to the robot, but it is unknown whether the robot is enabled or disabled (this can happen when using older versions of the PythonLib or if network table issues occur).</p>"},{"location":"ref/manuals/android_drive_station/#using-the-virtual-gamepad","title":"Using the Virtual Gamepad","text":"<p>The on-screen virtual gamepad has two joysticks and fourteen buttons (four of which make up the D-Pad). The numbers for these joystick axes and buttons match those shown in the PC Drive Station's Controllers tab, but are also listed below.</p> <p>Axes</p> Axis Axis Number Left X Axis 0 Left Y Axis 1 Right X Axis 2 Right Y Axis 3 L2 Button 4 R2 Button 5 <p>Just like with a controller where the triggers are digital buttons, the L2 and R2 axes will either be 0 or 1.0 when read by the robot.</p> <p>Buttons</p> Button Button Number A 0 B 1 X 2 Y 3 Back 4 Start 6 L1 9 R1 10 <p>There is no button 5 as there is no \"Guide\" button on the virtual gamepad. There are no buttons 7 and 8 as the virtual gamepad's joysticks cannot be pressed as a button.</p> <p>Dpad</p> <p>Based on the direction buttons pressed on the virtual dpad the gamepad's D-Pad number 0 will have the following values</p> Direction Value None (Center) 0 North 1 Northeast 2 East 3 Southeast 4 South 5 Southwest 6 West 7 Northwest 8 <p>Unlike the PC Drive Station the virtual gamepad is always \"enabled\", meaning the Mobile Drive Station will send data for the virtual gamepad to the robot whenever the robot is connected. Data will be sent as gamepad number 0.</p>"},{"location":"ref/manuals/android_drive_station/#reading-logs","title":"Reading Logs","text":"<p>There are two logs visible from the Mobile Drive Station: the robot log and the drive station log. The Mobile Drive Station log will show errors, warnings, and other messages from the Mobile Drive Station, while the robot log will show messages received from the robot (this only displays messages from the robot after the drive station connects).</p> <p>To view logs tap the log button in the ActionBar (if it is not visible look under the three-dots menu). A screen with two tabs will open. One will display the robot log. The other will display the Mobile Drive Station log.</p>"},{"location":"ref/manuals/android_drive_station/#main-battery-voltage","title":"Main battery voltage","text":"<p>If a voltage monitor device is designated as the main voltage monitor on the robot, the Drive Station will display the voltage as determined by the sensor in a colored label above the status label. The battery voltage indicator will change color based on the percentage range of the voltage read compared to the nominal (as printed on label) battery voltage. The main battery voltage can be set in the Mobile Drive Station settings (look under the three-dot menu). This voltage should be the nominal voltage of the batteries in use. For example, with 5 AA batteries at 1.5V each the \"Main Battery Voltage\" should be 5 * 1.5 = 7.5. Most batteries exceed this value when fully charged or new (in the case of non-rechargeable batteries).</p> <p>The colors of the indicator by percentage level are as follows</p> <ul> <li>100% and above = Green</li> <li>85%-99% = Yellow</li> <li>70%-84% = Orange</li> <li>70% and below = Red</li> </ul> <p>Keep in mind that it is normal for the battery voltage to drop significantly when motor first start moving.</p>"},{"location":"ref/manuals/android_drive_station/#network-table-indicators","title":"Network Table Indicators","text":"<p>An indicator shows the value of a key / value pair from the Network Table. To add an indicator you will first need to open the Network Table screen (second icon from the left in the ActionBar or check under the three-dot menu).</p> <p>Once open, the Network Table screen will have its own three-dot menu. Under this menu tap \"Add Existing Indicator\". This will show a list of Network Table keys known form the robot. Select one to add it to the network table view.</p> <p>Indicators will appear in a list on the Network Table screen. If you leave this screen then return you will still have the same indicators in the list. To clear the indicators tap the \"Clear Indicators\" option in the three-dots menu.</p> <p>Unlike with the PC Drive Station there is currently no way to view indicators and drive the robot at the same time. There is also no way to create new network table key/value pairs or edit existing ones.</p>"},{"location":"ref/manuals/android_drive_station/#about-menu","title":"About Menu","text":"<p>The about menu can be accessed from the three-dot menu of the main screen. This will open the about screen which shows the Mobile Drive Station's license as well as the licenses of other software it makes use of.</p>"},{"location":"ref/manuals/deploy_tool/","title":"Deploy Tool Manual","text":"<p>The Deploy Tool is a program that runs on your computer with the primary purpose of deploying a robot program written on your computer to the robot via the robot's WiFi network. It is also used to configure the robot's computer.</p>"},{"location":"ref/manuals/deploy_tool/#uses-features","title":"Uses / Features","text":"<ul> <li>Connect via SSH* to the computer on the robot</li> <li>Show the CPU usage, memory usage, and writable status of the computer on the robot</li> <li>Show the image version, python version, ArPiRobot-Tools version, and PythonLib version in use on the robot</li> <li>Shutdown or reboot the robot, restart the running robot program, and switch between readonly and read/write states</li> <li>Deploy a program from your computer to the robot (such that the robot will run the program on boot)</li> <li>Configure the robot's computer's WiFi network settings (SSID, password, channel, country) and the hostname</li> <li>Send updates to and install updates on the robot</li> <li>Pull the full robot program log</li> </ul> <p>*This is a way of logging in to the computer over the network. Unlike the Drive Station which connects to a running robot program, the Deploy Tool connects to the robot's computer itself.</p>"},{"location":"ref/manuals/deploy_tool/#installing-and-running","title":"Installing and Running","text":"<p>The Deploy Tool is built and available for download in the following formats</p> <ul> <li><code>.exe</code> file - This is a windows installer that will install the Deploy Tool. Supports 64-bit x86 Windows (x86_64).</li> <li><code>.app.zip</code> - This is a zip file containing a macOS app for the Deploy Tool After extracting the zip you can drag the <code>.app</code> file to your Mac's <code>Applications</code> folder so the Deploy Tool will show up in Launchpad. Supports 64-bit x86 macOS (x86_64).</li> <li><code>.deb</code> file - This is a package that can be used to install the Deploy Tool on Ubuntu Linux (it should also work on other debian based systems using <code>.deb</code> packages). It depends on the required packages. Supports any architecture where PySide6 is available.</li> <li><code>.tar.gz</code> file - This is a package for any linux distribution. Python3, pip, and venv must be installed from system packages. Then, extract the package and run <code>install.sh</code>. Supports any architecture where PySide6 is available. </li> </ul>"},{"location":"ref/manuals/deploy_tool/#this-pc-tab","title":"This PC Tab","text":"<p>The \"This PC Tab\" is used to view or install different tools required for ArPiRobot program development on your computer.</p> <p>The \"ArPiRobot Libraries\" section is used to install libraries used to develop ArPiRobot programs. Currently, this is just the Core Library (ArPiRobot CoreLib). The version of the currently installed version will be displayed. Next to the version, the \"Install Update Package\" button can be used to select a downloaded CoreLib zip file to install a new version. This will be installed over any existing version (only one version of the CoreLib can be installed at a time).</p> <p>Below this section, there are sections for both C++ and Python development tools. It will show the currently installed version (if any) and sometimes have download links. Additionally, for C++ development tools, there is a button to install ArPiRobot Toolchain packages. Multiple toolchains can be installed (only one per architecture).</p>"},{"location":"ref/manuals/deploy_tool/#connecting-to-the-robot-connection-tab","title":"Connecting to the Robot (Connection Tab)","text":"<p>Until you connect to the robot you will not be able to access most other tabs in the Deploy Tool.</p> <p>Before connecting to the robot make sure your computer is connected to the Robot's WiFi network (the access point generated by the robot). Then make sure (in the Deploy Tool) that the robot's IP address, and login credentials are correct (the default settings are listed here). The initial settings are the default ones. If you make any changes to these settings they will be saved and reloaded the next time you run the Deploy Tool.</p> <p>Once you are sure the settings are correct click the connect button. The Deploy Tool will login to the robot's computer and the load information about what versions of different components are in use on the robot. Once this is done the \"Connecting\" progress dialog will close. If the connection fails you will see an error message dialog. After a successful connection the \"Connect\" button will become a \"Disconnect\" button, which can be clicked to disconnect from the robot.</p> <p>If you experience issues with the Deploy Tool getting disconnected frequently you can check the \"Use Longer Timeouts\" box on the connection tab, however if you have this issue with the Deploy Tool it is likely that you will run into other network related issues when controlling the robot using the Drive Station. You may want to consider changing the robot's WiFi network channel (described in the Network Settings section below) or following some of the WiFi debugging steps. </p>"},{"location":"ref/manuals/deploy_tool/#robot-program-tab","title":"Robot Program Tab","text":"<p>The robot program tab is used to deploy a robot program to the robot. First you must select the project folder. The project folder contains a file called <code>arpirobot-proj.json</code>. This file determines what files are copied to the robot when deployed.</p> <p>Once the project folder is selected click the \"Deploy to Robot\" button. This will start by making the computer's SD card read/write. Then it will stop the old robot program (this will cause the Drive Station to be disconnected if it is connected at the time). Then, the Deploy Tool will copy the required files from the project folder to the robot along with the version of the CoreLib installed on the computer with the robot. The new robot program will then be started. Finally, if the computer was readonly when the Deploy Started, it will be made readonly once again.</p> <p>Because the SD card is read/write during deploy, you should not unplug the computer while a robot program is being deployed.</p>"},{"location":"ref/manuals/deploy_tool/#robot-program-log-tab","title":"Robot Program Log Tab","text":"<p>This tab in the Deploy Tool is used to display the full robot program log. This will show the entire log since the program first started, unlike the Drive Station which will only show the portion of the log from after it connected. This log will also show errors that occur when starting the robot program. It will contain any output from the robot while running the program and is useful for debugging robot program crashes or finding errors that prevent the program from starting.</p> <p>The log is refreshed automatically once every second so you will have a hard time selecting and copying the text before the refresh happens (and unselects all text). Instead you can use the \"Copy Log Contents\" button to copy the text from the log.</p>"},{"location":"ref/manuals/deploy_tool/#robot-status-tab","title":"Robot Status Tab","text":"<p>The robot status tab is divided into three sections. The section at the bottom labeled \"Robot Actions\" has five buttons that perform different actions on the robot's computer.</p> <ul> <li>Shutdown will power the robot's computer off (this is the safe way to turn the Pi off if it is read/write)</li> <li>Reboot will restart the robot's computer</li> <li>Restart Program will stop any running robot program then start it again.</li> <li>Make Readonly will make the computer's SD card readonly</li> <li>Make Read/Write will make the computer's SD card read/write</li> </ul> <p>Above the \"Robot Actions\" section there are two other sections. On the left is the \"Robot Status\" section. This section will show you the robot's computer's CPU Usage, memory (RAM) usage, and the state of it's SD card's filesystem (readonly or read/write).</p> <p>On the right side is a \"Versions\" panel. This shows three different versions</p> <ul> <li>Image Version - The name of the image in use on the robot</li> <li>ArPiRobot Tools Version - This is the version of the installed ArPiRobot Tools (installed via updates)</li> <li>Python Version - The full version number of the python interpreter installed on the robot (this is the version of python that will be used when running robot programs)</li> </ul>"},{"location":"ref/manuals/deploy_tool/#network-settings-tab","title":"Network Settings Tab","text":"<p>The network settings tab is divided into two sections. First is the \"Robot Hostname\" section. In this section you can view and/or change the robot's hostname. This is just the name of the robot's computer on the network. There is generally no reason to change this as the computer will have a known IP address (<code>192.168.10.1</code>) on its own WiFi network, however you can edit the hostname then click the \"Change &amp; Reboot\" button. This will change the hostname then reboot the computer so the change takes effect. This will cause the Deploy Tool to disconnect. After rebooting, you will also likely need to reconnect your computer to the robot's WiFi network before you can reconnect with the Deploy Tool. It may take the computer a couple of minutes to reboot.</p> <p>The more frequently used section is the \"Robot Access Point\" section. In this section you can adjust settings for the WiFi network generated by the robot's computer. The SSID is the network's name. The password is a WPA-2 passphrase (between 8 and 64 characters) for the WiFi network (this is the network's password). The country code is a two letter indication of which country the robot is in use in. This is important as some WiFi channels are not allowed in some countries. By default this is set to \"US\". You can find a list of country codes here. The final setting in this section is the WiFi channel. This is one of the 2.4GHz channels (numbered 1 to 14). In the United States only 1 to 11 are allowed. In most of the rest of the world 1 to 13 are allowed. If you set a channel that is not allowed based on the country code set you will loose access to the robot's WiFi network. The robot will not generate a WiFi network on a channel that is disallowed based on the country code. If you do this you will probably need to re-flash the SD card to recover the robot.</p>"},{"location":"ref/manuals/deploy_tool/#camera-stream-tab","title":"Camera Stream Tab","text":"<p>The camera stream tab is used to configure and play video streams from cameras connected to the robot's computer. </p> <p>The first section, \"Stream\", is used to configure different camera feeds. Configured camera streams will be shown in the dropdown. The three buttons below can be used to create new feed configurations, delete existing ones, or edit existing ones. The new / edit dialog has many options to configure each individual stream.</p> <p>The second section, \"Playback\", is used to play a selected stream. The stream must first be selected in the dropdown in the \"Stream\" section. Then, a playback tool can be chosen in the dropdown labeled \"Player\". Currently three tools are supported (and must be installed separately). These are mpv, ffplay, and mplayer. Mpv is generally recommended, however ffplay may be more compatible in some circumstances.  Once a player is selected, a stream can be opened (played) using the \"Play Stream\" button.</p> <p>Finally, the \"System Configuration\" section is used to configure both the camera stream service and the rtsp server service. The camera stream service runs all configured streams when started. The rtsp server service starts an rtsp server (used by default to run camera streams). For each, there is a button to manually start or stop the service. Additionally, there is a checkbox to start the service on boot (it is recommended to start both on boot if using camera streams).</p>"},{"location":"ref/manuals/deploy_tool/#about-menu","title":"About Menu","text":"<p>The Deploy Tool's about menu can be accessed by clicking <code>File &gt; About</code>. This will open an about dialog with information about the Deploy Tool's license as well as information about the licenses of third party software used by the Deploy Tool. In addition, in the title of the dialog (as in the title of the main Deploy Tool window) you will see the version number of the Deploy Tool.</p>"},{"location":"ref/manuals/drive_station/","title":"Drive Station Manual","text":"<p>The ArPiRobot Drive Station is the program for your computer (Windows, macOS, Linux) that is used to control the robot. Its primary function is to enable/disable the robot and send data from a gamepad connected to your computer to the robot via WiFi.</p> <p></p>"},{"location":"ref/manuals/drive_station/#uses-features","title":"Uses / Features","text":"<ul> <li>Connect to a running robot program over the Raspberry Pi's WiFi network</li> <li>Enable and Disable the Robot</li> <li>Show the status (enabled / disabled) of the robot</li> <li>Show and test connected gamepads</li> <li>Use one or more gamepads to control the robot</li> <li>Show logs sent from the robot after connecting the Drive Station</li> <li>Show the value of NetworkTable key / value pairs form the robot</li> <li>Create or edit NetworkTable key / value pairs on the robot</li> <li>Save and load configurations of shown NetworkTable values and their sizes / positions on the screen</li> </ul>"},{"location":"ref/manuals/drive_station/#installing-and-running","title":"Installing and Running","text":"<p>The Drive Station is built and available for download in the following formats</p> <ul> <li><code>.exe</code> file - This is a windows installer that will install the Drive Station. Supports 64-bit x86 Windows (x86_64).</li> <li><code>.app.zip</code> - This is a zip file containing a macOS app for the Drive Station. After extracting the zip you can drag the <code>.app</code> file to your Mac's <code>Applications</code> folder so the Drive Station will show up in Launchpad. Supports 64-bit x86 macOS (x86_64).</li> <li><code>.deb</code> file - This is a package that can be used to install the Drive Station on Ubuntu Linux (it should also work on other debian based systems using <code>.deb</code> packages). It depends on the required packages. Supports any architecture where PySide6 is available.</li> <li><code>.tar.gz</code> file - This is a package for any linux distribution. Python3, pip, and venv must be installed from system packages. Then, extract the package and run <code>install.sh</code>. Supports any architecture where PySide6 is available. </li> </ul>"},{"location":"ref/manuals/drive_station/#connecting-to-the-robot","title":"Connecting to the Robot","text":"<p>Before attempting to connect to the robot you will need to make sure your computer is connected to the WiFi network created by the robot. It may also be necessary to disconnect from other networks (such as ethernet).</p> <p>Once your computer is connected to the robot's WiFi the drive station will automatically connect. When this occurs the \"Network\" indicator will become green. If there is a program running on the robot, the \"Robot Program\" indicator will turn green too (indicating the drive station is fully connected). However, if no program is running one must be started before the drive station will fully connect (the drive station connects to the program running on the robot, not to the robot itself).</p> <p>Only one Drive Station can be connected to the robot at a time.</p> <p>If you are not using the robot's WiFi network or have modified the network configuration on the robot such that the robot has a non-default IP address you can change the IP address used when connecting to the robot in the Drive Station's settings (settings icon in bottom right). Hostnames can also be used and will be resolved using DNS.</p>"},{"location":"ref/manuals/drive_station/#enabling-and-disabling-the-robot","title":"Enabling and Disabling the Robot","text":"<p>In the bottom left corner of the drive station window, there are two buttons: one labeled \"Disable\" and another labeled \"Enable\". These disable and enable the robot respectively.</p> <p>The robot's current state will be indicated by \"lowering\" one of these buttons. The lowered button matches the state of the robot (ie if the \"Disable\" button is lowered the robot is currently disabled).</p>"},{"location":"ref/manuals/drive_station/#selecting-and-using-gamepads","title":"Selecting and Using Gamepads","text":"<p>When the \"Controllers\" tab in the bottom half of the Drive Station is selected you will see on the left side of the screen a section labeled \"Controllers\". Any gamepads connected to your PC will be listed in this section with their name beside a checkbox. </p> <p>You can drag the gamepads in the list to reorder them. The topmost gamepad will be gamepad 0. The next one will be gamepad 1, then gamepad 2, and so on. Each gamepad's number is indicated before it's name in parenthesis.</p> <p>To \"enable\" a gamepad so that the drive station sends data from it to the robot it is connected to you will need to check the checkbox beside the gamepad's name. The Drive Station will send the data from each checked gamepad to the robot. Uncheck any gamepad to stop sending its data to the robot. Whether or not gamepads are checked does not change the number order of the gamepads. For example, if the top gamepad is unchecked, but the next one is checked the checked gamepad will still be gamepad number 1 and the robot will not receive data from gamepad 0 (even though it does receive data for gamepad 1).</p> <p>If a gamepad is disconnected from the computer the Drive Station will remove it from the list. This can change the number of other controllers. As such, the drive station automatically disables the robot when this occurs.</p> <p>Beside the gamepad list there are a set of indicators that show the values of the axes, buttons, and dpad of the selected gamepad. To \"select\" a gamepad and see it's controls values in this section click on its name in the controller list. It will have a different background color to indicate that it is the selected controller. While selected, any action performed with the gamepad will be shown by the axis, button, or dpad indicators.</p>"},{"location":"ref/manuals/drive_station/#reading-logs","title":"Reading Logs","text":"<p>There are two logs visible from the Drive Station: the robot log and the drive station log. The Drive Station log will show errors, warnings, and other messages from the Drive Station, while the robot log will show messages received from the robot (this only displays messages from the robot after the drive station connects).</p> <p>There are four log levels. The lower the level the more detailed the information that will be shown. Both the robot and drive station logs have these same levels.</p> <ol> <li>Debug</li> <li>Info</li> <li>Warning</li> <li>Error</li> </ol> <p>All four levels of log messages will be shown in the drive station log windows.</p>"},{"location":"ref/manuals/drive_station/#main-battery-voltage","title":"Main Battery Voltage","text":"<p>If a voltage monitor device is designated as the main voltage monitor on the robot, the Drive Station will display the voltage as determined by the sensor in the lower center of the Drive Station window. The battery voltage indicator will change color based on the percentage range of the voltage read compared to the nominal (as printed on label) battery voltage. The main battery voltage can be set in the Drive Station settings. This voltage should be the nominal voltage of the batteries in use. For example, with 5 AA batteries at 1.5V each the \"Main Battery Voltage\" should be 5 * 1.5 = 7.5. Most batteries exceed this value when fully charged or new (in the case of non-rechargeable batteries).</p> <p>The colors of the indicator by percentage level are as follows</p> <ul> <li>100% and above = Green</li> <li>85%-99% = Yellow</li> <li>70%-84% = Orange</li> <li>70% and below = Red</li> </ul> <p>Keep in mind that it is normal for the battery voltage to drop significantly when motor first start moving.</p>"},{"location":"ref/manuals/drive_station/#networktable-indicators","title":"NetworkTable Indicators","text":"<p>An indicator shows the value of a key / value pair from the Network Table. You can add indicators in two ways:</p> <ul> <li>By creating a new indicator (and if it does not exist a corresponding key / value pair in the Network Table)</li> <li>By adding an indicator for existing key / value pairs received from the robot or already known to the drive station</li> </ul> <p>The top portion of the drive station is the indicators panel. In this boxed in area any indicators you add are shown and can be resized and moved around any way you want.</p> <p>To create a new indicator click <code>Network Table &gt; Add New</code>. Then enter a key name in the dialog and click OK. You can only have one indicator for any key / value pair.</p> <p>To add an indicator for an existing key / value pair select an existing key under <code>Network Table &gt; Add From Robot</code>. This menu will display any keys that the robot program has previously written.</p> <p>Once an indicator is on the panel it can be deleted (removed from the panel, but not the Network Table) by right clicking it and choosing delete. Additionally, all indicators can be removed from the indicators panel by using the <code>Network Table &gt; Clear Indicators</code> option. </p> <p>You can also edit the value of an indicator (and change the corresponding value on the Network Table) by right clicking and making the indicator editable. You will then be able to type values in the text field next to the indicator's label. Uncheck \"Editable\" in the right click menu to disable editing an indicator. Setting the value of an indicator is an easy way to send small amounts of information to the robot.</p> <p>To resize an indicator click the label. The drag the left or right edges of the box drawn around it to resize the indicator. To move the indicator, click and drag the indicator's label.</p> <p>Be aware that positions in the indicators panel are \"absolute\" meaning if you resize the Drive Station window it is possible to move an indicator off the screen. For this reason it is recommended to keep the Drive Station the same size at all times. The two easy ways to do this are to use the default size or to always maximize the window.</p> <p>Finally, note that the displayed indicators (including positions and sizes) are saved when the drive station is closed and restored the next time it is opened.</p>"},{"location":"ref/manuals/drive_station/#about-menu","title":"About Menu","text":"<p>Can be accessed by clicking <code>File &gt; About</code>. An about dialog will open up with information about the license of the Drive Station and the other software it makes use of.</p>"},{"location":"ref/manuals/drive_station/#drive-station-themes","title":"Drive Station Themes","text":"<p>The drive station supports two themes: a light theme and a dark theme. The theme can be selected in the settings dialog. Additionally, there is an option to increase font sizes when using either theme.</p>"}]}